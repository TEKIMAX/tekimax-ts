{"version":3,"sources":["/Users/erunion/code/readme/oas/packages/oas-normalize/dist/chunk-HIUYACR6.cjs","../src/lib/utils.ts"],"names":[],"mappings":"AAAA;ACAA,iFAAkC;AAGlC,uDAA8B;AAOvB,SAAS,QAAA,CAAS,GAAA,EAAmB;AAC1C,EAAA,OACE,IAAA,GAAO,KAAA,GACP,GAAA,CAAI,YAAA,GAAe,KAAA,GACnB,OAAO,GAAA,CAAI,WAAA,CAAY,SAAA,IAAa,WAAA,GACpC,CAAC,CAAC,GAAA,CAAI,WAAA,CAAY,QAAA,CAAS,GAAG,CAAA;AAElC;AAMO,SAAS,UAAA,CAAW,GAAA,EAAoD;AAC7E,EAAA,MAAM,QAAA,EAAuB,CAAC,CAAA;AAC9B,EAAA,MAAM,EAAA,EAAI,IAAI,GAAA,CAAI,GAAG,CAAA;AAIrB,EAAA,GAAA,CAAI,CAAA,CAAE,SAAA,GAAY,CAAA,CAAE,QAAA,EAAU;AAC5B,IAAA,OAAA,CAAQ,QAAA,EAAU;AAAA,MAChB,aAAA,EAAe,CAAA,MAAA,EAAS,IAAA,CAAK,CAAA,EAAA;AAC/B,IAAA;AAEa,IAAA;AACA,IAAA;AACf,EAAA;AAGiC,EAAA;AACtB,IAAA;AACuB,IAAA;AAClC,EAAA;AAEO,EAAA;AACW,IAAA;AAChB,IAAA;AACF,EAAA;AACF;AAO8G;AACzF,EAAA;AACV,IAAA;AACiB,EAAA;AACjB,IAAA;AACiB,EAAA;AACD,IAAA;AACd,MAAA;AACmB,IAAA;AAEnB,MAAA;AACoB,IAAA;AACpB,MAAA;AACT,IAAA;AAEO,IAAA;AACT,EAAA;AAEO,EAAA;AACT;AAMoE;AAClD,EAAA;AAClB;AAaoE;AACjC,EAAA;AACnC;AAMoE;AAClD,EAAA;AAClB;AAMgG;AAC9D,EAAA;AACvB,IAAA;AACyB,EAAA;AACR,IAAA;AAC1B,EAAA;AAE2B,EAAA;AAC7B;AAM0E;AAC5C,EAAA;AAC9B;AAMqC;AACZ,EAAA;AACd,IAAA;AACqB,EAAA;AACrB,IAAA;AACqB,EAAA;AACrB,IAAA;AACT,EAAA;AAEO,EAAA;AACT;ADvEoC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/Users/erunion/code/readme/oas/packages/oas-normalize/dist/chunk-HIUYACR6.cjs","sourcesContent":[null,"import YAML, { JSON_SCHEMA } from 'js-yaml';\n\n// biome-ignore lint/performance/noBarrelFile: This isn't a barrel file, we're re-exporting a function from another package.\nexport { compileErrors } from '@readme/openapi-parser';\n\n/**\n * Determine if a given variable is a `Buffer`.\n *\n */\n// biome-ignore lint/suspicious/noExplicitAny: This is a type guard.\nexport function isBuffer(obj: any): boolean {\n  return (\n    obj != null &&\n    obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' &&\n    !!obj.constructor.isBuffer(obj)\n  );\n}\n\n/**\n * Deconstruct a URL into a payload for a `fetch` request.\n *\n */\nexport function prepareURL(url: string): { options: RequestInit; url: string } {\n  const options: RequestInit = {};\n  const u = new URL(url);\n\n  // `fetch` doesn't support supplying basic auth credentials in the URL so we need to move them\n  // into a header.\n  if (u.username || u.password) {\n    options.headers = {\n      Authorization: `Basic ${btoa(`${u.username}:${u.password}`)}`,\n    };\n\n    u.username = '';\n    u.password = '';\n  }\n\n  // Transform GitHub sources into their raw content URLs.\n  if (u.host === 'github.com' && u.pathname.includes('/blob/')) {\n    u.host = 'raw.githubusercontent.com';\n    u.pathname = u.pathname.replace('/blob/', '/');\n  }\n\n  return {\n    url: u.toString(),\n    options,\n  };\n}\n\n/**\n * Determine the type of a given variable. Returns `false` if unrecognized.\n *\n */\n// biome-ignore lint/suspicious/noExplicitAny: This function handles type narrowing.\nexport function getType(obj: any): 'buffer' | 'json' | 'path' | 'string-json' | 'string-yaml' | 'url' | false {\n  if (isBuffer(obj)) {\n    return 'buffer';\n  } else if (typeof obj === 'object') {\n    return 'json';\n  } else if (typeof obj === 'string') {\n    if (obj.match(/\\s*{/)) {\n      return 'string-json';\n    } else if (obj.match(/\\n/)) {\n      // Not sure about this...\n      return 'string-yaml';\n    } else if (obj.substring(0, 4) === 'http') {\n      return 'url';\n    }\n\n    return 'path';\n  }\n\n  return false;\n}\n\n/**\n * Determine if a given schema if an OpenAPI definition.\n *\n */\nexport function isOpenAPI(schema: Record<string, unknown>): boolean {\n  return !!schema.openapi;\n}\n\n/**\n * Determine if a given schema is a Postman collection.\n *\n * Unfortunately the Postman schema spec doesn't have anything like `openapi` or `swagger` for us\n * to look at but it does require that `info` and `item` be present and as `item` doesn't exist in\n * OpenAPI or Swagger we can use the combination of those two properties to determine if what we\n * have is a Postman collection.\n *\n * @see {@link https://schema.postman.com/json/collection/v2.0.0/collection.json}\n * @see {@link https://schema.postman.com/json/collection/v2.1.0/collection.json}\n */\nexport function isPostman(schema: Record<string, unknown>): boolean {\n  return !!schema.info && !!schema.item;\n}\n\n/**\n * Determine if a given schema if an Swagger definition.\n *\n */\nexport function isSwagger(schema: Record<string, unknown>): boolean {\n  return !!schema.swagger;\n}\n\n/**\n * Convert a YAML blob or stringified JSON object into a JSON object.\n *\n */\nexport function stringToJSON(string: Record<string, unknown> | string): Record<string, unknown> {\n  if (typeof string === 'object') {\n    return string;\n  } else if (string.match(/^\\s*{/)) {\n    return JSON.parse(string);\n  }\n\n  return YAML.load(string, { schema: JSON_SCHEMA }) as Record<string, unknown>;\n}\n\n/**\n * Determine if a given schema is an API definition that we can support.\n *\n */\nexport function isAPIDefinition(schema: Record<string, unknown>): boolean {\n  return isOpenAPI(schema) || isPostman(schema) || isSwagger(schema);\n}\n\n/**\n * Retrieve the type of API definition that a given schema is.\n *\n */\nexport function getAPIDefinitionType(schema: Record<string, unknown>): 'openapi' | 'postman' | 'swagger' | 'unknown' {\n  if (isOpenAPI(schema)) {\n    return 'openapi';\n  } else if (isPostman(schema)) {\n    return 'postman';\n  } else if (isSwagger(schema)) {\n    return 'swagger';\n  }\n\n  return 'unknown';\n}\n"]}