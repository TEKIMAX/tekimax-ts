{"version":3,"sources":["../src/lib/utils.ts"],"sourcesContent":["import YAML, { JSON_SCHEMA } from 'js-yaml';\n\n// biome-ignore lint/performance/noBarrelFile: This isn't a barrel file, we're re-exporting a function from another package.\nexport { compileErrors } from '@readme/openapi-parser';\n\n/**\n * Determine if a given variable is a `Buffer`.\n *\n */\n// biome-ignore lint/suspicious/noExplicitAny: This is a type guard.\nexport function isBuffer(obj: any): boolean {\n  return (\n    obj != null &&\n    obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' &&\n    !!obj.constructor.isBuffer(obj)\n  );\n}\n\n/**\n * Deconstruct a URL into a payload for a `fetch` request.\n *\n */\nexport function prepareURL(url: string): { options: RequestInit; url: string } {\n  const options: RequestInit = {};\n  const u = new URL(url);\n\n  // `fetch` doesn't support supplying basic auth credentials in the URL so we need to move them\n  // into a header.\n  if (u.username || u.password) {\n    options.headers = {\n      Authorization: `Basic ${btoa(`${u.username}:${u.password}`)}`,\n    };\n\n    u.username = '';\n    u.password = '';\n  }\n\n  // Transform GitHub sources into their raw content URLs.\n  if (u.host === 'github.com' && u.pathname.includes('/blob/')) {\n    u.host = 'raw.githubusercontent.com';\n    u.pathname = u.pathname.replace('/blob/', '/');\n  }\n\n  return {\n    url: u.toString(),\n    options,\n  };\n}\n\n/**\n * Determine the type of a given variable. Returns `false` if unrecognized.\n *\n */\n// biome-ignore lint/suspicious/noExplicitAny: This function handles type narrowing.\nexport function getType(obj: any): 'buffer' | 'json' | 'path' | 'string-json' | 'string-yaml' | 'url' | false {\n  if (isBuffer(obj)) {\n    return 'buffer';\n  } else if (typeof obj === 'object') {\n    return 'json';\n  } else if (typeof obj === 'string') {\n    if (obj.match(/\\s*{/)) {\n      return 'string-json';\n    } else if (obj.match(/\\n/)) {\n      // Not sure about this...\n      return 'string-yaml';\n    } else if (obj.substring(0, 4) === 'http') {\n      return 'url';\n    }\n\n    return 'path';\n  }\n\n  return false;\n}\n\n/**\n * Determine if a given schema if an OpenAPI definition.\n *\n */\nexport function isOpenAPI(schema: Record<string, unknown>): boolean {\n  return !!schema.openapi;\n}\n\n/**\n * Determine if a given schema is a Postman collection.\n *\n * Unfortunately the Postman schema spec doesn't have anything like `openapi` or `swagger` for us\n * to look at but it does require that `info` and `item` be present and as `item` doesn't exist in\n * OpenAPI or Swagger we can use the combination of those two properties to determine if what we\n * have is a Postman collection.\n *\n * @see {@link https://schema.postman.com/json/collection/v2.0.0/collection.json}\n * @see {@link https://schema.postman.com/json/collection/v2.1.0/collection.json}\n */\nexport function isPostman(schema: Record<string, unknown>): boolean {\n  return !!schema.info && !!schema.item;\n}\n\n/**\n * Determine if a given schema if an Swagger definition.\n *\n */\nexport function isSwagger(schema: Record<string, unknown>): boolean {\n  return !!schema.swagger;\n}\n\n/**\n * Convert a YAML blob or stringified JSON object into a JSON object.\n *\n */\nexport function stringToJSON(string: Record<string, unknown> | string): Record<string, unknown> {\n  if (typeof string === 'object') {\n    return string;\n  } else if (string.match(/^\\s*{/)) {\n    return JSON.parse(string);\n  }\n\n  return YAML.load(string, { schema: JSON_SCHEMA }) as Record<string, unknown>;\n}\n\n/**\n * Determine if a given schema is an API definition that we can support.\n *\n */\nexport function isAPIDefinition(schema: Record<string, unknown>): boolean {\n  return isOpenAPI(schema) || isPostman(schema) || isSwagger(schema);\n}\n\n/**\n * Retrieve the type of API definition that a given schema is.\n *\n */\nexport function getAPIDefinitionType(schema: Record<string, unknown>): 'openapi' | 'postman' | 'swagger' | 'unknown' {\n  if (isOpenAPI(schema)) {\n    return 'openapi';\n  } else if (isPostman(schema)) {\n    return 'postman';\n  } else if (isSwagger(schema)) {\n    return 'swagger';\n  }\n\n  return 'unknown';\n}\n"],"mappings":";AAAA,OAAO,QAAQ,mBAAmB;AAGlC,SAAS,qBAAqB;AAOvB,SAAS,SAAS,KAAmB;AAC1C,SACE,OAAO,QACP,IAAI,eAAe,QACnB,OAAO,IAAI,YAAY,aAAa,cACpC,CAAC,CAAC,IAAI,YAAY,SAAS,GAAG;AAElC;AAMO,SAAS,WAAW,KAAoD;AAC7E,QAAM,UAAuB,CAAC;AAC9B,QAAM,IAAI,IAAI,IAAI,GAAG;AAIrB,MAAI,EAAE,YAAY,EAAE,UAAU;AAC5B,YAAQ,UAAU;AAAA,MAChB,eAAe,SAAS,KAAK,GAAG,EAAE,QAAQ,IAAI,EAAE,QAAQ,EAAE,CAAC;AAAA,IAC7D;AAEA,MAAE,WAAW;AACb,MAAE,WAAW;AAAA,EACf;AAGA,MAAI,EAAE,SAAS,gBAAgB,EAAE,SAAS,SAAS,QAAQ,GAAG;AAC5D,MAAE,OAAO;AACT,MAAE,WAAW,EAAE,SAAS,QAAQ,UAAU,GAAG;AAAA,EAC/C;AAEA,SAAO;AAAA,IACL,KAAK,EAAE,SAAS;AAAA,IAChB;AAAA,EACF;AACF;AAOO,SAAS,QAAQ,KAAsF;AAC5G,MAAI,SAAS,GAAG,GAAG;AACjB,WAAO;AAAA,EACT,WAAW,OAAO,QAAQ,UAAU;AAClC,WAAO;AAAA,EACT,WAAW,OAAO,QAAQ,UAAU;AAClC,QAAI,IAAI,MAAM,MAAM,GAAG;AACrB,aAAO;AAAA,IACT,WAAW,IAAI,MAAM,IAAI,GAAG;AAE1B,aAAO;AAAA,IACT,WAAW,IAAI,UAAU,GAAG,CAAC,MAAM,QAAQ;AACzC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAMO,SAAS,UAAU,QAA0C;AAClE,SAAO,CAAC,CAAC,OAAO;AAClB;AAaO,SAAS,UAAU,QAA0C;AAClE,SAAO,CAAC,CAAC,OAAO,QAAQ,CAAC,CAAC,OAAO;AACnC;AAMO,SAAS,UAAU,QAA0C;AAClE,SAAO,CAAC,CAAC,OAAO;AAClB;AAMO,SAAS,aAAa,QAAmE;AAC9F,MAAI,OAAO,WAAW,UAAU;AAC9B,WAAO;AAAA,EACT,WAAW,OAAO,MAAM,OAAO,GAAG;AAChC,WAAO,KAAK,MAAM,MAAM;AAAA,EAC1B;AAEA,SAAO,KAAK,KAAK,QAAQ,EAAE,QAAQ,YAAY,CAAC;AAClD;AAMO,SAAS,gBAAgB,QAA0C;AACxE,SAAO,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM;AACnE;AAMO,SAAS,qBAAqB,QAAgF;AACnH,MAAI,UAAU,MAAM,GAAG;AACrB,WAAO;AAAA,EACT,WAAW,UAAU,MAAM,GAAG;AAC5B,WAAO;AAAA,EACT,WAAW,UAAU,MAAM,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;","names":[]}