{"version":3,"sources":["/Users/erunion/code/readme/oas/packages/oas-normalize/dist/index.cjs","../src/index.ts"],"names":[],"mappings":"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","file":"/Users/erunion/code/readme/oas/packages/oas-normalize/dist/index.cjs","sourcesContent":[null,"import type { ParserOptions, ValidationResult } from '@readme/openapi-parser';\nimport type { OpenAPI, OpenAPIV2, OpenAPIV3 } from 'openapi-types';\nimport type { Options } from './lib/types.js';\n\nimport fs from 'node:fs';\n\nimport { bundle, compileErrors, dereference, validate } from '@readme/openapi-parser';\nimport postmanToOpenAPI from '@readme/postman-to-openapi';\nimport converter from 'swagger2openapi';\n\nimport { ValidationError } from './lib/errors.js';\nimport {\n  getAPIDefinitionType,\n  getType,\n  isOpenAPI,\n  isPostman,\n  isSwagger,\n  prepareURL,\n  stringToJSON,\n} from './lib/utils.js';\n\n// biome-ignore lint/style/noDefaultExport: This is fine for now.\nexport default class OASNormalize {\n  cache: {\n    bundle?: OpenAPI.Document | false;\n    convert?: OpenAPI.Document | false;\n    deref?: OpenAPI.Document | false;\n    load?: Record<string, unknown> | false;\n  };\n\n  // biome-ignore lint/suspicious/noExplicitAny: Intentionally loose because this library supports a wide variety of inputs.\n  file: any;\n\n  opts: Options;\n\n  type: ReturnType<typeof getType>;\n\n  // biome-ignore lint/suspicious/noExplicitAny: Intentionally loose because this library supports a wide variety of inputs.\n  constructor(file: any, opts?: Options) {\n    this.file = file;\n    this.opts = {\n      colorizeErrors: false,\n      enablePaths: false,\n      parser: {},\n      ...opts,\n    };\n\n    if (!this.opts.enablePaths) {\n      if (!this.opts.parser) this.opts.parser = {};\n      if (!this.opts.parser.resolve) this.opts.parser.resolve = {};\n      this.opts.parser.resolve = { file: false };\n    }\n\n    this.type = getType(this.file);\n\n    this.cache = {\n      load: false,\n      bundle: false,\n      deref: false,\n    };\n  }\n\n  /**\n   * Load and return the API definition that `oas-normalize` was initialized with.\n   *\n   */\n  async load(): Promise<Record<string, unknown>> {\n    if (this.cache.load) return this.cache.load;\n\n    const resolve = (obj: Parameters<typeof stringToJSON>[0]) => {\n      const ret = stringToJSON(obj);\n      this.cache.load = ret;\n      return ret;\n    };\n\n    switch (this.type) {\n      case 'json':\n      case 'string-json':\n      case 'string-yaml':\n        return resolve(this.file);\n\n      case 'buffer':\n        return resolve(this.file.toString());\n\n      case 'url': {\n        const { url, options } = prepareURL(this.file);\n        const resp = await fetch(url, options).then(res => res.text());\n        return resolve(resp);\n      }\n\n      case 'path': {\n        // Load a local file\n        if (!this.opts.enablePaths) {\n          throw new Error('Use `opts.enablePaths` to enable accessing local files.');\n        }\n\n        const contents = fs.readFileSync(this.file).toString();\n        if (!contents.trim()) {\n          throw new Error('No file contents found.');\n        }\n        return resolve(contents);\n      }\n\n      default:\n        throw new Error('Could not load this file.');\n    }\n  }\n\n  private static async convertPostmanToOpenAPI(schema: Record<string, unknown>) {\n    return postmanToOpenAPI(JSON.stringify(schema), undefined, {\n      outputFormat: 'json',\n      replaceVars: true,\n    }).then(JSON.parse);\n  }\n\n  /**\n   * Bundle up the given API definition, resolving any external `$ref` pointers in the process.\n   *\n   */\n  async bundle(): Promise<OpenAPI.Document> {\n    if (this.cache.bundle) return this.cache.bundle;\n    const parserOptions = this.opts.parser || {};\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to bundle we'll still\n        // upconvert it to an OpenAPI definition file so our returned dataset is always one of\n        // those for a Postman dataset.\n        if (isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => bundle(schema, parserOptions))\n      .then(bundled => {\n        this.cache.bundle = bundled;\n        return bundled;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   */\n  async dereference(): Promise<OpenAPI.Document> {\n    if (this.cache.deref) return this.cache.deref;\n    const parserOptions = this.opts.parser || {};\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to dereference we'll\n        // still upconvert it to an OpenAPI definition file so our returned dataset is always one\n        // of those for a Postman dataset.\n        if (isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => dereference(schema, parserOptions))\n      .then(dereferenced => {\n        this.cache.deref = dereferenced;\n        return dereferenced;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   * This method is deprecated in favor of `dereference`. It will be removed in a future release.\n   *\n   * @deprecated\n   */\n  async deref(): Promise<OpenAPI.Document> {\n    return this.dereference();\n  }\n\n  /**\n   * Convert a given API definition to OpenAPI if it is not already.\n   *\n   */\n  async convert(): Promise<OpenAPI.Document> {\n    if (this.cache.convert) return this.cache.convert;\n\n    return this.load()\n      .then(async schema => {\n        // If we have a Postman collection we need to convert it to OpenAPI.\n        return isPostman(schema) ? OASNormalize.convertPostmanToOpenAPI(schema) : schema;\n      })\n      .then(async schema => {\n        if (!isSwagger(schema) && !isOpenAPI(schema)) {\n          throw new Error('The supplied API definition is unsupported.');\n        } else if (isOpenAPI(schema)) {\n          return schema;\n        }\n\n        const baseVersion = parseInt(schema.swagger, 10);\n        if (baseVersion === 1) {\n          throw new Error('Swagger v1.2 is unsupported.');\n        }\n\n        return converter\n          .convertObj(schema, { anchors: true })\n          .then((options: { openapi: OpenAPI.Document }) => options.openapi);\n      });\n  }\n\n  /**\n   * Validate a given API definition.\n   *\n   * If supplied a Postman collection it will be converted to OpenAPI first and then run through\n   * standard OpenAPI validation.\n   *\n   */\n  async validate(\n    opts: {\n      /**\n       * Options to supply to our OpenAPI parser. See `@readme/openapi-parser` for documentation.\n       * This option is deprecated in favor of the `parser` option on the constructor. It will be\n       * removed in a future release.\n       *\n       * @see {@link https://npm.im/@readme/openapi-parser}\n       * @deprecated\n       */\n      parser?: ParserOptions;\n\n      /**\n       * Determines if `.validate()` should throw a `ValidationError` if the API definition is\n       * invalid.\n       *\n       * By default this will always happen however if you want to always instead receive a\n       * `ValidationResult` object back, which will still allow you to determine if the supplied\n       * API definition is valid or not, you can set this to `false`.\n       */\n      shouldThrowIfInvalid?: boolean;\n    } = {},\n  ): Promise<ValidationResult> {\n    const shouldThrowIfInvalid = opts.shouldThrowIfInvalid ?? true;\n    const parserOptions = opts.parser || this.opts.parser || {};\n    if (!parserOptions.validate) parserOptions.validate = {};\n    if (!parserOptions.validate.errors) parserOptions.validate.errors = {};\n\n    parserOptions.validate.errors.colorize = this.opts.colorizeErrors;\n\n    return this.load()\n      .then(async schema => {\n        // Because we don't have something akin to `openapi-parser` for Postman collections we just\n        // always convert them to OpenAPI.\n        return isPostman(schema) ? OASNormalize.convertPostmanToOpenAPI(schema) : schema;\n      })\n      .then(async schema => {\n        if (!isSwagger(schema) && !isOpenAPI(schema)) {\n          if (shouldThrowIfInvalid) {\n            throw new ValidationError('The supplied API definition is unsupported.');\n          }\n\n          return {\n            valid: false,\n            errors: [{ message: 'The supplied API definition is unsupported.' }],\n            warnings: [],\n            additionalErrors: 0,\n            specification: null,\n          };\n        } else if (isSwagger(schema)) {\n          const baseVersion = parseInt(schema.swagger, 10);\n          if (baseVersion === 1) {\n            if (shouldThrowIfInvalid) {\n              throw new ValidationError('Swagger v1.2 is unsupported.');\n            }\n\n            return {\n              valid: false,\n              errors: [{ message: 'Swagger v1.2 is unsupported.' }],\n              warnings: [],\n              additionalErrors: 0,\n              specification: 'Swagger',\n            };\n          }\n        }\n\n        /**\n         * `OpenAPIParser.validate()` dereferences schemas at the same time as validation, mutating\n         * the supplied parameter in the process, and does not give us an option to disable this.\n         * As we already have a dereferencing method on this library, and this method just needs to\n         * tell us if the API definition is valid or not, we need to clone the schema before\n         * supplying it to `openapi-parser`.\n         */\n        const clonedSchema = JSON.parse(JSON.stringify(schema));\n\n        const result = await validate(clonedSchema, parserOptions);\n        if (!result.valid && shouldThrowIfInvalid) {\n          throw new ValidationError(compileErrors(result), {\n            errors: result.errors,\n            warnings: result.warnings,\n          });\n        }\n\n        // The API definition, whatever its format or specification, is valid.\n        return result;\n      });\n  }\n\n  /**\n   * Retrieve OpenAPI, Swagger, or Postman version information about the supplied API definition.\n   *\n   */\n  async version(): Promise<{\n    specification: 'openapi' | 'postman' | 'swagger';\n    version: string | 'unknown';\n  }> {\n    return this.load().then(schema => {\n      switch (getAPIDefinitionType(schema)) {\n        case 'openapi':\n          return {\n            specification: 'openapi',\n            version: (schema as unknown as OpenAPIV3.Document).openapi,\n          };\n\n        case 'postman': {\n          let version = 'unknown';\n          if ((schema?.info as Record<string, string>)?.schema) {\n            // Though `info.schema` is required by the Postman spec there's no strictness to its\n            // contents so we'll do our best to extract a version out of this schema URL that they\n            // seem to usually match. If not we'll fallback to treating it as an `unknown` version.\n            const match = (schema?.info as Record<string, string>).schema.match(\n              /http(s?):\\/\\/schema.getpostman.com\\/json\\/collection\\/v([0-9.]+)\\//,\n            );\n\n            if (match) {\n              version = match[2];\n            }\n          }\n\n          return {\n            specification: 'postman',\n            version,\n          };\n        }\n\n        case 'swagger':\n          return {\n            specification: 'swagger',\n            version: (schema as unknown as OpenAPIV2.Document).swagger,\n          };\n\n        default:\n          throw new Error('Unknown file detected.');\n      }\n    });\n  }\n}\n"]}