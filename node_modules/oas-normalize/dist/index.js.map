{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { ParserOptions, ValidationResult } from '@readme/openapi-parser';\nimport type { OpenAPI, OpenAPIV2, OpenAPIV3 } from 'openapi-types';\nimport type { Options } from './lib/types.js';\n\nimport fs from 'node:fs';\n\nimport { bundle, compileErrors, dereference, validate } from '@readme/openapi-parser';\nimport postmanToOpenAPI from '@readme/postman-to-openapi';\nimport converter from 'swagger2openapi';\n\nimport { ValidationError } from './lib/errors.js';\nimport {\n  getAPIDefinitionType,\n  getType,\n  isOpenAPI,\n  isPostman,\n  isSwagger,\n  prepareURL,\n  stringToJSON,\n} from './lib/utils.js';\n\n// biome-ignore lint/style/noDefaultExport: This is fine for now.\nexport default class OASNormalize {\n  cache: {\n    bundle?: OpenAPI.Document | false;\n    convert?: OpenAPI.Document | false;\n    deref?: OpenAPI.Document | false;\n    load?: Record<string, unknown> | false;\n  };\n\n  // biome-ignore lint/suspicious/noExplicitAny: Intentionally loose because this library supports a wide variety of inputs.\n  file: any;\n\n  opts: Options;\n\n  type: ReturnType<typeof getType>;\n\n  // biome-ignore lint/suspicious/noExplicitAny: Intentionally loose because this library supports a wide variety of inputs.\n  constructor(file: any, opts?: Options) {\n    this.file = file;\n    this.opts = {\n      colorizeErrors: false,\n      enablePaths: false,\n      parser: {},\n      ...opts,\n    };\n\n    if (!this.opts.enablePaths) {\n      if (!this.opts.parser) this.opts.parser = {};\n      if (!this.opts.parser.resolve) this.opts.parser.resolve = {};\n      this.opts.parser.resolve = { file: false };\n    }\n\n    this.type = getType(this.file);\n\n    this.cache = {\n      load: false,\n      bundle: false,\n      deref: false,\n    };\n  }\n\n  /**\n   * Load and return the API definition that `oas-normalize` was initialized with.\n   *\n   */\n  async load(): Promise<Record<string, unknown>> {\n    if (this.cache.load) return this.cache.load;\n\n    const resolve = (obj: Parameters<typeof stringToJSON>[0]) => {\n      const ret = stringToJSON(obj);\n      this.cache.load = ret;\n      return ret;\n    };\n\n    switch (this.type) {\n      case 'json':\n      case 'string-json':\n      case 'string-yaml':\n        return resolve(this.file);\n\n      case 'buffer':\n        return resolve(this.file.toString());\n\n      case 'url': {\n        const { url, options } = prepareURL(this.file);\n        const resp = await fetch(url, options).then(res => res.text());\n        return resolve(resp);\n      }\n\n      case 'path': {\n        // Load a local file\n        if (!this.opts.enablePaths) {\n          throw new Error('Use `opts.enablePaths` to enable accessing local files.');\n        }\n\n        const contents = fs.readFileSync(this.file).toString();\n        if (!contents.trim()) {\n          throw new Error('No file contents found.');\n        }\n        return resolve(contents);\n      }\n\n      default:\n        throw new Error('Could not load this file.');\n    }\n  }\n\n  private static async convertPostmanToOpenAPI(schema: Record<string, unknown>) {\n    return postmanToOpenAPI(JSON.stringify(schema), undefined, {\n      outputFormat: 'json',\n      replaceVars: true,\n    }).then(JSON.parse);\n  }\n\n  /**\n   * Bundle up the given API definition, resolving any external `$ref` pointers in the process.\n   *\n   */\n  async bundle(): Promise<OpenAPI.Document> {\n    if (this.cache.bundle) return this.cache.bundle;\n    const parserOptions = this.opts.parser || {};\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to bundle we'll still\n        // upconvert it to an OpenAPI definition file so our returned dataset is always one of\n        // those for a Postman dataset.\n        if (isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => bundle(schema, parserOptions))\n      .then(bundled => {\n        this.cache.bundle = bundled;\n        return bundled;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   */\n  async dereference(): Promise<OpenAPI.Document> {\n    if (this.cache.deref) return this.cache.deref;\n    const parserOptions = this.opts.parser || {};\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to dereference we'll\n        // still upconvert it to an OpenAPI definition file so our returned dataset is always one\n        // of those for a Postman dataset.\n        if (isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => dereference(schema, parserOptions))\n      .then(dereferenced => {\n        this.cache.deref = dereferenced;\n        return dereferenced;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   * This method is deprecated in favor of `dereference`. It will be removed in a future release.\n   *\n   * @deprecated\n   */\n  async deref(): Promise<OpenAPI.Document> {\n    return this.dereference();\n  }\n\n  /**\n   * Convert a given API definition to OpenAPI if it is not already.\n   *\n   */\n  async convert(): Promise<OpenAPI.Document> {\n    if (this.cache.convert) return this.cache.convert;\n\n    return this.load()\n      .then(async schema => {\n        // If we have a Postman collection we need to convert it to OpenAPI.\n        return isPostman(schema) ? OASNormalize.convertPostmanToOpenAPI(schema) : schema;\n      })\n      .then(async schema => {\n        if (!isSwagger(schema) && !isOpenAPI(schema)) {\n          throw new Error('The supplied API definition is unsupported.');\n        } else if (isOpenAPI(schema)) {\n          return schema;\n        }\n\n        const baseVersion = parseInt(schema.swagger, 10);\n        if (baseVersion === 1) {\n          throw new Error('Swagger v1.2 is unsupported.');\n        }\n\n        return converter\n          .convertObj(schema, { anchors: true })\n          .then((options: { openapi: OpenAPI.Document }) => options.openapi);\n      });\n  }\n\n  /**\n   * Validate a given API definition.\n   *\n   * If supplied a Postman collection it will be converted to OpenAPI first and then run through\n   * standard OpenAPI validation.\n   *\n   */\n  async validate(\n    opts: {\n      /**\n       * Options to supply to our OpenAPI parser. See `@readme/openapi-parser` for documentation.\n       * This option is deprecated in favor of the `parser` option on the constructor. It will be\n       * removed in a future release.\n       *\n       * @see {@link https://npm.im/@readme/openapi-parser}\n       * @deprecated\n       */\n      parser?: ParserOptions;\n\n      /**\n       * Determines if `.validate()` should throw a `ValidationError` if the API definition is\n       * invalid.\n       *\n       * By default this will always happen however if you want to always instead receive a\n       * `ValidationResult` object back, which will still allow you to determine if the supplied\n       * API definition is valid or not, you can set this to `false`.\n       */\n      shouldThrowIfInvalid?: boolean;\n    } = {},\n  ): Promise<ValidationResult> {\n    const shouldThrowIfInvalid = opts.shouldThrowIfInvalid ?? true;\n    const parserOptions = opts.parser || this.opts.parser || {};\n    if (!parserOptions.validate) parserOptions.validate = {};\n    if (!parserOptions.validate.errors) parserOptions.validate.errors = {};\n\n    parserOptions.validate.errors.colorize = this.opts.colorizeErrors;\n\n    return this.load()\n      .then(async schema => {\n        // Because we don't have something akin to `openapi-parser` for Postman collections we just\n        // always convert them to OpenAPI.\n        return isPostman(schema) ? OASNormalize.convertPostmanToOpenAPI(schema) : schema;\n      })\n      .then(async schema => {\n        if (!isSwagger(schema) && !isOpenAPI(schema)) {\n          if (shouldThrowIfInvalid) {\n            throw new ValidationError('The supplied API definition is unsupported.');\n          }\n\n          return {\n            valid: false,\n            errors: [{ message: 'The supplied API definition is unsupported.' }],\n            warnings: [],\n            additionalErrors: 0,\n            specification: null,\n          };\n        } else if (isSwagger(schema)) {\n          const baseVersion = parseInt(schema.swagger, 10);\n          if (baseVersion === 1) {\n            if (shouldThrowIfInvalid) {\n              throw new ValidationError('Swagger v1.2 is unsupported.');\n            }\n\n            return {\n              valid: false,\n              errors: [{ message: 'Swagger v1.2 is unsupported.' }],\n              warnings: [],\n              additionalErrors: 0,\n              specification: 'Swagger',\n            };\n          }\n        }\n\n        /**\n         * `OpenAPIParser.validate()` dereferences schemas at the same time as validation, mutating\n         * the supplied parameter in the process, and does not give us an option to disable this.\n         * As we already have a dereferencing method on this library, and this method just needs to\n         * tell us if the API definition is valid or not, we need to clone the schema before\n         * supplying it to `openapi-parser`.\n         */\n        const clonedSchema = JSON.parse(JSON.stringify(schema));\n\n        const result = await validate(clonedSchema, parserOptions);\n        if (!result.valid && shouldThrowIfInvalid) {\n          throw new ValidationError(compileErrors(result), {\n            errors: result.errors,\n            warnings: result.warnings,\n          });\n        }\n\n        // The API definition, whatever its format or specification, is valid.\n        return result;\n      });\n  }\n\n  /**\n   * Retrieve OpenAPI, Swagger, or Postman version information about the supplied API definition.\n   *\n   */\n  async version(): Promise<{\n    specification: 'openapi' | 'postman' | 'swagger';\n    version: string | 'unknown';\n  }> {\n    return this.load().then(schema => {\n      switch (getAPIDefinitionType(schema)) {\n        case 'openapi':\n          return {\n            specification: 'openapi',\n            version: (schema as unknown as OpenAPIV3.Document).openapi,\n          };\n\n        case 'postman': {\n          let version = 'unknown';\n          if ((schema?.info as Record<string, string>)?.schema) {\n            // Though `info.schema` is required by the Postman spec there's no strictness to its\n            // contents so we'll do our best to extract a version out of this schema URL that they\n            // seem to usually match. If not we'll fallback to treating it as an `unknown` version.\n            const match = (schema?.info as Record<string, string>).schema.match(\n              /http(s?):\\/\\/schema.getpostman.com\\/json\\/collection\\/v([0-9.]+)\\//,\n            );\n\n            if (match) {\n              version = match[2];\n            }\n          }\n\n          return {\n            specification: 'postman',\n            version,\n          };\n        }\n\n        case 'swagger':\n          return {\n            specification: 'swagger',\n            version: (schema as unknown as OpenAPIV2.Document).swagger,\n          };\n\n        default:\n          throw new Error('Unknown file detected.');\n      }\n    });\n  }\n}\n"],"mappings":"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","names":[]}