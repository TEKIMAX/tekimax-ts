import { r as __name } from "./chunk-CrnDzoTS.js";
import { c as FabricReactElement, f as Key, g as FunctionParams, h as types_d_exports, l as FabricReactNode, y as createFunctionParams } from "./types-BKnc-nPE.js";
import { t as Options$1 } from "./reactPlugin-CvA5o0Zs.js";
import { Fabric, FileManager, FileManager as FileManager$1, FileProcessor, TreeNode, TreeNode as TreeNode$1, createContext, createFabric, createFile, useApp, useContext, useFile, useLifecycle } from "@kubb/fabric-core";
import { Fabric as Fabric$1, FabricConfig, FabricMode, KubbFile } from "@kubb/fabric-core/types";
import * as react3 from "react";

//#region src/components/App.d.ts
type AppProps<TMeta extends object = object> = {
  /**
   * Metadata associated with the App.
   */
  meta?: TMeta;
  /**
   * Children nodes.
   */
  children?: FabricReactNode;
};
/**
 * App container containing the AppContext carrying `meta` and an `exit` hook.
 */
declare function App<TMeta extends object = object>({
  children,
  ...props
}: AppProps<TMeta>): FabricReactElement;
declare namespace App {
  var displayName: string;
}
//#endregion
//#region src/components/Const.d.ts
type ConstProps = {
  key?: Key;
  /**
   * Name of the const
   */
  name: string;
  /**
   * Does this type need to be exported.
   */
  export?: boolean;
  /**
   * Type to make the const being typed
   */
  type?: string;
  /**
   * Options for JSdocs.
   */
  JSDoc?: types_d_exports.JSDoc;
  /**
   * Use of `const` assertions
   */
  asConst?: boolean;
  /**
   * Children nodes.
   */
  children?: FabricReactNode;
};
/**
 * Generates a TypeScript constant declaration.
 */
declare function Const({
  children,
  ...props
}: ConstProps): FabricReactElement;
declare namespace Const {
  var displayName: string;
}
//#endregion
//#region src/components/File.d.ts
type BasePropsWithBaseName = {
  /**
   * Name to be used to dynamicly create the baseName(based on input.path).
   * Based on UNIX basename
   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix
   */
  baseName: KubbFile.BaseName;
  /**
   * Path will be full qualified path to a specified file.
   */
  path: KubbFile.Path;
};
type BasePropsWithoutBaseName = {
  baseName?: never;
  /**
   * Path will be full qualified path to a specified file.
   */
  path?: KubbFile.Path;
};
type BaseProps = BasePropsWithBaseName | BasePropsWithoutBaseName;
type Props$1<TMeta> = BaseProps & {
  key?: Key;
  meta?: TMeta;
  banner?: string;
  footer?: string;
  children?: FabricReactNode;
};
/**
 * Adds files to the FileManager
 */
declare function File<TMeta extends object = object>({
  children,
  ...props
}: Props$1<TMeta>): FabricReactElement;
declare namespace File {
  var displayName: string;
  var Export: typeof FileExport;
  var Import: typeof FileImport;
  var Source: typeof FileSource;
}
type FileSourceProps = Omit<KubbFile.Source, 'value'> & {
  key?: Key;
  children?: FabricReactNode;
};
/**
 * File.Source
 *
 * Marks a block of source text to be associated with the current file when
 * rendering with the FileCollector. Children are treated as the source string.
 */
declare function FileSource({
  children,
  ...props
}: FileSourceProps): FabricReactElement;
declare namespace FileSource {
  var displayName: string;
}
type FileExportProps = KubbFile.Export & {
  key?: Key;
};
/**
 * File.Export
 *
 * Declares an export entry for the current file. This will be collected by
 * the FileCollector for later emission.
 */
declare function FileExport(props: FileExportProps): FabricReactElement;
declare namespace FileExport {
  var displayName: string;
}
type FileImportProps = KubbFile.Import & {
  key?: Key;
};
/**
 * File.Import
 *
 * Declares an import entry for the current file.
 */
declare function FileImport(props: FileImportProps): FabricReactElement;
declare namespace FileImport {
  var displayName: string;
}
//#endregion
//#region src/components/Function.d.ts
type Props = {
  key?: Key;
  /**
   * Name of the function.
   */
  name: string;
  /**
   * Add default when export is being used
   */
  default?: boolean;
  /**
   * Parameters/options/props that need to be used.
   */
  params?: string;
  /**
   * Does this function need to be exported.
   */
  export?: boolean;
  /**
   * Does the function has async/promise behavior.
   * This will also add `Promise<returnType>` as the returnType.
   */
  async?: boolean;
  /**
   * Generics that needs to be added for TypeScript.
   */
  generics?: string | string[];
  /**
   * ReturnType(see async for adding Promise type).
   */
  returnType?: string;
  /**
   * Options for JSdocs.
   */
  JSDoc?: types_d_exports.JSDoc;
  /**
   * Children nodes.
   */
  children?: FabricReactNode;
};
/**
 * Generates a TypeScript function declaration.
 */
declare function Function({
  children,
  ...props
}: Props): FabricReactElement;
declare namespace Function {
  var displayName: string;
  var Arrow: typeof ArrowFunction;
}
type ArrowFunctionProps = Props & {
  /**
   * Create Arrow function in one line
   */
  singleLine?: boolean;
};
/**
 * ArrowFunction
 *
 * Renders an arrow function definition. Supports the same flags as `Function`.
 * Use `singleLine` to render the body as a single-line expression.
 */
declare function ArrowFunction({
  children,
  ...props
}: ArrowFunctionProps): react3.JSX.Element;
declare namespace ArrowFunction {
  var displayName: string;
}
//#endregion
//#region src/components/Root.d.ts
type RootProps = {
  /**
   * Exit (unmount) the whole app.
   */
  onExit: (error?: Error) => void;
  /**
   * Error hook receiving runtime exceptions.
   */
  onError: (error: Error) => void;
  /**
   * TreeNode representing the tree structure of the app.
   */
  treeNode: TreeNode$1<types_d_exports.ComponentNode>;
  /**
   * FileManager instance for managing files within the app.
   */
  fileManager: FileManager$1;
  /**
   * Children nodes.
   */
  children?: FabricReactNode;
};
/**
 * This component provides the root behavior for the Fabric runtime.
 */
declare function Root({
  onError,
  onExit,
  treeNode,
  fileManager,
  children
}: RootProps): FabricReactElement;
declare namespace Root {
  var displayName: string;
}
//#endregion
//#region src/components/Type.d.ts
type TypeProps = {
  key?: Key;
  /**
   * Name of the type, this needs to start with a capital letter.
   */
  name: string;
  /**
   * Does this type need to be exported.
   */
  export?: boolean;
  /**
   * Options for JSdocs.
   */
  JSDoc?: types_d_exports.JSDoc;
  /**
   * Children nodes.
   */
  children?: FabricReactNode;
};
/**
 * Generates a TypeScript type declaration.
 */
declare function Type({
  children,
  ...props
}: TypeProps): FabricReactElement;
declare namespace Type {
  var displayName: string;
}
//#endregion
//#region src/createReactFabric.d.ts
declare function createReactFabric(config?: FabricConfig<Options$1 & {
  mode?: FabricMode;
  devtools?: boolean;
}>): Fabric$1<Options$1 & {
  mode?: FabricMode;
  devtools?: boolean;
}>;
//#endregion
//#region src/devtools.d.ts
declare global {
  var WebSocket: typeof WebSocket;
  var self: any;
  var window: any;
  var isDevtoolsEnabled: any;
}
declare function openDevtools(): undefined;
//#endregion
//#region src/Runtime.d.ts
type Options = {
  fileManager: FileManager$1;
  treeNode?: TreeNode$1<types_d_exports.ComponentNode>;
  stdout?: NodeJS.WriteStream;
  stdin?: NodeJS.ReadStream;
  stderr?: NodeJS.WriteStream;
  /**
   * Set this to true to always see the result of the render in the console(line per render)
   */
  debug?: boolean;
};
declare class Runtime {
  #private;
  exitPromise?: Promise<void>;
  constructor(options: Options);
  get fileManager(): FileManager$1;
  resolveExitPromise: () => void;
  rejectExitPromise: (reason?: Error) => void;
  unsubscribeExit: () => void;
  onRender: () => Promise<void>;
  onError(error: Error): void;
  onExit(error?: Error): void;
  render(node: FabricReactElement): Promise<void>;
  renderToString(node: FabricReactElement): Promise<string>;
  unmount(error?: Error | number | null): void;
  waitUntilExit(): Promise<void>;
}
//#endregion
//#region src/index.d.ts
declare const useState: typeof react3.useState;
declare const useEffect: typeof react3.useEffect;
declare const useReducer: typeof react3.useReducer;
declare const useRef: typeof react3.useRef;
//#endregion
export { App, Const, type Fabric, File, FileManager, FileProcessor, Function, FunctionParams, Root, Runtime, TreeNode, Type, createContext, createFabric, createFile, createFunctionParams, createReactFabric, openDevtools, useApp, useContext, useEffect, useFile, useLifecycle, useReducer, useRef, useState };