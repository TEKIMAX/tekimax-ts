import { a as __require, i as __name, n as __esmMin, o as __toCommonJS, r as __exportAll, s as __toESM, t as __commonJSMin } from "./chunk-BdfDOGov.js";
import { findSchemaDefinition, matchesMimeType, matchesMimeType as matchesMimeType$1 } from "oas/utils";
import jsonpointer from "jsonpointer";
import BaseOas from "oas";
import path from "node:path";
import { pascalCase } from "@kubb/core/transformers";
import { URLPath } from "@kubb/core/utils";
import { isRef } from "oas/types";
import OASNormalize from "oas-normalize";
import { isPlainObject, mergeDeep } from "remeda";
import swagger2openapi from "swagger2openapi";

//#region ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = /* @__PURE__ */ __exportAll({
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default
});
function __extends(d, b) {
	if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
}
function __decorate(decorators, target, key, desc) {
	var c = arguments.length;
	var r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	var d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f) {
		if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
		return f;
	}
	var kind = contextIn.kind;
	var key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _;
	var done = false;
	for (var i = decorators.length - 1; i >= 0; i--) {
		var context = {};
		for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
		for (var p in contextIn.access) context.access[p] = contextIn.access[p];
		context.addInitializer = function(f) {
			if (done) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f || null));
		};
		var result = (0, decorators[i])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_ = accept(result.get)) descriptor.get = _;
			if (_ = accept(result.set)) descriptor.set = _;
			if (_ = accept(result.init)) initializers.unshift(_);
		} else if (_ = accept(result)) if (kind === "field") initializers.unshift(_);
		else descriptor[key] = _;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done = true;
}
function __runInitializers(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i = 0; i < initializers.length; i++) value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	return useValue ? value : void 0;
}
function __propKey(x) {
	return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _ = {
		label: 0,
		sent: function() {
			if (t[0] & 1) throw t[1];
			return t[1];
		},
		trys: [],
		ops: []
	};
	var f;
	var y;
	var t;
	var g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		return this;
	}), g;
	function verb(n) {
		return function(v) {
			return step([n, v]);
		};
	}
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while (g && (g = 0, op[0] && (_ = 0)), _) try {
			if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
			if (y = 0, t) op = [op[0] & 2, t.value];
			switch (op[0]) {
				case 0:
				case 1:
					t = op;
					break;
				case 4:
					_.label++;
					return {
						value: op[1],
						done: false
					};
				case 5:
					_.label++;
					y = op[1];
					op = [0];
					continue;
				case 7:
					op = _.ops.pop();
					_.trys.pop();
					continue;
				default:
					if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
						_ = 0;
						continue;
					}
					if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
						_.label = op[1];
						break;
					}
					if (op[0] === 6 && _.label < t[1]) {
						_.label = t[1];
						t = op;
						break;
					}
					if (t && _.label < t[2]) {
						_.label = t[2];
						_.ops.push(op);
						break;
					}
					if (t[2]) _.ops.pop();
					_.trys.pop();
					continue;
			}
			op = body.call(thisArg, _);
		} catch (e) {
			op = [6, e];
			y = 0;
		} finally {
			f = t = 0;
		}
		if (op[0] & 5) throw op[1];
		return {
			value: op[0] ? op[1] : void 0,
			done: true
		};
	}
}
function __exportStar(m, o) {
	for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
	var s = typeof Symbol === "function" && Symbol.iterator;
	var m = s && o[s];
	var i = 0;
	if (m) return m.call(o);
	if (o && typeof o.length === "number") return { next: function() {
		if (o && i >= o.length) o = void 0;
		return {
			value: o && o[i++],
			done: !o
		};
	} };
	throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
	var m = typeof Symbol === "function" && o[Symbol.iterator];
	if (!m) return o;
	var i = m.call(o);
	var r;
	var ar = [];
	var e;
	try {
		while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	} catch (error) {
		e = { error };
	} finally {
		try {
			if (r && !r.done && (m = i["return"])) m.call(i);
		} finally {
			if (e) throw e.error;
		}
	}
	return ar;
}
/** @deprecated */
function __spread() {
	for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
	return ar;
}
/** @deprecated */
function __spreadArrays() {
	for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
	return r;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
	return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g = generator.apply(thisArg, _arguments || []);
	var i;
	var q = [];
	return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
		return this;
	}, i;
	function awaitReturn(f) {
		return function(v) {
			return Promise.resolve(v).then(f, reject);
		};
	}
	function verb(n, f) {
		if (g[n]) {
			i[n] = function(v) {
				return new Promise(function(a, b) {
					q.push([
						n,
						v,
						a,
						b
					]) > 1 || resume(n, v);
				});
			};
			if (f) i[n] = f(i[n]);
		}
	}
	function resume(n, v) {
		try {
			step(g[n](v));
		} catch (e) {
			settle(q[0][3], e);
		}
	}
	function step(r) {
		r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
	}
	function fulfill(value) {
		resume("next", value);
	}
	function reject(value) {
		resume("throw", value);
	}
	function settle(f, v) {
		if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	}
}
function __asyncDelegator(o) {
	var i;
	var p;
	return i = {}, verb("next"), verb("throw", function(e) {
		throw e;
	}), verb("return"), i[Symbol.iterator] = function() {
		return this;
	}, i;
	function verb(n, f) {
		i[n] = o[n] ? function(v) {
			return (p = !p) ? {
				value: __await(o[n](v)),
				done: false
			} : f ? f(v) : v;
		} : f;
	}
}
function __asyncValues(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o[Symbol.asyncIterator];
	var i;
	return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
		return this;
	}, i);
	function verb(n) {
		i[n] = o[n] && function(v) {
			return new Promise(function(resolve, reject) {
				v = o[n](v), settle(resolve, reject, v.done, v.value);
			});
		};
	}
	function settle(resolve, reject, d, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve({
				value: v$1,
				done: d
			});
		}, reject);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	}
	__setModuleDefault(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		var dispose;
		var inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e) {
				return Promise.reject(e);
			}
		};
		env.stack.push({
			value,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value;
}
function __disposeResources(env) {
	function fail(e) {
		env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
		env.hasError = true;
	}
	var r;
	var s = 0;
	function next() {
		while (r = env.stack.pop()) try {
			if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
			if (r.dispose) {
				var result = r.dispose.call(r.value);
				if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
					fail(e);
					return next();
				});
			} else s |= 1;
		} catch (e) {
			fail(e);
		}
		if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path$1, preserveJsx) {
	if (typeof path$1 === "string" && /^\.\.?\//.test(path$1)) return path$1.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
		return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
	});
	return path$1;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esmMin((() => {
	extendStatics = function(d, b) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
			d$1.__proto__ = b$1;
		} || function(d$1, b$1) {
			for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
		};
		return extendStatics(d, b);
	};
	__assign = function() {
		__assign = Object.assign || function __assign$1(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};
	__createBinding = Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	__setModuleDefault = Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	};
	ownKeys = function(o) {
		ownKeys = Object.getOwnPropertyNames || function(o$1) {
			var ar = [];
			for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
			return ar;
		};
		return ownKeys(o);
	};
	_SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
		var e = new Error(message);
		return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};
	tslib_es6_default = {
		__extends,
		__assign,
		__rest,
		__decorate,
		__param,
		__esDecorate,
		__runInitializers,
		__propKey,
		__setFunctionName,
		__metadata,
		__awaiter,
		__generator,
		__createBinding,
		__exportStar,
		__values,
		__read,
		__spread,
		__spreadArrays,
		__spreadArray,
		__await,
		__asyncGenerator,
		__asyncDelegator,
		__asyncValues,
		__makeTemplateObject,
		__importStar,
		__importDefault,
		__classPrivateFieldGet,
		__classPrivateFieldSet,
		__classPrivateFieldIn,
		__addDisposableResource,
		__disposeResources,
		__rewriteRelativeImportExtension
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/yamlAST.js
var require_yamlAST = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Kind;
	(function(Kind) {
		Kind[Kind["SCALAR"] = 0] = "SCALAR";
		Kind[Kind["MAPPING"] = 1] = "MAPPING";
		Kind[Kind["MAP"] = 2] = "MAP";
		Kind[Kind["SEQ"] = 3] = "SEQ";
		Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
		Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
	})(Kind = exports.Kind || (exports.Kind = {}));
	function newMapping(key, value) {
		var end = value ? value.endPosition : key.endPosition + 1;
		return {
			key,
			value,
			startPosition: key.startPosition,
			endPosition: end,
			kind: Kind.MAPPING,
			parent: null,
			errors: []
		};
	}
	exports.newMapping = newMapping;
	function newAnchorRef(key, start, end, value) {
		return {
			errors: [],
			referencesAnchor: key,
			value,
			startPosition: start,
			endPosition: end,
			kind: Kind.ANCHOR_REF,
			parent: null
		};
	}
	exports.newAnchorRef = newAnchorRef;
	function newScalar(v = "") {
		const result = {
			errors: [],
			startPosition: -1,
			endPosition: -1,
			value: "" + v,
			kind: Kind.SCALAR,
			parent: null,
			doubleQuoted: false,
			rawValue: "" + v
		};
		if (typeof v !== "string") result.valueObject = v;
		return result;
	}
	exports.newScalar = newScalar;
	function newItems() {
		return {
			errors: [],
			startPosition: -1,
			endPosition: -1,
			items: [],
			kind: Kind.SEQ,
			parent: null
		};
	}
	exports.newItems = newItems;
	function newSeq() {
		return newItems();
	}
	exports.newSeq = newSeq;
	function newMap(mappings) {
		return {
			errors: [],
			startPosition: -1,
			endPosition: -1,
			mappings: mappings ? mappings : [],
			kind: Kind.MAP,
			parent: null
		};
	}
	exports.newMap = newMap;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/common.js
var require_common = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function isNothing(subject) {
		return typeof subject === "undefined" || null === subject;
	}
	exports.isNothing = isNothing;
	function isObject(subject) {
		return typeof subject === "object" && null !== subject;
	}
	exports.isObject = isObject;
	function toArray(sequence) {
		if (Array.isArray(sequence)) return sequence;
		else if (isNothing(sequence)) return [];
		return [sequence];
	}
	exports.toArray = toArray;
	function extend(target, source) {
		var index;
		var length;
		var key;
		var sourceKeys;
		if (source) {
			sourceKeys = Object.keys(source);
			for (index = 0, length = sourceKeys.length; index < length; index += 1) {
				key = sourceKeys[index];
				target[key] = source[key];
			}
		}
		return target;
	}
	exports.extend = extend;
	function repeat(string, count) {
		var result = "";
		var cycle;
		for (cycle = 0; cycle < count; cycle += 1) result += string;
		return result;
	}
	exports.repeat = repeat;
	function isNegativeZero(number) {
		return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
	}
	exports.isNegativeZero = isNegativeZero;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/exception.js
var require_exception = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var YAMLException = class YAMLException {
		constructor(reason, mark = null, isWarning = false) {
			this.name = "YAMLException";
			this.reason = reason;
			this.mark = mark;
			this.message = this.toString(false);
			this.isWarning = isWarning;
		}
		static isInstance(instance) {
			if (instance != null && instance.getClassIdentifier && typeof instance.getClassIdentifier == "function") {
				for (let currentIdentifier of instance.getClassIdentifier()) if (currentIdentifier == YAMLException.CLASS_IDENTIFIER) return true;
			}
			return false;
		}
		getClassIdentifier() {
			return [].concat(YAMLException.CLASS_IDENTIFIER);
		}
		toString(compact = false) {
			var result = "JS-YAML: " + (this.reason || "(unknown reason)");
			if (!compact && this.mark) result += " " + this.mark.toString();
			return result;
		}
	};
	YAMLException.CLASS_IDENTIFIER = "yaml-ast-parser.YAMLException";
	module.exports = YAMLException;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/mark.js
var require_mark = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const common = require_common();
	var Mark = class {
		constructor(name, buffer, position, line, column) {
			this.name = name;
			this.buffer = buffer;
			this.position = position;
			this.line = line;
			this.column = column;
		}
		getSnippet(indent = 0, maxLength = 75) {
			var head;
			var start;
			var tail;
			var end;
			var snippet;
			if (!this.buffer) return null;
			indent = indent || 4;
			maxLength = maxLength || 75;
			head = "";
			start = this.position;
			while (start > 0 && -1 === "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start - 1))) {
				start -= 1;
				if (this.position - start > maxLength / 2 - 1) {
					head = " ... ";
					start += 5;
					break;
				}
			}
			tail = "";
			end = this.position;
			while (end < this.buffer.length && -1 === "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end))) {
				end += 1;
				if (end - this.position > maxLength / 2 - 1) {
					tail = " ... ";
					end -= 5;
					break;
				}
			}
			snippet = this.buffer.slice(start, end);
			return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
		}
		toString(compact = true) {
			var snippet;
			var where = "";
			if (this.name) where += "in \"" + this.name + "\" ";
			where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
			if (!compact) {
				snippet = this.getSnippet();
				if (snippet) where += ":\n" + snippet;
			}
			return where;
		}
	};
	module.exports = Mark;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type.js
var require_type = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const YAMLException = require_exception();
	var TYPE_CONSTRUCTOR_OPTIONS = [
		"kind",
		"resolve",
		"construct",
		"instanceOf",
		"predicate",
		"represent",
		"defaultStyle",
		"styleAliases"
	];
	var YAML_NODE_KINDS = [
		"scalar",
		"sequence",
		"mapping"
	];
	function compileStyleAliases(map) {
		var result = {};
		if (null !== map) Object.keys(map).forEach(function(style) {
			map[style].forEach(function(alias) {
				result[String(alias)] = style;
			});
		});
		return result;
	}
	var Type = class {
		constructor(tag, options) {
			options = options || {};
			Object.keys(options).forEach(function(name) {
				if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) throw new YAMLException("Unknown option \"" + name + "\" is met in definition of \"" + tag + "\" YAML type.");
			});
			this.tag = tag;
			this.kind = options["kind"] || null;
			this.resolve = options["resolve"] || function() {
				return true;
			};
			this.construct = options["construct"] || function(data) {
				return data;
			};
			this.instanceOf = options["instanceOf"] || null;
			this.predicate = options["predicate"] || null;
			this.represent = options["represent"] || null;
			this.defaultStyle = options["defaultStyle"] || null;
			this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
			if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) throw new YAMLException("Unknown kind \"" + this.kind + "\" is specified for \"" + tag + "\" YAML type.");
		}
	};
	exports.Type = Type;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema.js
var require_schema = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const common = require_common();
	const YAMLException = require_exception();
	const type_1 = require_type();
	function compileList(schema, name, result) {
		var exclude = [];
		schema.include.forEach(function(includedSchema) {
			result = compileList(includedSchema, name, result);
		});
		schema[name].forEach(function(currentType) {
			result.forEach(function(previousType, previousIndex) {
				if (previousType.tag === currentType.tag) exclude.push(previousIndex);
			});
			result.push(currentType);
		});
		return result.filter(function(type, index) {
			return -1 === exclude.indexOf(index);
		});
	}
	function compileMap() {
		var result = {};
		var index;
		var length;
		function collectType(type) {
			result[type.tag] = type;
		}
		for (index = 0, length = arguments.length; index < length; index += 1) arguments[index].forEach(collectType);
		return result;
	}
	var Schema = class {
		constructor(definition) {
			this.include = definition.include || [];
			this.implicit = definition.implicit || [];
			this.explicit = definition.explicit || [];
			this.implicit.forEach(function(type) {
				if (type.loadKind && "scalar" !== type.loadKind) throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
			});
			this.compiledImplicit = compileList(this, "implicit", []);
			this.compiledExplicit = compileList(this, "explicit", []);
			this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
		}
	};
	exports.Schema = Schema;
	Schema.DEFAULT = null;
	Schema.create = function createSchema() {
		var schemas;
		var types;
		switch (arguments.length) {
			case 1:
				schemas = Schema.DEFAULT;
				types = arguments[0];
				break;
			case 2:
				schemas = arguments[0];
				types = arguments[1];
				break;
			default: throw new YAMLException("Wrong number of arguments for Schema.create function");
		}
		schemas = common.toArray(schemas);
		types = common.toArray(types);
		if (!schemas.every(function(schema) {
			return schema instanceof Schema;
		})) throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
		if (!types.every(function(type) {
			return type instanceof type_1.Type;
		})) throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
		return new Schema({
			include: schemas,
			explicit: types
		});
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/str.js
var require_str = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	module.exports = new type_1.Type("tag:yaml.org,2002:str", {
		kind: "scalar",
		construct: function(data) {
			return null !== data ? data : "";
		}
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/seq.js
var require_seq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	module.exports = new type_1.Type("tag:yaml.org,2002:seq", {
		kind: "sequence",
		construct: function(data) {
			return null !== data ? data : [];
		}
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/map.js
var require_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	module.exports = new type_1.Type("tag:yaml.org,2002:map", {
		kind: "mapping",
		construct: function(data) {
			return null !== data ? data : {};
		}
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema/failsafe.js
var require_failsafe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const schema_1 = require_schema();
	module.exports = new schema_1.Schema({ explicit: [
		require_str(),
		require_seq(),
		require_map()
	] });
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/null.js
var require_null = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	function resolveYamlNull(data) {
		if (null === data) return true;
		var max = data.length;
		return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
	}
	function constructYamlNull() {
		return null;
	}
	function isNull(object) {
		return null === object;
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:null", {
		kind: "scalar",
		resolve: resolveYamlNull,
		construct: constructYamlNull,
		predicate: isNull,
		represent: {
			canonical: function() {
				return "~";
			},
			lowercase: function() {
				return "null";
			},
			uppercase: function() {
				return "NULL";
			},
			camelcase: function() {
				return "Null";
			}
		},
		defaultStyle: "lowercase"
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/bool.js
var require_bool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	function resolveYamlBoolean(data) {
		if (null === data) return false;
		var max = data.length;
		return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
	}
	function constructYamlBoolean(data) {
		return data === "true" || data === "True" || data === "TRUE";
	}
	function isBoolean(object) {
		return "[object Boolean]" === Object.prototype.toString.call(object);
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:bool", {
		kind: "scalar",
		resolve: resolveYamlBoolean,
		construct: constructYamlBoolean,
		predicate: isBoolean,
		represent: {
			lowercase: function(object) {
				return object ? "true" : "false";
			},
			uppercase: function(object) {
				return object ? "TRUE" : "FALSE";
			},
			camelcase: function(object) {
				return object ? "True" : "False";
			}
		},
		defaultStyle: "lowercase"
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/int.js
var require_int = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const common = require_common();
	const type_1 = require_type();
	function isHexCode(c) {
		return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
	}
	function isOctCode(c) {
		return 48 <= c && c <= 55;
	}
	function isDecCode(c) {
		return 48 <= c && c <= 57;
	}
	function resolveYamlInteger(data) {
		if (null === data) return false;
		var max = data.length;
		var index = 0;
		var hasDigits = false;
		var ch;
		if (!max) return false;
		ch = data[index];
		if (ch === "-" || ch === "+") ch = data[++index];
		if (ch === "0") {
			if (index + 1 === max) return true;
			ch = data[++index];
			if (ch === "b") {
				index++;
				for (; index < max; index++) {
					ch = data[index];
					if (ch === "_") continue;
					if (ch !== "0" && ch !== "1") return false;
					hasDigits = true;
				}
				return hasDigits;
			}
			if (ch === "x") {
				index++;
				for (; index < max; index++) {
					ch = data[index];
					if (ch === "_") continue;
					if (!isHexCode(data.charCodeAt(index))) return false;
					hasDigits = true;
				}
				return hasDigits;
			}
			for (; index < max; index++) {
				ch = data[index];
				if (ch === "_") continue;
				if (!isOctCode(data.charCodeAt(index))) {
					hasDigits = false;
					break;
				}
				hasDigits = true;
			}
			if (hasDigits) return hasDigits;
		}
		for (; index < max; index++) {
			ch = data[index];
			if (ch === "_") continue;
			if (ch === ":") break;
			if (!isDecCode(data.charCodeAt(index))) return false;
			hasDigits = true;
		}
		if (!hasDigits) return false;
		if (ch !== ":") return true;
		return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}
	function constructYamlInteger(data) {
		var value = data;
		var sign = 1;
		var ch;
		var base;
		var digits = [];
		if (value.indexOf("_") !== -1) value = value.replace(/_/g, "");
		ch = value[0];
		if (ch === "-" || ch === "+") {
			if (ch === "-") sign = -1;
			value = value.slice(1);
			ch = value[0];
		}
		if ("0" === value) return 0;
		if (ch === "0") {
			if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
			if (value[1] === "x") return sign * parseInt(value, 16);
			return sign * parseInt(value, 8);
		}
		if (value.indexOf(":") !== -1) {
			value.split(":").forEach(function(v) {
				digits.unshift(parseInt(v, 10));
			});
			value = 0;
			base = 1;
			digits.forEach(function(d) {
				value += d * base;
				base *= 60;
			});
			return sign * value;
		}
		return sign * parseInt(value, 10);
	}
	function isInteger(object) {
		const type = Object.prototype.toString.call(object);
		return "[object Number]" === type && 0 === object % 1 && !common.isNegativeZero(object) || "[object BigInt]" === type;
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:int", {
		kind: "scalar",
		resolve: resolveYamlInteger,
		construct: constructYamlInteger,
		predicate: isInteger,
		represent: {
			binary: function(object) {
				return "0b" + object.toString(2);
			},
			octal: function(object) {
				return "0" + object.toString(8);
			},
			decimal: function(object) {
				return object.toString(10);
			},
			hexadecimal: function(object) {
				return "0x" + object.toString(16).toUpperCase();
			}
		},
		defaultStyle: "decimal",
		styleAliases: {
			binary: [2, "bin"],
			octal: [8, "oct"],
			decimal: [10, "dec"],
			hexadecimal: [16, "hex"]
		}
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/float.js
var require_float = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const common = require_common();
	const type_1 = require_type();
	var YAML_FLOAT_PATTERN = /* @__PURE__ */ new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
	function resolveYamlFloat(data) {
		if (null === data) return false;
		if (!YAML_FLOAT_PATTERN.test(data)) return false;
		return true;
	}
	function constructYamlFloat(data) {
		var value = data.replace(/_/g, "").toLowerCase();
		var sign = "-" === value[0] ? -1 : 1;
		var base;
		var digits = [];
		if (0 <= "+-".indexOf(value[0])) value = value.slice(1);
		if (".inf" === value) return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
		else if (".nan" === value) return NaN;
		else if (0 <= value.indexOf(":")) {
			value.split(":").forEach(function(v) {
				digits.unshift(parseFloat(v, 10));
			});
			value = 0;
			base = 1;
			digits.forEach(function(d) {
				value += d * base;
				base *= 60;
			});
			return sign * value;
		}
		return sign * parseFloat(value, 10);
	}
	function representYamlFloat(object, style) {
		if (isNaN(object)) switch (style) {
			case "lowercase": return ".nan";
			case "uppercase": return ".NAN";
			case "camelcase": return ".NaN";
		}
		else if (Number.POSITIVE_INFINITY === object) switch (style) {
			case "lowercase": return ".inf";
			case "uppercase": return ".INF";
			case "camelcase": return ".Inf";
		}
		else if (Number.NEGATIVE_INFINITY === object) switch (style) {
			case "lowercase": return "-.inf";
			case "uppercase": return "-.INF";
			case "camelcase": return "-.Inf";
		}
		else if (common.isNegativeZero(object)) return "-0.0";
		return object.toString(10);
	}
	function isFloat(object) {
		return "[object Number]" === Object.prototype.toString.call(object) && (0 !== object % 1 || common.isNegativeZero(object));
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:float", {
		kind: "scalar",
		resolve: resolveYamlFloat,
		construct: constructYamlFloat,
		predicate: isFloat,
		represent: representYamlFloat,
		defaultStyle: "lowercase"
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema/json.js
var require_json = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const schema_1 = require_schema();
	module.exports = new schema_1.Schema({
		include: [require_failsafe()],
		implicit: [
			require_null(),
			require_bool(),
			require_int(),
			require_float()
		]
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema/core.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const schema_1 = require_schema();
	module.exports = new schema_1.Schema({ include: [require_json()] });
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/timestamp.js
var require_timestamp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	var YAML_TIMESTAMP_REGEXP = /* @__PURE__ */ new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$");
	function resolveYamlTimestamp(data) {
		if (null === data) return false;
		if (null === YAML_TIMESTAMP_REGEXP.exec(data)) return false;
		return true;
	}
	function constructYamlTimestamp(data) {
		var match;
		var year;
		var month;
		var day;
		var hour;
		var minute;
		var second;
		var fraction = 0;
		var delta = null;
		var tz_hour;
		var tz_minute;
		var date;
		match = YAML_TIMESTAMP_REGEXP.exec(data);
		if (null === match) throw new Error("Date resolve error");
		year = +match[1];
		month = +match[2] - 1;
		day = +match[3];
		if (!match[4]) return new Date(Date.UTC(year, month, day));
		hour = +match[4];
		minute = +match[5];
		second = +match[6];
		if (match[7]) {
			fraction = match[7].slice(0, 3);
			while (fraction.length < 3) fraction = fraction + "0";
			fraction = +fraction;
		}
		if (match[9]) {
			tz_hour = +match[10];
			tz_minute = +(match[11] || 0);
			delta = (tz_hour * 60 + tz_minute) * 6e4;
			if ("-" === match[9]) delta = -delta;
		}
		date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
		if (delta) date.setTime(date.getTime() - delta);
		return date;
	}
	function representYamlTimestamp(object) {
		return object.toISOString();
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:timestamp", {
		kind: "scalar",
		resolve: resolveYamlTimestamp,
		construct: constructYamlTimestamp,
		instanceOf: Date,
		represent: representYamlTimestamp
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/merge.js
var require_merge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	function resolveYamlMerge(data) {
		return "<<" === data || null === data;
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:merge", {
		kind: "scalar",
		resolve: resolveYamlMerge
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/binary.js
var require_binary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var NodeBuffer = __require("buffer").Buffer;
	const type_1 = require_type();
	var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
	function resolveYamlBinary(data) {
		if (null === data) return false;
		var code;
		var idx;
		var bitlen = 0;
		var max = data.length;
		var map = BASE64_MAP;
		for (idx = 0; idx < max; idx++) {
			code = map.indexOf(data.charAt(idx));
			if (code > 64) continue;
			if (code < 0) return false;
			bitlen += 6;
		}
		return bitlen % 8 === 0;
	}
	function constructYamlBinary(data) {
		var idx;
		var tailbits;
		var input = data.replace(/[\r\n=]/g, "");
		var max = input.length;
		var map = BASE64_MAP;
		var bits = 0;
		var result = [];
		for (idx = 0; idx < max; idx++) {
			if (idx % 4 === 0 && idx) {
				result.push(bits >> 16 & 255);
				result.push(bits >> 8 & 255);
				result.push(bits & 255);
			}
			bits = bits << 6 | map.indexOf(input.charAt(idx));
		}
		tailbits = max % 4 * 6;
		if (tailbits === 0) {
			result.push(bits >> 16 & 255);
			result.push(bits >> 8 & 255);
			result.push(bits & 255);
		} else if (tailbits === 18) {
			result.push(bits >> 10 & 255);
			result.push(bits >> 2 & 255);
		} else if (tailbits === 12) result.push(bits >> 4 & 255);
		if (NodeBuffer) return new NodeBuffer(result);
		return result;
	}
	function representYamlBinary(object) {
		var result = "";
		var bits = 0;
		var idx;
		var tail;
		var max = object.length;
		var map = BASE64_MAP;
		for (idx = 0; idx < max; idx++) {
			if (idx % 3 === 0 && idx) {
				result += map[bits >> 18 & 63];
				result += map[bits >> 12 & 63];
				result += map[bits >> 6 & 63];
				result += map[bits & 63];
			}
			bits = (bits << 8) + object[idx];
		}
		tail = max % 3;
		if (tail === 0) {
			result += map[bits >> 18 & 63];
			result += map[bits >> 12 & 63];
			result += map[bits >> 6 & 63];
			result += map[bits & 63];
		} else if (tail === 2) {
			result += map[bits >> 10 & 63];
			result += map[bits >> 4 & 63];
			result += map[bits << 2 & 63];
			result += map[64];
		} else if (tail === 1) {
			result += map[bits >> 2 & 63];
			result += map[bits << 4 & 63];
			result += map[64];
			result += map[64];
		}
		return result;
	}
	function isBinary(object) {
		return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:binary", {
		kind: "scalar",
		resolve: resolveYamlBinary,
		construct: constructYamlBinary,
		predicate: isBinary,
		represent: representYamlBinary
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/omap.js
var require_omap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString = Object.prototype.toString;
	function resolveYamlOmap(data) {
		if (null === data) return true;
		var objectKeys = [];
		var index;
		var length;
		var pair;
		var pairKey;
		var pairHasKey;
		var object = data;
		for (index = 0, length = object.length; index < length; index += 1) {
			pair = object[index];
			pairHasKey = false;
			if ("[object Object]" !== _toString.call(pair)) return false;
			for (pairKey in pair) if (_hasOwnProperty.call(pair, pairKey)) if (!pairHasKey) pairHasKey = true;
			else return false;
			if (!pairHasKey) return false;
			if (-1 === objectKeys.indexOf(pairKey)) objectKeys.push(pairKey);
			else return false;
		}
		return true;
	}
	function constructYamlOmap(data) {
		return null !== data ? data : [];
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:omap", {
		kind: "sequence",
		resolve: resolveYamlOmap,
		construct: constructYamlOmap
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/pairs.js
var require_pairs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	const ast = require_yamlAST();
	var _toString = Object.prototype.toString;
	function resolveYamlPairs(data) {
		if (null === data) return true;
		if (data.kind != ast.Kind.SEQ) return false;
		var index;
		var length;
		var pair;
		var object = data.items;
		for (index = 0, length = object.length; index < length; index += 1) {
			pair = object[index];
			if ("[object Object]" !== _toString.call(pair)) return false;
			if (!Array.isArray(pair.mappings)) return false;
			if (1 !== pair.mappings.length) return false;
		}
		return true;
	}
	function constructYamlPairs(data) {
		if (null === data || !Array.isArray(data.items)) return [];
		let index;
		let length;
		let result;
		let object = data.items;
		result = ast.newItems();
		result.parent = data.parent;
		result.startPosition = data.startPosition;
		result.endPosition = data.endPosition;
		for (index = 0, length = object.length; index < length; index += 1) {
			let mapping = object[index].mappings[0];
			let pairSeq = ast.newItems();
			pairSeq.parent = result;
			pairSeq.startPosition = mapping.key.startPosition;
			pairSeq.endPosition = mapping.value.startPosition;
			mapping.key.parent = pairSeq;
			mapping.value.parent = pairSeq;
			pairSeq.items = [mapping.key, mapping.value];
			result.items.push(pairSeq);
		}
		return result;
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:pairs", {
		kind: "sequence",
		resolve: resolveYamlPairs,
		construct: constructYamlPairs
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/set.js
var require_set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	const ast = require_yamlAST();
	function resolveYamlSet(data) {
		if (null === data) return true;
		if (data.kind != ast.Kind.MAP) return false;
		return true;
	}
	function constructYamlSet(data) {
		return null !== data ? data : {};
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:set", {
		kind: "mapping",
		resolve: resolveYamlSet,
		construct: constructYamlSet
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_safe.js
var require_default_safe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var schema = new (require_schema()).Schema({
		include: [require_core()],
		implicit: [require_timestamp(), require_merge()],
		explicit: [
			require_binary(),
			require_omap(),
			require_pairs(),
			require_set()
		]
	});
	module.exports = schema;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/undefined.js
var require_undefined = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	function resolveJavascriptUndefined() {
		return true;
	}
	function constructJavascriptUndefined() {}
	function representJavascriptUndefined() {
		return "";
	}
	function isUndefined(object) {
		return "undefined" === typeof object;
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:js/undefined", {
		kind: "scalar",
		resolve: resolveJavascriptUndefined,
		construct: constructJavascriptUndefined,
		predicate: isUndefined,
		represent: representJavascriptUndefined
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/regexp.js
var require_regexp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const type_1 = require_type();
	function resolveJavascriptRegExp(data) {
		if (null === data) return false;
		if (0 === data.length) return false;
		var regexp = data;
		var tail = /\/([gim]*)$/.exec(data);
		var modifiers = "";
		if ("/" === regexp[0]) {
			if (tail) modifiers = tail[1];
			if (modifiers.length > 3) return false;
			if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
			regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
		}
		try {
			return true;
		} catch (error) {
			return false;
		}
	}
	function constructJavascriptRegExp(data) {
		var regexp = data;
		var tail = /\/([gim]*)$/.exec(data);
		var modifiers = "";
		if ("/" === regexp[0]) {
			if (tail) modifiers = tail[1];
			regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
		}
		return new RegExp(regexp, modifiers);
	}
	function representJavascriptRegExp(object) {
		var result = "/" + object.source + "/";
		if (object.global) result += "g";
		if (object.multiline) result += "m";
		if (object.ignoreCase) result += "i";
		return result;
	}
	function isRegExp(object) {
		return "[object RegExp]" === Object.prototype.toString.call(object);
	}
	module.exports = new type_1.Type("tag:yaml.org,2002:js/regexp", {
		kind: "scalar",
		resolve: resolveJavascriptRegExp,
		construct: constructJavascriptRegExp,
		predicate: isRegExp,
		represent: representJavascriptRegExp
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_full.js
var require_default_full = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const schema_1 = require_schema();
	var schema = new schema_1.Schema({
		include: [require_default_safe()],
		explicit: [require_undefined(), require_regexp()]
	});
	schema_1.Schema.DEFAULT = schema;
	module.exports = schema;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/loader.js
var require_loader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ast = require_yamlAST();
	const common = require_common();
	const YAMLException = require_exception();
	const Mark = require_mark();
	const DEFAULT_SAFE_SCHEMA = require_default_safe();
	const DEFAULT_FULL_SCHEMA = require_default_full();
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CONTEXT_FLOW_IN = 1;
	var CONTEXT_FLOW_OUT = 2;
	var CONTEXT_BLOCK_IN = 3;
	var CONTEXT_BLOCK_OUT = 4;
	var CHOMPING_CLIP = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP = 3;
	var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	function is_EOL(c) {
		return c === 10 || c === 13;
	}
	function is_WHITE_SPACE(c) {
		return c === 9 || c === 32;
	}
	function is_WS_OR_EOL(c) {
		return c === 9 || c === 32 || c === 10 || c === 13;
	}
	function is_FLOW_INDICATOR(c) {
		return 44 === c || 91 === c || 93 === c || 123 === c || 125 === c;
	}
	function fromHexCode(c) {
		var lc;
		if (48 <= c && c <= 57) return c - 48;
		lc = c | 32;
		if (97 <= lc && lc <= 102) return lc - 97 + 10;
		return -1;
	}
	function escapedHexLen(c) {
		if (c === 120) return 2;
		if (c === 117) return 4;
		if (c === 85) return 8;
		return 0;
	}
	function fromDecimalCode(c) {
		if (48 <= c && c <= 57) return c - 48;
		return -1;
	}
	function simpleEscapeSequence(c) {
		return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? "\"" : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
	}
	function charFromCodepoint(c) {
		if (c <= 65535) return String.fromCharCode(c);
		return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
	}
	var simpleEscapeCheck = new Array(256);
	var simpleEscapeMap = new Array(256);
	var customEscapeCheck = new Array(256);
	var customEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
		customEscapeMap[i] = simpleEscapeMap[i] = simpleEscapeSequence(i);
		simpleEscapeCheck[i] = simpleEscapeMap[i] ? 1 : 0;
		customEscapeCheck[i] = 1;
		if (!simpleEscapeCheck[i]) customEscapeMap[i] = "\\" + String.fromCharCode(i);
	}
	var State = class {
		constructor(input, options) {
			this.errorMap = {};
			this.errors = [];
			this.lines = [];
			this.input = input;
			this.filename = options["filename"] || null;
			this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
			this.onWarning = options["onWarning"] || null;
			this.legacy = options["legacy"] || false;
			this.allowAnyEscape = options["allowAnyEscape"] || false;
			this.ignoreDuplicateKeys = options["ignoreDuplicateKeys"] || false;
			this.implicitTypes = this.schema.compiledImplicit;
			this.typeMap = this.schema.compiledTypeMap;
			this.length = input.length;
			this.position = 0;
			this.line = 0;
			this.lineStart = 0;
			this.lineIndent = 0;
			this.documents = [];
		}
	};
	function generateError(state, message, isWarning = false) {
		return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart), isWarning);
	}
	function throwErrorFromPosition(state, position, message, isWarning = false, toLineEnd = false) {
		var line = positionToLine(state, position);
		if (!line) return;
		var hash = message + position;
		if (state.errorMap[hash]) return;
		var mark = new Mark(state.filename, state.input, position, line.line, position - line.start);
		if (toLineEnd) mark.toLineEnd = true;
		var error = new YAMLException(message, mark, isWarning);
		state.errors.push(error);
	}
	function throwError(state, message) {
		var error = generateError(state, message);
		var hash = error.message + error.mark.position;
		if (state.errorMap[hash]) return;
		state.errors.push(error);
		state.errorMap[hash] = 1;
		var or = state.position;
		while (true) {
			if (state.position >= state.input.length - 1) return;
			var c = state.input.charAt(state.position);
			if (c == "\n") {
				state.position--;
				if (state.position == or) state.position += 1;
				return;
			}
			if (c == "\r") {
				state.position--;
				if (state.position == or) state.position += 1;
				return;
			}
			state.position++;
		}
	}
	function throwWarning(state, message) {
		var error = generateError(state, message);
		if (state.onWarning) state.onWarning.call(null, error);
	}
	var directiveHandlers = {
		YAML: function handleYamlDirective(state, name, args) {
			var match;
			var major;
			var minor;
			if (null !== state.version) throwError(state, "duplication of %YAML directive");
			if (1 !== args.length) throwError(state, "YAML directive accepts exactly one argument");
			match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
			if (null === match) throwError(state, "ill-formed argument of the YAML directive");
			major = parseInt(match[1], 10);
			minor = parseInt(match[2], 10);
			if (1 !== major) throwError(state, "found incompatible YAML document (version 1.2 is required)");
			state.version = args[0];
			state.checkLineBreaks = minor < 2;
			if (2 !== minor) throwError(state, "found incompatible YAML document (version 1.2 is required)");
		},
		TAG: function handleTagDirective(state, name, args) {
			var handle;
			var prefix;
			if (2 !== args.length) throwError(state, "TAG directive accepts exactly two arguments");
			handle = args[0];
			prefix = args[1];
			if (!PATTERN_TAG_HANDLE.test(handle)) throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
			if (_hasOwnProperty.call(state.tagMap, handle)) throwError(state, "there is a previously declared suffix for \"" + handle + "\" tag handle");
			if (!PATTERN_TAG_URI.test(prefix)) throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
			state.tagMap[handle] = prefix;
		}
	};
	function captureSegment(state, start, end, checkJson) {
		var _position;
		var _length;
		var _character;
		var _result;
		var scalar = state.result;
		if (scalar.startPosition == -1) scalar.startPosition = start;
		if (start <= end) {
			_result = state.input.slice(start, end);
			if (checkJson) for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
				_character = _result.charCodeAt(_position);
				if (!(9 === _character || 32 <= _character && _character <= 1114111)) throwError(state, "expected valid JSON character");
			}
			else if (PATTERN_NON_PRINTABLE.test(_result)) throwError(state, "the stream contains non-printable characters");
			scalar.value += _result;
			scalar.endPosition = end;
		}
	}
	function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
		if (keyNode == null) return;
		if (null === _result) _result = {
			startPosition: keyNode.startPosition,
			endPosition: valueNode.endPosition,
			parent: null,
			errors: [],
			mappings: [],
			kind: ast.Kind.MAP
		};
		var mapping = ast.newMapping(keyNode, valueNode);
		mapping.parent = _result;
		keyNode.parent = mapping;
		if (valueNode != null) valueNode.parent = mapping;
		!state.ignoreDuplicateKeys && _result.mappings.forEach((sibling) => {
			if (sibling.key && sibling.key.value === (mapping.key && mapping.key.value)) {
				throwErrorFromPosition(state, mapping.key.startPosition, "duplicate key");
				throwErrorFromPosition(state, sibling.key.startPosition, "duplicate key");
			}
		});
		_result.mappings.push(mapping);
		_result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1;
		return _result;
	}
	function readLineBreak(state) {
		var ch = state.input.charCodeAt(state.position);
		if (10 === ch) state.position++;
		else if (13 === ch) {
			state.position++;
			if (10 === state.input.charCodeAt(state.position)) state.position++;
		} else throwError(state, "a line break is expected");
		state.line += 1;
		state.lineStart = state.position;
		state.lines.push({
			start: state.lineStart,
			line: state.line
		});
	}
	function positionToLine(state, position) {
		var line;
		for (var i = 0; i < state.lines.length; i++) {
			if (state.lines[i].start > position) break;
			line = state.lines[i];
		}
		if (!line) return {
			start: 0,
			line: 0
		};
		return line;
	}
	function readComment(state) {
		var ch = 0;
		var _position = state.position;
		do
			ch = state.input.charCodeAt(++state.position);
		while (0 !== ch && !is_EOL(ch));
		state.comments.push({
			startPosition: _position,
			endPosition: state.position,
			value: state.input.slice(_position + 1, state.position)
		});
	}
	function skipSeparationSpace(state, allowComments, checkIndent) {
		var lineBreaks = 0;
		var ch = state.input.charCodeAt(state.position);
		while (0 !== ch) {
			while (is_WHITE_SPACE(ch)) {
				if (ch === 9) state.errors.push(generateError(state, "Using tabs can lead to unpredictable results", true));
				ch = state.input.charCodeAt(++state.position);
			}
			if (allowComments && 35 === ch) {
				readComment(state);
				ch = state.input.charCodeAt(state.position);
			}
			if (is_EOL(ch)) {
				readLineBreak(state);
				ch = state.input.charCodeAt(state.position);
				lineBreaks++;
				state.lineIndent = 0;
				while (32 === ch) {
					state.lineIndent++;
					ch = state.input.charCodeAt(++state.position);
				}
			} else break;
		}
		if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) throwWarning(state, "deficient indentation");
		return lineBreaks;
	}
	function testDocumentSeparator(state) {
		var _position = state.position;
		var ch = state.input.charCodeAt(_position);
		if ((45 === ch || 46 === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {
			_position += 3;
			ch = state.input.charCodeAt(_position);
			if (ch === 0 || is_WS_OR_EOL(ch)) return true;
		}
		return false;
	}
	function writeFoldedLines(state, scalar, count) {
		if (1 === count) scalar.value += " ";
		else if (count > 1) scalar.value += common.repeat("\n", count - 1);
	}
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
		var preceding;
		var following;
		var captureStart;
		var captureEnd;
		var hasPendingContent;
		var _line;
		var _lineStart;
		var _lineIndent;
		var _kind = state.kind;
		var _result = state.result;
		var ch;
		var state_result = ast.newScalar();
		state_result.plainScalar = true;
		state.result = state_result;
		ch = state.input.charCodeAt(state.position);
		if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 35 === ch || 38 === ch || 42 === ch || 33 === ch || 124 === ch || 62 === ch || 39 === ch || 34 === ch || 37 === ch || 64 === ch || 96 === ch) return false;
		if (63 === ch || 45 === ch) {
			following = state.input.charCodeAt(state.position + 1);
			if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) return false;
		}
		state.kind = "scalar";
		captureStart = captureEnd = state.position;
		hasPendingContent = false;
		while (0 !== ch) {
			if (58 === ch) {
				following = state.input.charCodeAt(state.position + 1);
				if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) break;
			} else if (35 === ch) {
				preceding = state.input.charCodeAt(state.position - 1);
				if (is_WS_OR_EOL(preceding)) break;
			} else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) break;
			else if (is_EOL(ch)) {
				_line = state.line;
				_lineStart = state.lineStart;
				_lineIndent = state.lineIndent;
				skipSeparationSpace(state, false, -1);
				if (state.lineIndent >= nodeIndent) {
					hasPendingContent = true;
					ch = state.input.charCodeAt(state.position);
					continue;
				} else {
					state.position = captureEnd;
					state.line = _line;
					state.lineStart = _lineStart;
					state.lineIndent = _lineIndent;
					break;
				}
			}
			if (hasPendingContent) {
				captureSegment(state, captureStart, captureEnd, false);
				writeFoldedLines(state, state_result, state.line - _line);
				captureStart = captureEnd = state.position;
				hasPendingContent = false;
			}
			if (!is_WHITE_SPACE(ch)) captureEnd = state.position + 1;
			ch = state.input.charCodeAt(++state.position);
			if (state.position >= state.input.length) return false;
		}
		captureSegment(state, captureStart, captureEnd, false);
		if (state.result.startPosition != -1) {
			state_result.rawValue = state.input.substring(state_result.startPosition, state_result.endPosition);
			return true;
		}
		state.kind = _kind;
		state.result = _result;
		return false;
	}
	function readSingleQuotedScalar(state, nodeIndent) {
		var ch = state.input.charCodeAt(state.position);
		var captureStart;
		var captureEnd;
		if (39 !== ch) return false;
		var scalar = ast.newScalar();
		scalar.singleQuoted = true;
		state.kind = "scalar";
		state.result = scalar;
		scalar.startPosition = state.position;
		state.position++;
		captureStart = captureEnd = state.position;
		while (0 !== (ch = state.input.charCodeAt(state.position))) if (39 === ch) {
			captureSegment(state, captureStart, state.position, true);
			ch = state.input.charCodeAt(++state.position);
			scalar.endPosition = state.position;
			if (39 === ch) {
				captureStart = captureEnd = state.position;
				state.position++;
			} else return true;
		} else if (is_EOL(ch)) {
			captureSegment(state, captureStart, captureEnd, true);
			writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
			captureStart = captureEnd = state.position;
		} else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, "unexpected end of the document within a single quoted scalar");
		else {
			state.position++;
			captureEnd = state.position;
			scalar.endPosition = state.position;
		}
		throwError(state, "unexpected end of the stream within a single quoted scalar");
	}
	function readDoubleQuotedScalar(state, nodeIndent) {
		var captureStart;
		var captureEnd;
		var hexLength;
		var hexResult;
		var tmp;
		var ch = state.input.charCodeAt(state.position);
		if (34 !== ch) return false;
		state.kind = "scalar";
		var scalar = ast.newScalar();
		scalar.doubleQuoted = true;
		state.result = scalar;
		scalar.startPosition = state.position;
		state.position++;
		captureStart = captureEnd = state.position;
		while (0 !== (ch = state.input.charCodeAt(state.position))) if (34 === ch) {
			captureSegment(state, captureStart, state.position, true);
			state.position++;
			scalar.endPosition = state.position;
			scalar.rawValue = state.input.substring(scalar.startPosition, scalar.endPosition);
			return true;
		} else if (92 === ch) {
			captureSegment(state, captureStart, state.position, true);
			ch = state.input.charCodeAt(++state.position);
			if (is_EOL(ch)) skipSeparationSpace(state, false, nodeIndent);
			else if (ch < 256 && (state.allowAnyEscape ? customEscapeCheck[ch] : simpleEscapeCheck[ch])) {
				scalar.value += state.allowAnyEscape ? customEscapeMap[ch] : simpleEscapeMap[ch];
				state.position++;
			} else if ((tmp = escapedHexLen(ch)) > 0) {
				hexLength = tmp;
				hexResult = 0;
				for (; hexLength > 0; hexLength--) {
					ch = state.input.charCodeAt(++state.position);
					if ((tmp = fromHexCode(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
					else throwError(state, "expected hexadecimal character");
				}
				scalar.value += charFromCodepoint(hexResult);
				state.position++;
			} else throwError(state, "unknown escape sequence");
			captureStart = captureEnd = state.position;
		} else if (is_EOL(ch)) {
			captureSegment(state, captureStart, captureEnd, true);
			writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
			captureStart = captureEnd = state.position;
		} else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, "unexpected end of the document within a double quoted scalar");
		else {
			state.position++;
			captureEnd = state.position;
		}
		throwError(state, "unexpected end of the stream within a double quoted scalar");
	}
	function readFlowCollection(state, nodeIndent) {
		var readNext = true;
		var _line;
		var _tag = state.tag;
		var _result;
		var _anchor = state.anchor;
		var following;
		var terminator;
		var isPair;
		var isExplicitPair;
		var isMapping;
		var keyNode;
		var keyTag;
		var valueNode;
		var ch = state.input.charCodeAt(state.position);
		if (ch === 91) {
			terminator = 93;
			isMapping = false;
			_result = ast.newItems();
			_result.startPosition = state.position;
		} else if (ch === 123) {
			terminator = 125;
			isMapping = true;
			_result = ast.newMap();
			_result.startPosition = state.position;
		} else return false;
		if (null !== state.anchor) {
			_result.anchorId = state.anchor;
			state.anchorMap[state.anchor] = _result;
		}
		ch = state.input.charCodeAt(++state.position);
		while (0 !== ch) {
			skipSeparationSpace(state, true, nodeIndent);
			ch = state.input.charCodeAt(state.position);
			if (ch === terminator) {
				state.position++;
				state.tag = _tag;
				state.anchor = _anchor;
				state.kind = isMapping ? "mapping" : "sequence";
				state.result = _result;
				_result.endPosition = state.position;
				return true;
			} else if (!readNext) {
				var p = state.position;
				throwError(state, "missed comma between flow collection entries");
				state.position = p + 1;
			}
			keyTag = keyNode = valueNode = null;
			isPair = isExplicitPair = false;
			if (63 === ch) {
				following = state.input.charCodeAt(state.position + 1);
				if (is_WS_OR_EOL(following)) {
					isPair = isExplicitPair = true;
					state.position++;
					skipSeparationSpace(state, true, nodeIndent);
				}
			}
			_line = state.line;
			composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
			keyTag = state.tag;
			keyNode = state.result;
			skipSeparationSpace(state, true, nodeIndent);
			ch = state.input.charCodeAt(state.position);
			if ((isExplicitPair || state.line === _line) && 58 === ch) {
				isPair = true;
				ch = state.input.charCodeAt(++state.position);
				skipSeparationSpace(state, true, nodeIndent);
				composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
				valueNode = state.result;
			}
			if (isMapping) storeMappingPair(state, _result, keyTag, keyNode, valueNode);
			else if (isPair) {
				var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
				mp.parent = _result;
				_result.items.push(mp);
			} else {
				if (keyNode) keyNode.parent = _result;
				_result.items.push(keyNode);
			}
			_result.endPosition = state.position + 1;
			skipSeparationSpace(state, true, nodeIndent);
			ch = state.input.charCodeAt(state.position);
			if (44 === ch) {
				readNext = true;
				ch = state.input.charCodeAt(++state.position);
			} else readNext = false;
		}
		throwError(state, "unexpected end of the stream within a flow collection");
	}
	function readBlockScalar(state, nodeIndent) {
		var captureStart;
		var folding;
		var chomping = CHOMPING_CLIP;
		var detectedIndent = false;
		var textIndent = nodeIndent;
		var emptyLines = 0;
		var atMoreIndented = false;
		var tmp;
		var ch = state.input.charCodeAt(state.position);
		if (ch === 124) folding = false;
		else if (ch === 62) folding = true;
		else return false;
		var sc = ast.newScalar();
		state.kind = "scalar";
		state.result = sc;
		sc.startPosition = state.position;
		while (0 !== ch) {
			ch = state.input.charCodeAt(++state.position);
			if (43 === ch || 45 === ch) if (CHOMPING_CLIP === chomping) chomping = 43 === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
			else throwError(state, "repeat of a chomping mode identifier");
			else if ((tmp = fromDecimalCode(ch)) >= 0) if (tmp === 0) throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
			else if (!detectedIndent) {
				textIndent = nodeIndent + tmp - 1;
				detectedIndent = true;
			} else throwError(state, "repeat of an indentation width identifier");
			else break;
		}
		if (is_WHITE_SPACE(ch)) {
			do
				ch = state.input.charCodeAt(++state.position);
			while (is_WHITE_SPACE(ch));
			if (35 === ch) {
				readComment(state);
				ch = state.input.charCodeAt(state.position);
			}
		}
		while (0 !== ch) {
			readLineBreak(state);
			state.lineIndent = 0;
			ch = state.input.charCodeAt(state.position);
			while ((!detectedIndent || state.lineIndent < textIndent) && 32 === ch) {
				state.lineIndent++;
				ch = state.input.charCodeAt(++state.position);
			}
			if (!detectedIndent && state.lineIndent > textIndent) textIndent = state.lineIndent;
			if (is_EOL(ch)) {
				emptyLines++;
				continue;
			}
			if (state.lineIndent < textIndent) {
				if (chomping === CHOMPING_KEEP) sc.value += common.repeat("\n", emptyLines);
				else if (chomping === CHOMPING_CLIP) {
					if (detectedIndent) sc.value += "\n";
				}
				break;
			}
			if (folding) if (is_WHITE_SPACE(ch)) {
				atMoreIndented = true;
				sc.value += common.repeat("\n", emptyLines + 1);
			} else if (atMoreIndented) {
				atMoreIndented = false;
				sc.value += common.repeat("\n", emptyLines + 1);
			} else if (0 === emptyLines) {
				if (detectedIndent) sc.value += " ";
			} else sc.value += common.repeat("\n", emptyLines);
			else if (detectedIndent) sc.value += common.repeat("\n", emptyLines + 1);
			detectedIndent = true;
			emptyLines = 0;
			captureStart = state.position;
			while (!is_EOL(ch) && 0 !== ch) ch = state.input.charCodeAt(++state.position);
			captureSegment(state, captureStart, state.position, false);
		}
		sc.endPosition = state.position;
		var i = state.position - 1;
		var needMinus = false;
		while (true) {
			var c = state.input[i];
			if (c == "\r" || c == "\n") {
				if (needMinus) i--;
				break;
			}
			if (c != " " && c != "	") break;
			i--;
		}
		sc.endPosition = i;
		sc.rawValue = state.input.substring(sc.startPosition, sc.endPosition);
		return true;
	}
	function readBlockSequence(state, nodeIndent) {
		var _line;
		var _tag = state.tag;
		var _anchor = state.anchor;
		var _result = ast.newItems();
		var following;
		var detected = false;
		var ch;
		if (null !== state.anchor) {
			_result.anchorId = state.anchor;
			state.anchorMap[state.anchor] = _result;
		}
		_result.startPosition = state.position;
		ch = state.input.charCodeAt(state.position);
		while (0 !== ch) {
			if (45 !== ch) break;
			following = state.input.charCodeAt(state.position + 1);
			if (!is_WS_OR_EOL(following)) break;
			detected = true;
			state.position++;
			if (skipSeparationSpace(state, true, -1)) {
				if (state.lineIndent <= nodeIndent) {
					_result.items.push(null);
					ch = state.input.charCodeAt(state.position);
					continue;
				}
			}
			_line = state.line;
			composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
			if (state.result) {
				state.result.parent = _result;
				_result.items.push(state.result);
			}
			skipSeparationSpace(state, true, -1);
			ch = state.input.charCodeAt(state.position);
			if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) throwError(state, "bad indentation of a sequence entry");
			else if (state.lineIndent < nodeIndent) break;
		}
		_result.endPosition = state.position;
		if (detected) {
			state.tag = _tag;
			state.anchor = _anchor;
			state.kind = "sequence";
			state.result = _result;
			_result.endPosition = state.position;
			return true;
		}
		return false;
	}
	function readBlockMapping(state, nodeIndent, flowIndent) {
		var following;
		var allowCompact;
		var _line;
		var _tag = state.tag;
		var _anchor = state.anchor;
		var _result = ast.newMap();
		var keyTag = null;
		var keyNode = null;
		var valueNode = null;
		var atExplicitKey = false;
		var detected = false;
		var ch;
		_result.startPosition = state.position;
		if (null !== state.anchor) {
			_result.anchorId = state.anchor;
			state.anchorMap[state.anchor] = _result;
		}
		ch = state.input.charCodeAt(state.position);
		while (0 !== ch) {
			following = state.input.charCodeAt(state.position + 1);
			_line = state.line;
			if ((63 === ch || 58 === ch) && is_WS_OR_EOL(following)) {
				if (63 === ch) {
					if (atExplicitKey) {
						storeMappingPair(state, _result, keyTag, keyNode, null);
						keyTag = keyNode = valueNode = null;
					}
					detected = true;
					atExplicitKey = true;
					allowCompact = true;
				} else if (atExplicitKey) {
					atExplicitKey = false;
					allowCompact = true;
				} else throwError(state, "incomplete explicit mapping pair; a key node is missed");
				state.position += 1;
				ch = following;
			} else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) if (state.line === _line) {
				ch = state.input.charCodeAt(state.position);
				while (is_WHITE_SPACE(ch)) ch = state.input.charCodeAt(++state.position);
				if (58 === ch) {
					ch = state.input.charCodeAt(++state.position);
					if (!is_WS_OR_EOL(ch)) throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
					if (atExplicitKey) {
						storeMappingPair(state, _result, keyTag, keyNode, null);
						keyTag = keyNode = valueNode = null;
					}
					detected = true;
					atExplicitKey = false;
					allowCompact = false;
					keyTag = state.tag;
					keyNode = state.result;
				} else if (state.position == state.lineStart && testDocumentSeparator(state)) break;
				else if (detected) throwError(state, "can not read an implicit mapping pair; a colon is missed");
				else {
					state.tag = _tag;
					state.anchor = _anchor;
					return true;
				}
			} else if (detected) {
				throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
				while (state.position > 0) {
					ch = state.input.charCodeAt(--state.position);
					if (is_EOL(ch)) {
						state.position++;
						break;
					}
				}
			} else {
				state.tag = _tag;
				state.anchor = _anchor;
				return true;
			}
			else break;
			if (state.line === _line || state.lineIndent > nodeIndent) {
				if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) if (atExplicitKey) keyNode = state.result;
				else valueNode = state.result;
				if (!atExplicitKey) {
					storeMappingPair(state, _result, keyTag, keyNode, valueNode);
					keyTag = keyNode = valueNode = null;
				}
				skipSeparationSpace(state, true, -1);
				ch = state.input.charCodeAt(state.position);
			}
			if (state.lineIndent > nodeIndent && 0 !== ch) throwError(state, "bad indentation of a mapping entry");
			else if (state.lineIndent < nodeIndent) break;
		}
		if (atExplicitKey) storeMappingPair(state, _result, keyTag, keyNode, null);
		if (detected) {
			state.tag = _tag;
			state.anchor = _anchor;
			state.kind = "mapping";
			state.result = _result;
		}
		return detected;
	}
	function readTagProperty(state) {
		var _position;
		var isVerbatim = false;
		var isNamed = false;
		var tagHandle;
		var tagName;
		var ch = state.input.charCodeAt(state.position);
		if (33 !== ch) return false;
		if (null !== state.tag) throwError(state, "duplication of a tag property");
		ch = state.input.charCodeAt(++state.position);
		if (60 === ch) {
			isVerbatim = true;
			ch = state.input.charCodeAt(++state.position);
		} else if (33 === ch) {
			isNamed = true;
			tagHandle = "!!";
			ch = state.input.charCodeAt(++state.position);
		} else tagHandle = "!";
		_position = state.position;
		if (isVerbatim) {
			do
				ch = state.input.charCodeAt(++state.position);
			while (0 !== ch && 62 !== ch);
			if (state.position < state.length) {
				tagName = state.input.slice(_position, state.position);
				ch = state.input.charCodeAt(++state.position);
			} else throwError(state, "unexpected end of the stream within a verbatim tag");
		} else {
			while (0 !== ch && !is_WS_OR_EOL(ch)) {
				if (33 === ch) if (!isNamed) {
					tagHandle = state.input.slice(_position - 1, state.position + 1);
					if (!PATTERN_TAG_HANDLE.test(tagHandle)) throwError(state, "named tag handle cannot contain such characters");
					isNamed = true;
					_position = state.position + 1;
				} else throwError(state, "tag suffix cannot contain exclamation marks");
				ch = state.input.charCodeAt(++state.position);
			}
			tagName = state.input.slice(_position, state.position);
			if (PATTERN_FLOW_INDICATORS.test(tagName)) throwError(state, "tag suffix cannot contain flow indicator characters");
		}
		if (tagName && !PATTERN_TAG_URI.test(tagName)) throwError(state, "tag name cannot contain such characters: " + tagName);
		if (isVerbatim) state.tag = tagName;
		else if (_hasOwnProperty.call(state.tagMap, tagHandle)) state.tag = state.tagMap[tagHandle] + tagName;
		else if ("!" === tagHandle) state.tag = "!" + tagName;
		else if ("!!" === tagHandle) state.tag = "tag:yaml.org,2002:" + tagName;
		else throwError(state, "undeclared tag handle \"" + tagHandle + "\"");
		return true;
	}
	function readAnchorProperty(state) {
		var _position;
		var ch = state.input.charCodeAt(state.position);
		if (38 !== ch) return false;
		if (null !== state.anchor) throwError(state, "duplication of an anchor property");
		ch = state.input.charCodeAt(++state.position);
		_position = state.position;
		while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) ch = state.input.charCodeAt(++state.position);
		if (state.position === _position) throwError(state, "name of an anchor node must contain at least one character");
		state.anchor = state.input.slice(_position, state.position);
		return true;
	}
	function readAlias(state) {
		var _position;
		var alias;
		state.length;
		state.input;
		var ch = state.input.charCodeAt(state.position);
		if (42 !== ch) return false;
		ch = state.input.charCodeAt(++state.position);
		_position = state.position;
		while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) ch = state.input.charCodeAt(++state.position);
		if (state.position <= _position) {
			throwError(state, "name of an alias node must contain at least one character");
			state.position = _position + 1;
		}
		alias = state.input.slice(_position, state.position);
		if (!state.anchorMap.hasOwnProperty(alias)) {
			throwError(state, "unidentified alias \"" + alias + "\"");
			if (state.position <= _position) state.position = _position + 1;
		}
		state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
		skipSeparationSpace(state, true, -1);
		return true;
	}
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
		var allowBlockStyles;
		var allowBlockScalars;
		var allowBlockCollections;
		var indentStatus = 1;
		var atNewLine = false;
		var hasContent = false;
		var typeIndex;
		var typeQuantity;
		var type;
		var flowIndent;
		var blockIndent;
		state.tag = null;
		state.anchor = null;
		state.kind = null;
		state.result = null;
		allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
		if (allowToSeek) {
			if (skipSeparationSpace(state, true, -1)) {
				atNewLine = true;
				if (state.lineIndent > parentIndent) indentStatus = 1;
				else if (state.lineIndent === parentIndent) indentStatus = 0;
				else if (state.lineIndent < parentIndent) indentStatus = -1;
			}
		}
		let tagStart = state.position;
		state.position - state.lineStart;
		if (1 === indentStatus) while (readTagProperty(state) || readAnchorProperty(state)) if (skipSeparationSpace(state, true, -1)) {
			atNewLine = true;
			allowBlockCollections = allowBlockStyles;
			if (state.lineIndent > parentIndent) indentStatus = 1;
			else if (state.lineIndent === parentIndent) indentStatus = 0;
			else if (state.lineIndent < parentIndent) indentStatus = -1;
		} else allowBlockCollections = false;
		if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
		if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
			if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) flowIndent = parentIndent;
			else flowIndent = parentIndent + 1;
			blockIndent = state.position - state.lineStart;
			if (1 === indentStatus) if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) hasContent = true;
			else {
				if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) hasContent = true;
				else if (readAlias(state)) {
					hasContent = true;
					if (null !== state.tag || null !== state.anchor) throwError(state, "alias node should not have any properties");
				} else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
					hasContent = true;
					if (null === state.tag) state.tag = "?";
				}
				if (null !== state.anchor) {
					state.anchorMap[state.anchor] = state.result;
					state.result.anchorId = state.anchor;
				}
			}
			else if (0 === indentStatus) hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
		}
		if (null !== state.tag && "!" !== state.tag) if (state.tag == "!include") {
			if (!state.result) {
				state.result = ast.newScalar();
				state.result.startPosition = state.position;
				state.result.endPosition = state.position;
				throwError(state, "!include without value");
			}
			state.result.kind = ast.Kind.INCLUDE_REF;
		} else if ("?" === state.tag) for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
			type = state.implicitTypes[typeIndex];
			var vl = state.result["value"];
			if (type.resolve(vl)) {
				state.result.valueObject = type.construct(state.result["value"]);
				state.tag = type.tag;
				if (null !== state.anchor) {
					state.result.anchorId = state.anchor;
					state.anchorMap[state.anchor] = state.result;
				}
				break;
			}
		}
		else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
			type = state.typeMap[state.tag];
			if (null !== state.result && type.kind !== state.kind) throwError(state, "unacceptable node kind for !<" + state.tag + "> tag; it should be \"" + type.kind + "\", not \"" + state.kind + "\"");
			if (!type.resolve(state.result)) throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
			else {
				state.result = type.construct(state.result);
				if (null !== state.anchor) {
					state.result.anchorId = state.anchor;
					state.anchorMap[state.anchor] = state.result;
				}
			}
		} else throwErrorFromPosition(state, tagStart, "unknown tag <" + state.tag + ">", false, true);
		return null !== state.tag || null !== state.anchor || hasContent;
	}
	function readDocument(state) {
		var documentStart = state.position;
		var _position;
		var directiveName;
		var directiveArgs;
		var hasDirectives = false;
		var ch;
		state.version = null;
		state.checkLineBreaks = state.legacy;
		state.tagMap = {};
		state.anchorMap = {};
		state.comments = [];
		while (0 !== (ch = state.input.charCodeAt(state.position))) {
			skipSeparationSpace(state, true, -1);
			ch = state.input.charCodeAt(state.position);
			if (state.lineIndent > 0 || 37 !== ch) break;
			hasDirectives = true;
			ch = state.input.charCodeAt(++state.position);
			_position = state.position;
			while (0 !== ch && !is_WS_OR_EOL(ch)) ch = state.input.charCodeAt(++state.position);
			directiveName = state.input.slice(_position, state.position);
			directiveArgs = [];
			if (directiveName.length < 1) throwError(state, "directive name must not be less than one character in length");
			while (0 !== ch) {
				while (is_WHITE_SPACE(ch)) ch = state.input.charCodeAt(++state.position);
				if (35 === ch) {
					readComment(state);
					ch = state.input.charCodeAt(state.position);
					break;
				}
				if (is_EOL(ch)) break;
				_position = state.position;
				while (0 !== ch && !is_WS_OR_EOL(ch)) ch = state.input.charCodeAt(++state.position);
				directiveArgs.push(state.input.slice(_position, state.position));
			}
			if (0 !== ch) readLineBreak(state);
			if (_hasOwnProperty.call(directiveHandlers, directiveName)) directiveHandlers[directiveName](state, directiveName, directiveArgs);
			else {
				throwWarning(state, "unknown document directive \"" + directiveName + "\"");
				state.position++;
			}
		}
		skipSeparationSpace(state, true, -1);
		if (0 === state.lineIndent && 45 === state.input.charCodeAt(state.position) && 45 === state.input.charCodeAt(state.position + 1) && 45 === state.input.charCodeAt(state.position + 2)) {
			state.position += 3;
			skipSeparationSpace(state, true, -1);
		} else if (hasDirectives) throwError(state, "directives end mark is expected");
		composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
		skipSeparationSpace(state, true, -1);
		if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) throwWarning(state, "non-ASCII line breaks are interpreted as content");
		state.result.comments = state.comments;
		state.documents.push(state.result);
		if (state.position === state.lineStart && testDocumentSeparator(state)) {
			if (46 === state.input.charCodeAt(state.position)) {
				state.position += 3;
				skipSeparationSpace(state, true, -1);
			}
			return;
		}
		if (state.position < state.length - 1) throwError(state, "end of the stream or a document separator is expected");
		else return;
	}
	function loadDocuments(input, options) {
		input = String(input);
		options = options || {};
		let inputLength = input.length;
		if (inputLength !== 0) {
			if (10 !== input.charCodeAt(inputLength - 1) && 13 !== input.charCodeAt(inputLength - 1)) input += "\n";
			if (input.charCodeAt(0) === 65279) input = input.slice(1);
		}
		var state = new State(input, options);
		state.input += "\0";
		while (32 === state.input.charCodeAt(state.position)) {
			state.lineIndent += 1;
			state.position += 1;
		}
		while (state.position < state.length - 1) {
			var q = state.position;
			readDocument(state);
			if (state.position <= q) {
				for (; state.position < state.length - 1; state.position++) if (state.input.charAt(state.position) == "\n") break;
			}
		}
		let documents = state.documents;
		let docsCount = documents.length;
		if (docsCount > 0) documents[docsCount - 1].endPosition = inputLength;
		for (let x of documents) {
			x.errors = state.errors;
			if (x.startPosition > x.endPosition) x.startPosition = x.endPosition;
		}
		return documents;
	}
	function loadAll(input, iterator, options = {}) {
		var documents = loadDocuments(input, options);
		var index;
		var length;
		for (index = 0, length = documents.length; index < length; index += 1) iterator(documents[index]);
	}
	exports.loadAll = loadAll;
	function load(input, options = {}) {
		var documents = loadDocuments(input, options);
		if (0 === documents.length) return;
		else if (1 === documents.length) return documents[0];
		var e = new YAMLException("expected a single document in the stream, but found more");
		e.mark = new Mark("", "", 0, 0, 0);
		e.mark.position = documents[0].endPosition;
		documents[0].errors.push(e);
		return documents[0];
	}
	exports.load = load;
	function safeLoadAll(input, output, options = {}) {
		loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoadAll = safeLoadAll;
	function safeLoad(input, options = {}) {
		return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoad = safeLoad;
	module.exports.loadAll = loadAll;
	module.exports.load = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad = safeLoad;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/dumper.js
var require_dumper = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var common = require_common();
	var YAMLException = require_exception();
	var DEFAULT_FULL_SCHEMA = require_default_full();
	var DEFAULT_SAFE_SCHEMA = require_default_safe();
	var _toString = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CHAR_TAB = 9;
	var CHAR_LINE_FEED = 10;
	var CHAR_CARRIAGE_RETURN = 13;
	var CHAR_SPACE = 32;
	var CHAR_EXCLAMATION = 33;
	var CHAR_DOUBLE_QUOTE = 34;
	var CHAR_SHARP = 35;
	var CHAR_PERCENT = 37;
	var CHAR_AMPERSAND = 38;
	var CHAR_SINGLE_QUOTE = 39;
	var CHAR_ASTERISK = 42;
	var CHAR_COMMA = 44;
	var CHAR_MINUS = 45;
	var CHAR_COLON = 58;
	var CHAR_EQUALS = 61;
	var CHAR_GREATER_THAN = 62;
	var CHAR_QUESTION = 63;
	var CHAR_COMMERCIAL_AT = 64;
	var CHAR_LEFT_SQUARE_BRACKET = 91;
	var CHAR_RIGHT_SQUARE_BRACKET = 93;
	var CHAR_GRAVE_ACCENT = 96;
	var CHAR_LEFT_CURLY_BRACKET = 123;
	var CHAR_VERTICAL_LINE = 124;
	var CHAR_RIGHT_CURLY_BRACKET = 125;
	var ESCAPE_SEQUENCES = {};
	ESCAPE_SEQUENCES[0] = "\\0";
	ESCAPE_SEQUENCES[7] = "\\a";
	ESCAPE_SEQUENCES[8] = "\\b";
	ESCAPE_SEQUENCES[9] = "\\t";
	ESCAPE_SEQUENCES[10] = "\\n";
	ESCAPE_SEQUENCES[11] = "\\v";
	ESCAPE_SEQUENCES[12] = "\\f";
	ESCAPE_SEQUENCES[13] = "\\r";
	ESCAPE_SEQUENCES[27] = "\\e";
	ESCAPE_SEQUENCES[34] = "\\\"";
	ESCAPE_SEQUENCES[92] = "\\\\";
	ESCAPE_SEQUENCES[133] = "\\N";
	ESCAPE_SEQUENCES[160] = "\\_";
	ESCAPE_SEQUENCES[8232] = "\\L";
	ESCAPE_SEQUENCES[8233] = "\\P";
	var DEPRECATED_BOOLEANS_SYNTAX = [
		"y",
		"Y",
		"yes",
		"Yes",
		"YES",
		"on",
		"On",
		"ON",
		"n",
		"N",
		"no",
		"No",
		"NO",
		"off",
		"Off",
		"OFF"
	];
	function compileStyleMap(schema, map) {
		var result;
		var keys;
		var index;
		var length;
		var tag;
		var style;
		var type;
		if (map === null) return {};
		result = {};
		keys = Object.keys(map);
		for (index = 0, length = keys.length; index < length; index += 1) {
			tag = keys[index];
			style = String(map[tag]);
			if (tag.slice(0, 2) === "!!") tag = "tag:yaml.org,2002:" + tag.slice(2);
			type = schema.compiledTypeMap["fallback"][tag];
			if (type && _hasOwnProperty.call(type.styleAliases, style)) style = type.styleAliases[style];
			result[tag] = style;
		}
		return result;
	}
	function encodeHex(character) {
		var string = character.toString(16).toUpperCase();
		var handle;
		var length;
		if (character <= 255) {
			handle = "x";
			length = 2;
		} else if (character <= 65535) {
			handle = "u";
			length = 4;
		} else if (character <= 4294967295) {
			handle = "U";
			length = 8;
		} else throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
		return "\\" + handle + common.repeat("0", length - string.length) + string;
	}
	function State(options) {
		this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
		this.indent = Math.max(1, options["indent"] || 2);
		this.noArrayIndent = options["noArrayIndent"] || false;
		this.skipInvalid = options["skipInvalid"] || false;
		this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
		this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
		this.sortKeys = options["sortKeys"] || false;
		this.lineWidth = options["lineWidth"] || 80;
		this.noRefs = options["noRefs"] || false;
		this.noCompatMode = options["noCompatMode"] || false;
		this.condenseFlow = options["condenseFlow"] || false;
		this.implicitTypes = this.schema.compiledImplicit;
		this.explicitTypes = this.schema.compiledExplicit;
		this.comments = options["comments"] || {};
		this.tag = null;
		this.result = "";
		this.duplicates = [];
		this.usedDuplicates = null;
	}
	function indentString(string, spaces) {
		var ind = common.repeat(" ", spaces);
		var position = 0;
		var next = -1;
		var result = "";
		var line;
		var length = string.length;
		while (position < length) {
			next = string.indexOf("\n", position);
			if (next === -1) {
				line = string.slice(position);
				position = length;
			} else {
				line = string.slice(position, next + 1);
				position = next + 1;
			}
			if (line.length && line !== "\n") result += ind;
			result += line;
		}
		return result;
	}
	function generateNextLine(state, level) {
		return "\n" + common.repeat(" ", state.indent * level);
	}
	function testImplicitResolving(state, str) {
		var index;
		var length;
		var type;
		for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
			type = state.implicitTypes[index];
			if (type.resolve(str)) return true;
		}
		return false;
	}
	function isWhitespace(c) {
		return c === CHAR_SPACE || c === CHAR_TAB;
	}
	function isPrintable(c) {
		return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
	}
	function isNsChar(c) {
		return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
	}
	function isPlainSafe(c, prev) {
		return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
	}
	function isPlainSafeFirst(c) {
		return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
	}
	function needIndentIndicator(string) {
		return /^\n* /.test(string);
	}
	var STYLE_PLAIN = 1;
	var STYLE_SINGLE = 2;
	var STYLE_LITERAL = 3;
	var STYLE_FOLDED = 4;
	var STYLE_DOUBLE = 5;
	function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
		var i;
		var char;
		var prev_char;
		var hasLineBreak = false;
		var hasFoldableLine = false;
		var shouldTrackWidth = lineWidth !== -1;
		var previousLineBreak = -1;
		var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
		if (singleLineOnly) for (i = 0; i < string.length; i++) {
			char = string.charCodeAt(i);
			if (!isPrintable(char)) return STYLE_DOUBLE;
			prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
			plain = plain && isPlainSafe(char, prev_char);
		}
		else {
			for (i = 0; i < string.length; i++) {
				char = string.charCodeAt(i);
				if (char === CHAR_LINE_FEED) {
					hasLineBreak = true;
					if (shouldTrackWidth) {
						hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
						previousLineBreak = i;
					}
				} else if (!isPrintable(char)) return STYLE_DOUBLE;
				prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
				plain = plain && isPlainSafe(char, prev_char);
			}
			hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
		}
		if (!hasLineBreak && !hasFoldableLine) return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
		if (indentPerLevel > 9 && needIndentIndicator(string)) return STYLE_DOUBLE;
		return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	}
	function writeScalar(state, string, level, iskey, pointer) {
		var _result = function() {
			if (string.length === 0) return "''";
			if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) return "'" + string + "'";
			var indent = state.indent * Math.max(1, level);
			var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
			var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
			function testAmbiguity(string$1) {
				return testImplicitResolving(state, string$1);
			}
			switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
				case STYLE_PLAIN: return string;
				case STYLE_SINGLE: return "'" + string.replace(/'/g, "''") + "'";
				case STYLE_LITERAL: return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
				case STYLE_FOLDED: return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
				case STYLE_DOUBLE: return "\"" + escapeString(string) + "\"";
				default: throw new YAMLException("impossible error: invalid scalar style");
			}
		}();
		if (!iskey) {
			let comment = new Comments(state, pointer).write(level, "before-eol");
			if (comment !== "") _result += " " + comment;
		}
		state.dump = _result;
	}
	function blockHeader(string, indentPerLevel) {
		var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
		var clip = string[string.length - 1] === "\n";
		return indentIndicator + (clip && (string[string.length - 2] === "\n" || string === "\n") ? "+" : clip ? "" : "-") + "\n";
	}
	function dropEndingNewline(string) {
		return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
	}
	function foldString(string, width) {
		var lineRe = /(\n+)([^\n]*)/g;
		var result = function() {
			var nextLF = string.indexOf("\n");
			nextLF = nextLF !== -1 ? nextLF : string.length;
			lineRe.lastIndex = nextLF;
			return foldLine(string.slice(0, nextLF), width);
		}();
		var prevMoreIndented = string[0] === "\n" || string[0] === " ";
		var moreIndented;
		var match;
		while (match = lineRe.exec(string)) {
			var prefix = match[1];
			var line = match[2];
			moreIndented = line[0] === " ";
			result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
			prevMoreIndented = moreIndented;
		}
		return result;
	}
	function foldLine(line, width) {
		if (line === "" || line[0] === " ") return line;
		var breakRe = / [^ ]/g;
		var match;
		var start = 0;
		var end;
		var curr = 0;
		var next = 0;
		var result = "";
		while (match = breakRe.exec(line)) {
			next = match.index;
			if (next - start > width) {
				end = curr > start ? curr : next;
				result += "\n" + line.slice(start, end);
				start = end + 1;
			}
			curr = next;
		}
		result += "\n";
		if (line.length - start > width && curr > start) result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
		else result += line.slice(start);
		return result.slice(1);
	}
	function escapeString(string) {
		var result = "";
		var char;
		var nextChar;
		var escapeSeq;
		for (var i = 0; i < string.length; i++) {
			char = string.charCodeAt(i);
			if (char >= 55296 && char <= 56319) {
				nextChar = string.charCodeAt(i + 1);
				if (nextChar >= 56320 && nextChar <= 57343) {
					result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
					i++;
					continue;
				}
			}
			escapeSeq = ESCAPE_SEQUENCES[char];
			result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
		}
		return result;
	}
	function writeFlowSequence(state, level, object, pointer) {
		var _result = "";
		var _tag = state.tag;
		var index;
		var length;
		for (index = 0, length = object.length; index < length; index += 1) if (writeNode(state, level, object[index], false, false, false, pointer)) {
			if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
			_result += state.dump;
		}
		state.tag = _tag;
		state.dump = "[" + _result + "]";
	}
	function writeBlockSequence(state, level, object, compact, pointer) {
		var _result = "";
		var _tag = state.tag;
		var index;
		var length;
		var comments = new Comments(state, pointer);
		_result += comments.write(level, "before-eol");
		_result += comments.write(level, "leading");
		for (index = 0, length = object.length; index < length; index += 1) {
			_result += comments.writeAt(String(index), level, "before");
			if (writeNode(state, level + 1, object[index], true, true, false, `${pointer}/${index}`)) {
				if (!compact || index !== 0) _result += generateNextLine(state, level);
				if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) _result += "-";
				else _result += "- ";
				_result += state.dump;
			}
			_result += comments.writeAt(String(index), level, "after");
		}
		state.tag = _tag;
		state.dump = _result || "[]";
		state.dump += comments.write(level, "trailing");
	}
	function writeFlowMapping(state, level, object, pointer) {
		var _result = "";
		var _tag = state.tag;
		var objectKeyList = Object.keys(object);
		var index;
		var length;
		var objectKey;
		var objectValue;
		var pairBuffer;
		for (index = 0, length = objectKeyList.length; index < length; index += 1) {
			pairBuffer = "";
			if (index !== 0) pairBuffer += ", ";
			if (state.condenseFlow) pairBuffer += "\"";
			objectKey = objectKeyList[index];
			objectValue = object[objectKey];
			if (!writeNode(state, level, objectKey, false, false, false, pointer)) continue;
			if (state.dump.length > 1024) pairBuffer += "? ";
			pairBuffer += state.dump + (state.condenseFlow ? "\"" : "") + ":" + (state.condenseFlow ? "" : " ");
			if (!writeNode(state, level, objectValue, false, false, false, pointer)) continue;
			pairBuffer += state.dump;
			_result += pairBuffer;
		}
		state.tag = _tag;
		state.dump = "{" + _result + "}";
	}
	function writeBlockMapping(state, level, object, compact, pointer) {
		var _result = "";
		var _tag = state.tag;
		var objectKeyList = Object.keys(object);
		var index;
		var length;
		var objectKey;
		var objectValue;
		var explicitPair;
		var pairBuffer;
		if (state.sortKeys === true) objectKeyList.sort();
		else if (typeof state.sortKeys === "function") objectKeyList.sort(state.sortKeys);
		else if (state.sortKeys) throw new YAMLException("sortKeys must be a boolean or a function");
		var comments = new Comments(state, pointer);
		_result += comments.write(level, "before-eol");
		_result += comments.write(level, "leading");
		for (index = 0, length = objectKeyList.length; index < length; index += 1) {
			pairBuffer = "";
			if (!compact || index !== 0) pairBuffer += generateNextLine(state, level);
			objectKey = objectKeyList[index];
			objectValue = object[objectKey];
			_result += comments.writeAt(objectKey, level, "before");
			if (!writeNode(state, level + 1, objectKey, true, true, true, pointer)) continue;
			explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
			if (explicitPair) if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += "?";
			else pairBuffer += "? ";
			pairBuffer += state.dump;
			if (explicitPair) pairBuffer += generateNextLine(state, level);
			if (!writeNode(state, level + 1, objectValue, true, explicitPair, false, `${pointer}/${encodeSegment(objectKey)}`)) continue;
			if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += ":";
			else pairBuffer += ": ";
			pairBuffer += state.dump;
			_result += pairBuffer;
			_result += comments.writeAt(level, objectKey, "after");
		}
		state.tag = _tag;
		state.dump = _result || "{}";
		state.dump += comments.write(level, "trailing");
	}
	function detectType(state, object, explicit) {
		var _result;
		var typeList = explicit ? state.explicitTypes : state.implicitTypes;
		var index;
		var length;
		var type;
		var style;
		for (index = 0, length = typeList.length; index < length; index += 1) {
			type = typeList[index];
			if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
				state.tag = explicit ? type.tag : "?";
				if (type.represent) {
					style = state.styleMap[type.tag] || type.defaultStyle;
					if (_toString.call(type.represent) === "[object Function]") _result = type.represent(object, style);
					else if (_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
					else throw new YAMLException("!<" + type.tag + "> tag resolver accepts not \"" + style + "\" style");
					state.dump = _result;
				}
				return true;
			}
		}
		return false;
	}
	function writeNode(state, level, object, block, compact, iskey, pointer) {
		state.tag = null;
		state.dump = object;
		if (!detectType(state, object, false)) detectType(state, object, true);
		var type = _toString.call(state.dump);
		if (block) block = state.flowLevel < 0 || state.flowLevel > level;
		if (state.tag !== null && state.tag !== "?" || state.indent !== 2 && level > 0) compact = false;
		var objectOrArray = type === "[object Object]" || type === "[object Array]";
		var duplicateIndex;
		var duplicate;
		if (objectOrArray) {
			duplicateIndex = state.duplicates.indexOf(object);
			duplicate = duplicateIndex !== -1;
		}
		if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) compact = false;
		if (duplicate && state.usedDuplicates[duplicateIndex]) state.dump = "*ref_" + duplicateIndex;
		else {
			if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) state.usedDuplicates[duplicateIndex] = true;
			if (type === "[object Object]") if (block && Object.keys(state.dump).length !== 0) {
				writeBlockMapping(state, level, state.dump, compact, pointer);
				if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
			} else {
				writeFlowMapping(state, level, state.dump, pointer);
				if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
			}
			else if (type === "[object Array]") {
				var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
				if (block && state.dump.length !== 0) {
					writeBlockSequence(state, arrayLevel, state.dump, compact, pointer);
					if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
				} else {
					writeFlowSequence(state, arrayLevel, state.dump, pointer);
					if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
				}
			} else if (type === "[object String]") {
				if (state.tag !== "?") writeScalar(state, state.dump, level, iskey, pointer);
			} else {
				if (state.skipInvalid) return false;
				throw new YAMLException("unacceptable kind of an object to dump " + type);
			}
			if (state.tag !== null && state.tag !== "?") state.dump = "!<" + state.tag + "> " + state.dump;
		}
		return true;
	}
	function getDuplicateReferences(object, state) {
		var objects = [];
		var duplicatesIndexes = [];
		var index;
		var length;
		inspectNode(object, objects, duplicatesIndexes);
		for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) state.duplicates.push(objects[duplicatesIndexes[index]]);
		state.usedDuplicates = new Array(length);
	}
	function inspectNode(object, objects, duplicatesIndexes) {
		var objectKeyList;
		var index;
		var length;
		if (object !== null && typeof object === "object") {
			index = objects.indexOf(object);
			if (index !== -1) {
				if (duplicatesIndexes.indexOf(index) === -1) duplicatesIndexes.push(index);
			} else {
				objects.push(object);
				if (Array.isArray(object)) for (index = 0, length = object.length; index < length; index += 1) inspectNode(object[index], objects, duplicatesIndexes);
				else {
					objectKeyList = Object.keys(object);
					for (index = 0, length = objectKeyList.length; index < length; index += 1) inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
				}
			}
		}
	}
	function dump(input, options) {
		options = options || {};
		var state = new State(options);
		if (!options.noRefs) getDuplicateReferences(input, state);
		if (writeNode(state, 0, input, true, true, false, "#")) return state.dump + "\n";
		return "";
	}
	exports.dump = dump;
	function safeDump(input, options) {
		return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeDump = safeDump;
	const TILDE_REGEXP = /~/g;
	const SLASH_REGEXP = /\//g;
	function encodeSegment(input) {
		return input.replace(TILDE_REGEXP, "~0").replace(SLASH_REGEXP, "~1");
	}
	function Comments(state, pointer) {
		this.state = state;
		this.comments = {
			"before-eol": /* @__PURE__ */ new Set(),
			leading: /* @__PURE__ */ new Set(),
			trailing: /* @__PURE__ */ new Set(),
			before: /* @__PURE__ */ new Map(),
			after: /* @__PURE__ */ new Map()
		};
		this.written = /* @__PURE__ */ new WeakSet();
		if (state.comments !== null && pointer in state.comments) for (let comment of state.comments[pointer]) switch (comment.placement) {
			case "before-eol":
			case "leading":
			case "trailing":
				this.comments[comment.placement].add(comment);
				break;
			case "between":
				let before = this.comments.before.get(comment.between[1]);
				if (!before) this.comments.before.set(comment.between[1], new Set([comment]));
				else before.add(comment);
				let after = this.comments.after.get(comment.between[0]);
				if (!after) this.comments.after.set(comment.between[0], new Set([comment]));
				else after.add(comment);
				break;
		}
	}
	Comments.prototype.write = function(level, placement) {
		let result = "";
		for (let comment of this.comments[placement]) result += this._write(comment, level);
		return result;
	};
	Comments.prototype.writeAt = function(key, level, placement) {
		let result = "";
		let comments = this.comments[placement].get(key);
		if (comments) for (let comment of comments) result += this._write(comment, level);
		return result;
	};
	Comments.prototype._write = function(comment, level) {
		if (this.written.has(comment)) return "";
		this.written.add(comment);
		let result = "#" + comment.value;
		if (comment.placement === "before-eol") return result;
		else if (level === 0 && comment.placement === "leading") return result + "\n";
		else return generateNextLine(this.state, level) + result;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/scalarInference.js
var require_scalarInference = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function parseYamlBoolean(input) {
		if ([
			"true",
			"True",
			"TRUE"
		].lastIndexOf(input) >= 0) return true;
		else if ([
			"false",
			"False",
			"FALSE"
		].lastIndexOf(input) >= 0) return false;
		throw `Invalid boolean "${input}"`;
	}
	exports.parseYamlBoolean = parseYamlBoolean;
	function safeParseYamlInteger(input) {
		if (input.lastIndexOf("0o", 0) === 0) return parseInt(input.substring(2), 8);
		return parseInt(input);
	}
	function parseYamlInteger(input) {
		const result = safeParseYamlInteger(input);
		if (Number.isNaN(result)) throw `Invalid integer "${input}"`;
		return result;
	}
	exports.parseYamlInteger = parseYamlInteger;
	function parseYamlBigInteger(input) {
		const result = parseYamlInteger(input);
		if (result > Number.MAX_SAFE_INTEGER && input.lastIndexOf("0o", 0) === -1) return BigInt(input);
		return result;
	}
	exports.parseYamlBigInteger = parseYamlBigInteger;
	function parseYamlFloat(input) {
		if ([
			".nan",
			".NaN",
			".NAN"
		].lastIndexOf(input) >= 0) return NaN;
		const match = /^([-+])?(?:\.inf|\.Inf|\.INF)$/.exec(input);
		if (match) return match[1] === "-" ? -Infinity : Infinity;
		const result = parseFloat(input);
		if (!isNaN(result)) return result;
		throw `Invalid float "${input}"`;
	}
	exports.parseYamlFloat = parseYamlFloat;
	var ScalarType;
	(function(ScalarType) {
		ScalarType[ScalarType["null"] = 0] = "null";
		ScalarType[ScalarType["bool"] = 1] = "bool";
		ScalarType[ScalarType["int"] = 2] = "int";
		ScalarType[ScalarType["float"] = 3] = "float";
		ScalarType[ScalarType["string"] = 4] = "string";
	})(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
	function determineScalarType(node) {
		if (node === void 0) return ScalarType.null;
		if (node.doubleQuoted || !node.plainScalar || node["singleQuoted"]) return ScalarType.string;
		const value = node.value;
		if ([
			"null",
			"Null",
			"NULL",
			"~",
			""
		].indexOf(value) >= 0) return ScalarType.null;
		if (value === null || value === void 0) return ScalarType.null;
		if ([
			"true",
			"True",
			"TRUE",
			"false",
			"False",
			"FALSE"
		].indexOf(value) >= 0) return ScalarType.bool;
		if (/^[-+]?[0-9]+$/.test(value) || /^0o[0-7]+$/.test(value) || /^0x[0-9a-fA-F]+$/.test(value)) return ScalarType.int;
		if (/^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$/.test(value) || /^[-+]?(\.inf|\.Inf|\.INF)$/.test(value) || [
			".nan",
			".NaN",
			".NAN"
		].indexOf(value) >= 0) return ScalarType.float;
		return ScalarType.string;
	}
	exports.determineScalarType = determineScalarType;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml-ast-parser@0.0.50/node_modules/@stoplight/yaml-ast-parser/dist/src/index.js
var require_src$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	function __export(m) {
		for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	var loader_1 = require_loader();
	exports.load = loader_1.load;
	exports.loadAll = loader_1.loadAll;
	exports.safeLoad = loader_1.safeLoad;
	exports.safeLoadAll = loader_1.safeLoadAll;
	var dumper_1 = require_dumper();
	exports.dump = dumper_1.dump;
	exports.safeDump = dumper_1.safeDump;
	exports.YAMLException = require_exception();
	__export(require_yamlAST());
	__export(require_scalarInference());
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/types.js
var require_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const yaml_ast_parser_1 = require_src$1();
	exports.Kind = yaml_ast_parser_1.Kind;
	exports.ScalarType = yaml_ast_parser_1.ScalarType;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isObject = (sth) => sth !== null && typeof sth === "object";
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/buildJsonPath.js
var require_buildJsonPath = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const types_1 = require_types();
	const utils_1 = require_utils();
	function buildJsonPath(node) {
		const path$1 = [];
		let prevNode = node;
		while (node) {
			switch (node.kind) {
				case types_1.Kind.SCALAR:
					path$1.unshift(node.value);
					break;
				case types_1.Kind.MAPPING:
					if (prevNode !== node.key) if (path$1.length > 0 && utils_1.isObject(node.value) && node.value.value === path$1[0]) path$1[0] = node.key.value;
					else path$1.unshift(node.key.value);
					break;
				case types_1.Kind.SEQ:
					if (prevNode) {
						const index = node.items.indexOf(prevNode);
						if (prevNode.kind === types_1.Kind.SCALAR) path$1[0] = index;
						else if (index !== -1) path$1.unshift(index);
					}
					break;
			}
			prevNode = node;
			node = node.parent;
		}
		return path$1;
	}
	exports.buildJsonPath = buildJsonPath;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/dereferenceAnchor.js
var require_dereferenceAnchor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const types_1 = require_types();
	const utils_1 = require_utils();
	exports.dereferenceAnchor = (node, anchorId) => {
		if (!utils_1.isObject(node)) return node;
		if (node.kind === types_1.Kind.ANCHOR_REF && node.referencesAnchor === anchorId) return null;
		switch (node.kind) {
			case types_1.Kind.MAP: return Object.assign({}, node, { mappings: node.mappings.map((mapping) => exports.dereferenceAnchor(mapping, anchorId)) });
			case types_1.Kind.SEQ: return Object.assign({}, node, { items: node.items.map((item) => exports.dereferenceAnchor(item, anchorId)) });
			case types_1.Kind.MAPPING: return Object.assign({}, node, { value: exports.dereferenceAnchor(node.value, anchorId) });
			case types_1.Kind.SCALAR: return node;
			case types_1.Kind.ANCHOR_REF:
				if (utils_1.isObject(node.value) && isSelfReferencingAnchorRef(node)) return null;
				return node;
			default: return node;
		}
	};
	const isSelfReferencingAnchorRef = (anchorRef) => {
		const { referencesAnchor } = anchorRef;
		let node = anchorRef;
		while (node = node.parent) if ("anchorId" in node && node.anchorId === referencesAnchor) return true;
		return false;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/getJsonPathForPosition.js
var require_getJsonPathForPosition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const buildJsonPath_1 = require_buildJsonPath();
	const types_1 = require_types();
	const utils_1 = require_utils();
	exports.getJsonPathForPosition = ({ ast, lineMap }, { line, character }) => {
		if (line >= lineMap.length || character >= lineMap[line]) return;
		const startOffset = line === 0 ? 0 : lineMap[line - 1] + 1;
		const node = findClosestScalar(ast, Math.min(lineMap[line] - 1, startOffset + character), line, lineMap);
		if (!utils_1.isObject(node)) return;
		const path$1 = buildJsonPath_1.buildJsonPath(node);
		if (path$1.length === 0) return;
		return path$1;
	};
	function* walk(node) {
		switch (node.kind) {
			case types_1.Kind.MAP:
				if (node.mappings.length !== 0) {
					for (const mapping of node.mappings) if (utils_1.isObject(mapping)) yield mapping;
				}
				break;
			case types_1.Kind.MAPPING:
				if (utils_1.isObject(node.key)) yield node.key;
				if (utils_1.isObject(node.value)) yield node.value;
				break;
			case types_1.Kind.SEQ:
				if (node.items.length !== 0) {
					for (const item of node.items) if (utils_1.isObject(item)) yield item;
				}
				break;
			case types_1.Kind.SCALAR:
				yield node;
				break;
		}
	}
	function getFirstScalarChild(node, line, lineMap) {
		const startOffset = lineMap[line - 1] + 1;
		const endOffset = lineMap[line];
		switch (node.kind) {
			case types_1.Kind.MAPPING: return node.key;
			case types_1.Kind.MAP:
				if (node.mappings.length !== 0) {
					for (const mapping of node.mappings) if (mapping.startPosition > startOffset && mapping.startPosition <= endOffset) return getFirstScalarChild(mapping, line, lineMap);
				}
				break;
			case types_1.Kind.SEQ:
				if (node.items.length !== 0) {
					for (const item of node.items) if (item !== null && item.startPosition > startOffset && item.startPosition <= endOffset) return getFirstScalarChild(item, line, lineMap);
				}
				break;
		}
		return node;
	}
	function findClosestScalar(container, offset, line, lineMap) {
		for (const node of walk(container)) if (node.startPosition <= offset && offset <= node.endPosition) return node.kind === types_1.Kind.SCALAR ? node : findClosestScalar(node, offset, line, lineMap);
		if (lineMap[line - 1] === lineMap[line] - 1) return container;
		if (container.startPosition < lineMap[line - 1] && offset <= container.endPosition) {
			if (container.kind !== types_1.Kind.MAPPING) return getFirstScalarChild(container, line, lineMap);
			if (container.value && container.key.endPosition < offset) return getFirstScalarChild(container.value, line, lineMap);
		}
		return container;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/lineForPosition.js
var require_lineForPosition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.lineForPosition = (pos, lines, start = 0, end) => {
		if (pos === 0 || lines.length === 0 || pos < lines[0]) return 0;
		if (typeof end === "undefined") end = lines.length;
		const target = Math.floor((end - start) / 2) + start;
		if (pos >= lines[target] && !lines[target + 1]) return target + 1;
		const nextLinePos = lines[Math.min(target + 1, lines.length)];
		if (pos === lines[target] - 1) return target;
		if (pos >= lines[target] && pos <= nextLinePos) {
			if (pos === nextLinePos) return target + 2;
			return target + 1;
		}
		if (pos > lines[target]) return exports.lineForPosition(pos, lines, target + 1, end);
		else return exports.lineForPosition(pos, lines, start, target - 1);
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/getLocationForJsonPath.js
var require_getLocationForJsonPath = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const lineForPosition_1 = require_lineForPosition();
	const types_1 = require_types();
	const utils_1 = require_utils();
	exports.getLocationForJsonPath = ({ ast, lineMap, metadata }, path$1, closest = false) => {
		const node = findNodeAtPath(ast, path$1, {
			closest,
			mergeKeys: metadata !== void 0 && metadata.mergeKeys === true
		});
		if (node === void 0) return;
		return getLoc(lineMap, {
			start: getStartPosition(node, lineMap.length > 0 ? lineMap[0] : 0),
			end: getEndPosition(node)
		});
	};
	function getStartPosition(node, offset) {
		if (node.parent && node.parent.kind === types_1.Kind.MAPPING) {
			if (node.parent.value === null) return node.parent.endPosition;
			if (node.kind !== types_1.Kind.SCALAR) return node.parent.key.endPosition + 1;
		}
		if (node.parent === null && offset - node.startPosition === 0) return 0;
		return node.startPosition;
	}
	function getEndPosition(node) {
		switch (node.kind) {
			case types_1.Kind.SEQ:
				const { items } = node;
				if (items.length !== 0) {
					const lastItem = items[items.length - 1];
					if (lastItem !== null) return getEndPosition(lastItem);
				}
				break;
			case types_1.Kind.MAPPING:
				if (node.value !== null) return getEndPosition(node.value);
				break;
			case types_1.Kind.MAP:
				if (node.value !== null && node.mappings.length !== 0) return getEndPosition(node.mappings[node.mappings.length - 1]);
				break;
			case types_1.Kind.SCALAR:
				if (node.parent !== null && node.parent.kind === types_1.Kind.MAPPING && node.parent.value === null) return node.parent.endPosition;
				break;
		}
		return node.endPosition;
	}
	function findNodeAtPath(node, path$1, { closest, mergeKeys }) {
		pathLoop: for (const segment of path$1) {
			if (!utils_1.isObject(node)) return closest ? node : void 0;
			switch (node.kind) {
				case types_1.Kind.MAP:
					const mappings = getMappings(node.mappings, mergeKeys);
					for (let i = mappings.length - 1; i >= 0; i--) {
						const item = mappings[i];
						if (item.key.value === segment) {
							if (item.value === null) node = item.key;
							else node = item.value;
							continue pathLoop;
						}
					}
					return closest ? node : void 0;
				case types_1.Kind.SEQ:
					for (let i = 0; i < node.items.length; i++) if (i === Number(segment)) {
						const item = node.items[i];
						if (item === null) break;
						node = item;
						continue pathLoop;
					}
					return closest ? node : void 0;
				default: return closest ? node : void 0;
			}
		}
		return node;
	}
	function getMappings(mappings, mergeKeys) {
		if (!mergeKeys) return mappings;
		return mappings.reduce((mergedMappings, mapping) => {
			if (utils_1.isObject(mapping)) if (mapping.key.value === "<<") mergedMappings.push(...reduceMergeKeys(mapping.value));
			else mergedMappings.push(mapping);
			return mergedMappings;
		}, []);
	}
	function reduceMergeKeys(node) {
		if (!utils_1.isObject(node)) return [];
		switch (node.kind) {
			case types_1.Kind.SEQ: return node.items.reduceRight((items, item) => {
				items.push(...reduceMergeKeys(item));
				return items;
			}, []);
			case types_1.Kind.MAP: return node.mappings;
			case types_1.Kind.ANCHOR_REF: return reduceMergeKeys(node.value);
			default: return [];
		}
	}
	const getLoc = (lineMap, { start = 0, end = 0 }) => {
		const startLine = lineForPosition_1.lineForPosition(start, lineMap);
		const endLine = lineForPosition_1.lineForPosition(end, lineMap);
		return { range: {
			start: {
				line: startLine,
				character: start - (startLine === 0 ? 0 : lineMap[startLine - 1])
			},
			end: {
				line: endLine,
				character: end - (endLine === 0 ? 0 : lineMap[endLine - 1])
			}
		} };
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+ordered-object-literal@1.0.5/node_modules/@stoplight/ordered-object-literal/src/index.cjs
var require_src = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ORDER_KEY_ID = `__object_order_${Math.floor(Date.now() / 36e5)}__`;
	const ORDER_KEY = Symbol.for(ORDER_KEY_ID);
	const STRINGIFIED_ORDER_KEY = String(ORDER_KEY);
	const traps = {
		defineProperty(target, key, descriptor) {
			if (!Object.prototype.hasOwnProperty.call(target, key) && ORDER_KEY in target) target[ORDER_KEY].push(key);
			else if ("value" in descriptor && key === ORDER_KEY && descriptor.value.lastIndexOf(ORDER_KEY) === -1) descriptor.value.push(ORDER_KEY);
			return Reflect.defineProperty(target, key, descriptor);
		},
		deleteProperty(target, key) {
			const hasKey = Object.prototype.hasOwnProperty.call(target, key);
			const deleted = Reflect.deleteProperty(target, key);
			if (deleted && hasKey && ORDER_KEY in target) {
				const index = target[ORDER_KEY].indexOf(key);
				if (index !== -1) target[ORDER_KEY].splice(index, 1);
			}
			return deleted;
		},
		ownKeys(target) {
			if (ORDER_KEY in target) return target[ORDER_KEY];
			return Reflect.ownKeys(target);
		},
		set(target, key, value) {
			const hasKey = Object.prototype.hasOwnProperty.call(target, key);
			const set = Reflect.set(target, key, value);
			if (set && !hasKey && ORDER_KEY in target) target[ORDER_KEY].push(key);
			return set;
		}
	};
	function createObj(target, order = Reflect.ownKeys(target)) {
		assertObjectLiteral(target);
		const t = new Proxy(target, traps);
		setOrder(t, order);
		return t;
	}
	function setOrder(target, order) {
		if (ORDER_KEY in target) {
			target[ORDER_KEY].length = 0;
			target[ORDER_KEY].push(...order);
			return true;
		} else return Reflect.defineProperty(target, ORDER_KEY, {
			configurable: true,
			value: order
		});
	}
	function getOrder(target) {
		return target[ORDER_KEY];
	}
	function serializeArray(target) {
		const newTarget = target.slice();
		for (let i = 0; i < newTarget.length; i += 1) {
			const value = newTarget[i];
			if (isObject(value)) newTarget[i] = Array.isArray(value) ? serializeArray(value) : serialize(value, true);
		}
		return newTarget;
	}
	function serialize(target, deep) {
		assertObjectLiteral(target, "Invalid target provided");
		const newTarget = { ...target };
		if (ORDER_KEY in target) Object.defineProperty(newTarget, STRINGIFIED_ORDER_KEY, {
			enumerable: true,
			value: target[ORDER_KEY].filter((item) => item !== ORDER_KEY)
		});
		if (deep) for (const key of Object.keys(target)) {
			if (key === STRINGIFIED_ORDER_KEY) continue;
			const value = target[key];
			if (isObject(value)) newTarget[key] = Array.isArray(value) ? serializeArray(value) : serialize(value, true);
		}
		return newTarget;
	}
	function deserializeArray(target) {
		for (let i = 0; i < target.length; i += 1) {
			const value = target[i];
			if (isObject(value)) target[i] = Array.isArray(value) ? deserializeArray(value) : deserialize(value, true);
		}
		return target;
	}
	function deserialize(target, deep) {
		assertObjectLiteral(target, "Invalid target provided");
		const newTarget = createObj(target, STRINGIFIED_ORDER_KEY in target ? target[STRINGIFIED_ORDER_KEY] : Reflect.ownKeys(target));
		delete newTarget[STRINGIFIED_ORDER_KEY];
		if (deep) for (const key of Object.keys(target)) {
			const value = target[key];
			if (isObject(value)) target[key] = Array.isArray(value) ? deserializeArray(value) : deserialize(value, true);
		}
		return newTarget;
	}
	function isOrderedObject(target) {
		return ORDER_KEY in target;
	}
	function isObject(maybeObj) {
		return maybeObj !== null && typeof maybeObj === "object";
	}
	function isObjectLiteral(obj) {
		if (!isObject(obj)) return false;
		if (obj[Symbol.toStringTag] !== void 0) {
			const proto = Object.getPrototypeOf(obj);
			return proto === null || proto === Object.prototype;
		}
		return toStringTag(obj) === "Object";
	}
	function toStringTag(obj) {
		const tag = obj[Symbol.toStringTag];
		if (typeof tag === "string") return tag;
		const name = Reflect.apply(Object.prototype.toString, obj, []);
		return name.slice(8, name.length - 1);
	}
	function assertObjectLiteral(maybeObj, message) {
		if (isDevEnv() && !isObjectLiteral(maybeObj)) throw new TypeError(message);
	}
	function isDevEnv() {
		if (typeof process === "undefined" || !isObject(process) || !isObject(process.env)) return false;
		return process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
	}
	exports.ORDER_KEY_ID = ORDER_KEY_ID;
	exports.default = createObj;
	exports.deserialize = deserialize;
	exports.getOrder = getOrder;
	exports.isOrderedObject = isOrderedObject;
	exports.serialize = serialize;
	exports.setOrder = setOrder;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+types@14.1.1/node_modules/@stoplight/types/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpOperationSecurityDeclarationTypes = void 0;
	(function(HttpOperationSecurityDeclarationTypes) {
		/** Indicates that the operation has no security declarations. */
		HttpOperationSecurityDeclarationTypes["None"] = "none";
		/** Indicates that the operation has explicit security declarations. */
		HttpOperationSecurityDeclarationTypes["Declared"] = "declared";
		/** Indicates that the operation inherits its security declarations from the service. */
		HttpOperationSecurityDeclarationTypes["InheritedFromService"] = "inheritedFromService";
	})(exports.HttpOperationSecurityDeclarationTypes || (exports.HttpOperationSecurityDeclarationTypes = {}));
	exports.HttpParamStyles = void 0;
	(function(HttpParamStyles) {
		/** Used when OAS2 type !== array */
		HttpParamStyles["Unspecified"] = "unspecified";
		/**
		* OAS 3.x style simple
		* OAS 2 collectionFormat csv
		*/
		HttpParamStyles["Simple"] = "simple";
		/**
		* OAS 3.x style matrix
		* OAS 2 collectionFormat no support
		*/
		HttpParamStyles["Matrix"] = "matrix";
		/**
		* OAS 3.x style label
		* OAS 2 collectionFormat no support
		*/
		HttpParamStyles["Label"] = "label";
		/**
		* OAS 3.x style form
		* OAS 2 collectionFormat
		*   * csv, when explode === false
		*   * multi, when explode === true
		*/
		HttpParamStyles["Form"] = "form";
		/**
		* OAS 3.x no support
		* OAS 2 collectionFormat csv when explode === undefined
		*/
		HttpParamStyles["CommaDelimited"] = "commaDelimited";
		/**
		* OAS 3.x style spaceDelimited
		* OAS 2 collectionFormat ssv
		*/
		HttpParamStyles["SpaceDelimited"] = "spaceDelimited";
		/**
		* OAS 3.x style spaceDelimited
		* OAS 2 collectionFormat pipes
		*/
		HttpParamStyles["PipeDelimited"] = "pipeDelimited";
		/**
		* OAS 3.x style deepObject
		* OAS 2 collectionFormat no support
		*/
		HttpParamStyles["DeepObject"] = "deepObject";
		/**
		* OAS 3.x style no support
		* OAS 2 collectionFormat tsv
		*/
		HttpParamStyles["TabDelimited"] = "tabDelimited";
	})(exports.HttpParamStyles || (exports.HttpParamStyles = {}));
	/**
	* Represents the severity of diagnostics.
	*/
	exports.DiagnosticSeverity = void 0;
	(function(DiagnosticSeverity) {
		/**
		* Something not allowed by the rules of a language or other means.
		*/
		DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
		/**
		* Something suspicious but allowed.
		*/
		DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
		/**
		* Something to inform about but not a problem.
		*/
		DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
		/**
		* Something to hint to a better way of doing it, like proposing
		* a refactoring.
		*/
		DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
	})(exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
	/**
	* Stoplight node types
	*/
	exports.NodeType = void 0;
	(function(NodeType) {
		NodeType["Article"] = "article";
		NodeType["HttpService"] = "http_service";
		NodeType["HttpServer"] = "http_server";
		NodeType["HttpOperation"] = "http_operation";
		NodeType["HttpCallback"] = "http_callback";
		NodeType["HttpWebhook"] = "http_webhook";
		NodeType["Model"] = "model";
		NodeType["Generic"] = "generic";
		NodeType["Unknown"] = "unknown";
		NodeType["TableOfContents"] = "table_of_contents";
		NodeType["SpectralRuleset"] = "spectral_ruleset";
		NodeType["Styleguide"] = "styleguide";
		NodeType["Image"] = "image";
		NodeType["StoplightResolutions"] = "stoplight_resolutions";
		NodeType["StoplightOverride"] = "stoplight_override";
	})(exports.NodeType || (exports.NodeType = {}));
	/**
	* Node data formats
	*/
	exports.NodeFormat = void 0;
	(function(NodeFormat) {
		NodeFormat["Json"] = "json";
		NodeFormat["Markdown"] = "markdown";
		NodeFormat["Yaml"] = "yaml";
		NodeFormat["Javascript"] = "javascript";
		NodeFormat["Apng"] = "apng";
		NodeFormat["Avif"] = "avif";
		NodeFormat["Bmp"] = "bmp";
		NodeFormat["Gif"] = "gif";
		NodeFormat["Jpeg"] = "jpeg";
		NodeFormat["Png"] = "png";
		NodeFormat["Svg"] = "svg";
		NodeFormat["Webp"] = "webp";
	})(exports.NodeFormat || (exports.NodeFormat = {}));
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/parseWithPointers.js
var require_parseWithPointers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ordered_object_literal_1 = require_src();
	const types_1 = require_dist();
	const yaml_ast_parser_1 = require_src$1();
	const buildJsonPath_1 = require_buildJsonPath();
	const dereferenceAnchor_1 = require_dereferenceAnchor();
	const lineForPosition_1 = require_lineForPosition();
	const types_2 = require_types();
	const utils_1 = require_utils();
	exports.parseWithPointers = (value, options) => {
		const lineMap = computeLineMap(value);
		const ast = yaml_ast_parser_1.load(value, Object.assign({}, options, { ignoreDuplicateKeys: true }));
		const parsed = {
			ast,
			lineMap,
			data: void 0,
			diagnostics: [],
			metadata: options,
			comments: {}
		};
		if (!ast) return parsed;
		const normalizedOptions = normalizeOptions(options);
		const comments = new Comments(parsed.comments, Comments.mapComments(normalizedOptions.attachComments && ast.comments ? ast.comments : [], lineMap), ast, lineMap, "#");
		parsed.data = walkAST({
			lineMap,
			diagnostics: parsed.diagnostics
		}, ast, comments, normalizedOptions);
		if (ast.errors) parsed.diagnostics.push(...transformErrors(ast.errors, lineMap));
		if (parsed.diagnostics.length > 0) parsed.diagnostics.sort((itemA, itemB) => itemA.range.start.line - itemB.range.start.line);
		if (Array.isArray(parsed.ast.errors)) parsed.ast.errors.length = 0;
		return parsed;
	};
	const TILDE_REGEXP = /~/g;
	const SLASH_REGEXP = /\//g;
	function encodeSegment(input) {
		return input.replace(TILDE_REGEXP, "~0").replace(SLASH_REGEXP, "~1");
	}
	const walkAST = (ctx, node, comments, options) => {
		if (node) switch (node.kind) {
			case types_2.Kind.MAP: {
				const mapComments = comments.enter(node);
				const { lineMap, diagnostics } = ctx;
				const { preserveKeyOrder, ignoreDuplicateKeys, json, mergeKeys } = options;
				const container = createMapContainer(preserveKeyOrder);
				const seenKeys = [];
				const handleMergeKeys = mergeKeys;
				const yamlMode = !json;
				const handleDuplicates = !ignoreDuplicateKeys;
				for (const mapping of node.mappings) {
					if (!validateMappingKey(mapping, lineMap, diagnostics, yamlMode)) continue;
					const key = String(getScalarValue(mapping.key));
					const mappingComments = mapComments.enter(mapping, encodeSegment(key));
					if ((yamlMode || handleDuplicates) && (!handleMergeKeys || key !== "<<")) if (seenKeys.includes(key)) {
						if (yamlMode) throw new Error("Duplicate YAML mapping key encountered");
						if (handleDuplicates) diagnostics.push(createYAMLException(mapping.key, lineMap, "duplicate key"));
					} else seenKeys.push(key);
					if (handleMergeKeys && key === "<<") {
						const reduced = reduceMergeKeys(walkAST(ctx, mapping.value, mappingComments, options), preserveKeyOrder);
						Object.assign(container, reduced);
					} else {
						container[key] = walkAST(ctx, mapping.value, mappingComments, options);
						if (preserveKeyOrder) pushKey(container, key);
					}
					mappingComments.attachComments();
				}
				mapComments.attachComments();
				return container;
			}
			case types_2.Kind.SEQ: {
				const nodeComments = comments.enter(node);
				const container = node.items.map((item, i) => {
					if (item !== null) {
						const sequenceItemComments = nodeComments.enter(item, i);
						const walked = walkAST(ctx, item, sequenceItemComments, options);
						sequenceItemComments.attachComments();
						return walked;
					} else return null;
				});
				nodeComments.attachComments();
				return container;
			}
			case types_2.Kind.SCALAR: {
				const value = getScalarValue(node);
				return !options.bigInt && typeof value === "bigint" ? Number(value) : value;
			}
			case types_2.Kind.ANCHOR_REF:
				if (utils_1.isObject(node.value)) node.value = dereferenceAnchor_1.dereferenceAnchor(node.value, node.referencesAnchor);
				return walkAST(ctx, node.value, comments, options);
			default: return null;
		}
		return node;
	};
	function getScalarValue(node) {
		switch (yaml_ast_parser_1.determineScalarType(node)) {
			case types_2.ScalarType.null: return null;
			case types_2.ScalarType.string: return String(node.value);
			case types_2.ScalarType.bool: return yaml_ast_parser_1.parseYamlBoolean(node.value);
			case types_2.ScalarType.int: return yaml_ast_parser_1.parseYamlBigInteger(node.value);
			case types_2.ScalarType.float: return yaml_ast_parser_1.parseYamlFloat(node.value);
		}
	}
	const computeLineMap = (input) => {
		const lineMap = [];
		let i = 0;
		for (; i < input.length; i++) if (input[i] === "\n") lineMap.push(i + 1);
		lineMap.push(i + 1);
		return lineMap;
	};
	function getLineLength(lineMap, line) {
		if (line === 0) return Math.max(0, lineMap[0] - 1);
		return Math.max(0, lineMap[line] - lineMap[line - 1] - 1);
	}
	const transformErrors = (errors, lineMap) => {
		const validations = [];
		let possiblyUnexpectedFlow = -1;
		let i = 0;
		for (const error of errors) {
			const validation = {
				code: error.name,
				message: error.reason,
				severity: error.isWarning ? types_1.DiagnosticSeverity.Warning : types_1.DiagnosticSeverity.Error,
				range: {
					start: {
						line: error.mark.line,
						character: error.mark.column
					},
					end: {
						line: error.mark.line,
						character: error.mark.toLineEnd ? getLineLength(lineMap, error.mark.line) : error.mark.column
					}
				}
			};
			if (error.reason === "missed comma between flow collection entries") possiblyUnexpectedFlow = possiblyUnexpectedFlow === -1 ? i : possiblyUnexpectedFlow;
			else if (possiblyUnexpectedFlow !== -1) {
				validations[possiblyUnexpectedFlow].range.end = validation.range.end;
				validations[possiblyUnexpectedFlow].message = "invalid mixed usage of block and flow styles";
				validations.length = possiblyUnexpectedFlow + 1;
				i = validations.length;
				possiblyUnexpectedFlow = -1;
			}
			validations.push(validation);
			i++;
		}
		return validations;
	};
	const reduceMergeKeys = (items, preserveKeyOrder) => {
		if (Array.isArray(items)) return items.reduceRight(preserveKeyOrder ? (merged, item) => {
			const keys = Object.keys(item);
			Object.assign(merged, item);
			for (let i = keys.length - 1; i >= 0; i--) unshiftKey(merged, keys[i]);
			return merged;
		} : (merged, item) => Object.assign(merged, item), createMapContainer(preserveKeyOrder));
		return typeof items !== "object" || items === null ? null : Object(items);
	};
	function createMapContainer(preserveKeyOrder) {
		return preserveKeyOrder ? ordered_object_literal_1.default({}) : {};
	}
	function deleteKey(container, key) {
		if (!(key in container)) return;
		const order = ordered_object_literal_1.getOrder(container);
		const index = order.indexOf(key);
		if (index !== -1) order.splice(index, 1);
	}
	function unshiftKey(container, key) {
		deleteKey(container, key);
		ordered_object_literal_1.getOrder(container).unshift(key);
	}
	function pushKey(container, key) {
		deleteKey(container, key);
		ordered_object_literal_1.getOrder(container).push(key);
	}
	function validateMappingKey(mapping, lineMap, diagnostics, yamlMode) {
		if (mapping.key.kind !== types_2.Kind.SCALAR) {
			if (!yamlMode) diagnostics.push(createYAMLIncompatibilityException(mapping.key, lineMap, "mapping key must be a string scalar", yamlMode));
			return false;
		}
		if (!yamlMode) {
			const type = typeof getScalarValue(mapping.key);
			if (type !== "string") diagnostics.push(createYAMLIncompatibilityException(mapping.key, lineMap, `mapping key must be a string scalar rather than ${mapping.key.valueObject === null ? "null" : type}`, yamlMode));
		}
		return true;
	}
	function createYAMLIncompatibilityException(node, lineMap, message, yamlMode) {
		const exception = createYAMLException(node, lineMap, message);
		exception.code = "YAMLIncompatibleValue";
		exception.severity = yamlMode ? types_1.DiagnosticSeverity.Hint : types_1.DiagnosticSeverity.Warning;
		return exception;
	}
	function createYAMLException(node, lineMap, message) {
		return {
			code: "YAMLException",
			message,
			severity: types_1.DiagnosticSeverity.Error,
			path: buildJsonPath_1.buildJsonPath(node),
			range: getRange(lineMap, node.startPosition, node.endPosition)
		};
	}
	function getRange(lineMap, startPosition, endPosition) {
		const startLine = lineForPosition_1.lineForPosition(startPosition, lineMap);
		const endLine = lineForPosition_1.lineForPosition(endPosition, lineMap);
		return {
			start: {
				line: startLine,
				character: startLine === 0 ? startPosition : startPosition - lineMap[startLine - 1]
			},
			end: {
				line: endLine,
				character: endLine === 0 ? endPosition : endPosition - lineMap[endLine - 1]
			}
		};
	}
	var Comments = class Comments {
		constructor(attachedComments, comments, node, lineMap, pointer) {
			this.attachedComments = attachedComments;
			this.node = node;
			this.lineMap = lineMap;
			this.pointer = pointer;
			if (comments.length === 0) this.comments = [];
			else {
				const startPosition = this.getStartPosition(node);
				const endPosition = this.getEndPosition(node);
				const startLine = lineForPosition_1.lineForPosition(startPosition, this.lineMap);
				const endLine = lineForPosition_1.lineForPosition(endPosition, this.lineMap);
				const matchingComments = [];
				for (let i = comments.length - 1; i >= 0; i--) {
					const comment = comments[i];
					if (comment.range.start.line >= startLine && comment.range.end.line <= endLine) {
						matchingComments.push(comment);
						comments.splice(i, 1);
					}
				}
				this.comments = matchingComments;
			}
		}
		getStartPosition(node) {
			if (node.parent === null) return 0;
			return node.kind === types_2.Kind.MAPPING ? node.key.startPosition : node.startPosition;
		}
		getEndPosition(node) {
			switch (node.kind) {
				case types_2.Kind.MAPPING: return node.value === null ? node.endPosition : this.getEndPosition(node.value);
				case types_2.Kind.MAP: return node.mappings.length === 0 ? node.endPosition : node.mappings[node.mappings.length - 1].endPosition;
				case types_2.Kind.SEQ: {
					if (node.items.length === 0) return node.endPosition;
					const lastItem = node.items[node.items.length - 1];
					return lastItem === null ? node.endPosition : lastItem.endPosition;
				}
				default: return node.endPosition;
			}
		}
		static mapComments(comments, lineMap) {
			return comments.map((comment) => ({
				value: comment.value,
				range: getRange(lineMap, comment.startPosition, comment.endPosition),
				startPosition: comment.startPosition,
				endPosition: comment.endPosition
			}));
		}
		enter(node, key) {
			return new Comments(this.attachedComments, this.comments, node, this.lineMap, key === void 0 ? this.pointer : `${this.pointer}/${key}`);
		}
		static isLeading(node, startPosition) {
			switch (node.kind) {
				case types_2.Kind.MAP: return node.mappings.length === 0 || node.mappings[0].startPosition > startPosition;
				case types_2.Kind.SEQ: {
					if (node.items.length === 0) return true;
					const firstItem = node.items[0];
					return firstItem === null || firstItem.startPosition > startPosition;
				}
				case types_2.Kind.MAPPING: return node.value === null || node.value.startPosition > startPosition;
				default: return false;
			}
		}
		static isTrailing(node, endPosition) {
			switch (node.kind) {
				case types_2.Kind.MAP: return node.mappings.length > 0 && endPosition > node.mappings[node.mappings.length - 1].endPosition;
				case types_2.Kind.SEQ:
					if (node.items.length === 0) return false;
					const lastItem = node.items[node.items.length - 1];
					return lastItem !== null && endPosition > lastItem.endPosition;
				case types_2.Kind.MAPPING: return node.value !== null && endPosition > node.value.endPosition;
				default: return false;
			}
		}
		static findBetween(node, startPosition, endPosition) {
			switch (node.kind) {
				case types_2.Kind.MAP: {
					let left;
					for (const mapping of node.mappings) if (startPosition > mapping.startPosition) left = mapping.key.value;
					else if (left !== void 0 && mapping.startPosition > endPosition) return [left, mapping.key.value];
					return null;
				}
				case types_2.Kind.SEQ: {
					let left;
					for (let i = 0; i < node.items.length; i++) {
						const item = node.items[i];
						if (item === null) continue;
						if (startPosition > item.startPosition) left = String(i);
						else if (left !== void 0 && item.startPosition > endPosition) return [left, String(i)];
					}
					return null;
				}
				default: return null;
			}
		}
		isBeforeEOL(comment) {
			return this.node.kind === types_2.Kind.SCALAR || this.node.kind === types_2.Kind.MAPPING && comment.range.end.line === lineForPosition_1.lineForPosition(this.node.key.endPosition, this.lineMap);
		}
		attachComments() {
			if (this.comments.length === 0) return;
			const attachedComments = this.attachedComments[this.pointer] = this.attachedComments[this.pointer] || [];
			for (const comment of this.comments) if (this.isBeforeEOL(comment)) attachedComments.push({
				value: comment.value,
				placement: "before-eol"
			});
			else if (Comments.isLeading(this.node, comment.startPosition)) attachedComments.push({
				value: comment.value,
				placement: "leading"
			});
			else if (Comments.isTrailing(this.node, comment.endPosition)) attachedComments.push({
				value: comment.value,
				placement: "trailing"
			});
			else {
				const between = Comments.findBetween(this.node, comment.startPosition, comment.endPosition);
				if (between !== null) attachedComments.push({
					value: comment.value,
					placement: "between",
					between
				});
				else attachedComments.push({
					value: comment.value,
					placement: "trailing"
				});
			}
		}
	};
	function normalizeOptions(options) {
		if (options === void 0) return {
			attachComments: false,
			preserveKeyOrder: false,
			bigInt: false,
			mergeKeys: false,
			json: true,
			ignoreDuplicateKeys: false
		};
		return Object.assign({}, options, {
			attachComments: options.attachComments === true,
			preserveKeyOrder: options.preserveKeyOrder === true,
			bigInt: options.bigInt === true,
			mergeKeys: options.mergeKeys === true,
			json: options.json !== false,
			ignoreDuplicateKeys: options.ignoreDuplicateKeys !== false
		});
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const parseWithPointers_1 = require_parseWithPointers();
	exports.parse = (value) => parseWithPointers_1.parseWithPointers(value).data;
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/safeStringify.js
var require_safeStringify = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const yaml_ast_parser_1 = require_src$1();
	exports.safeStringify = (value, options) => typeof value === "string" ? value : yaml_ast_parser_1.safeDump(value, options);
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/trapAccess.js
var require_trapAccess = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const ordered_object_literal_1 = require_src();
	exports.KEYS = Symbol.for(ordered_object_literal_1.ORDER_KEY_ID);
	const traps = { ownKeys(target) {
		return exports.KEYS in target ? target[exports.KEYS] : Reflect.ownKeys(target);
	} };
	exports.trapAccess = (target) => new Proxy(target, traps);
}));

//#endregion
//#region ../../node_modules/.pnpm/@stoplight+yaml@4.3.0/node_modules/@stoplight/yaml/index.js
var require_yaml = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	tslib_1.__exportStar(require_buildJsonPath(), exports);
	tslib_1.__exportStar(require_dereferenceAnchor(), exports);
	tslib_1.__exportStar(require_getJsonPathForPosition(), exports);
	tslib_1.__exportStar(require_getLocationForJsonPath(), exports);
	tslib_1.__exportStar(require_lineForPosition(), exports);
	var parse_1 = require_parse();
	exports.parse = parse_1.parse;
	var parseWithPointers_1 = require_parseWithPointers();
	exports.parseWithPointers = parseWithPointers_1.parseWithPointers;
	tslib_1.__exportStar(require_safeStringify(), exports);
	tslib_1.__exportStar(require_types(), exports);
	tslib_1.__exportStar(require_trapAccess(), exports);
}));

//#endregion
//#region src/utils.ts
var import_yaml = /* @__PURE__ */ __toESM(require_yaml(), 1);
const STRUCTURAL_KEYS = new Set([
	"properties",
	"items",
	"additionalProperties",
	"oneOf",
	"anyOf",
	"allOf",
	"not"
]);
function isOpenApiV2Document(doc) {
	return doc && isPlainObject(doc) && !("openapi" in doc);
}
function isOpenApiV3_1Document(doc) {
	return doc && isPlainObject(doc) && "openapi" in doc && doc.openapi.startsWith("3.1");
}
function isParameterObject(obj) {
	return obj && "in" in obj;
}
/**
* Determines if a schema is nullable, considering:
* - OpenAPI 3.0 `nullable` / `x-nullable`
* - OpenAPI 3.1 JSON Schema `type: ['null', ...]` or `type: 'null'`
*/
function isNullable(schema) {
	if ((schema?.nullable ?? schema?.["x-nullable"]) === true) return true;
	const schemaType = schema?.type;
	if (schemaType === "null") return true;
	if (Array.isArray(schemaType)) return schemaType.includes("null");
	return false;
}
/**
* Determines if the given object is an OpenAPI ReferenceObject.
*/
function isReference(obj) {
	return !!obj && isRef(obj);
}
/**
* Determines if the given object is a SchemaObject with a discriminator property of type DiscriminatorObject.
*/
function isDiscriminator(obj) {
	return !!obj && obj?.["discriminator"] && typeof obj.discriminator !== "string";
}
/**
* Determines whether a schema is required.
*
* Returns true if the schema has a non-empty {@link SchemaObject.required} array or a truthy {@link SchemaObject.required} property.
*/
function isRequired(schema) {
	if (!schema) return false;
	return Array.isArray(schema.required) ? !!schema.required?.length : !!schema.required;
}
function isAllOptional(schema) {
	if (!schema) return true;
	if (isOptional(schema)) return true;
	const s = schema;
	if (Array.isArray(s?.required) && s?.required.length > 0) return false;
	const groups = [
		s?.allOf,
		s?.anyOf,
		s?.oneOf
	].filter((g) => Array.isArray(g));
	if (groups.length === 0) return true;
	return groups.every((arr) => arr.every((child) => isAllOptional(child)));
}
function isOptional(schema) {
	return !isRequired(schema);
}
/**
* Determines the appropriate default value for a schema parameter.
* - For array types: returns '[]'
* - For union types (anyOf/oneOf):
*   - If at least one variant has all-optional fields: returns '{}'
*   - Otherwise: returns undefined (no default)
* - For object types with optional fields: returns '{}'
* - For primitive types (string, number, boolean): returns undefined (no default)
* - For required types: returns undefined (no default)
*/
function getDefaultValue(schema) {
	if (!schema || !isOptional(schema)) return;
	if (schema.type === "array") return "[]";
	if (schema.anyOf || schema.oneOf) {
		const variants = schema.anyOf || schema.oneOf;
		if (!Array.isArray(variants)) return;
		if (!variants.some((variant) => isAllOptional(variant))) return;
		return "{}";
	}
	if (schema.type === "object" || schema.properties) return "{}";
}
async function parse(pathOrApi, { oasClass = Oas, canBundle = true, enablePaths = true } = {}) {
	const { loadConfig, bundle } = await import("@redocly/openapi-core");
	if (typeof pathOrApi === "string" && canBundle) return parse((await bundle({
		ref: pathOrApi,
		config: await loadConfig(),
		base: pathOrApi
	})).bundle.parsed, {
		oasClass,
		canBundle,
		enablePaths
	});
	const document = await new OASNormalize(pathOrApi, {
		enablePaths,
		colorizeErrors: true
	}).load();
	if (isOpenApiV2Document(document)) {
		const { openapi } = await swagger2openapi.convertObj(document, { anchors: true });
		return new oasClass(openapi);
	}
	return new oasClass(document);
}
async function merge(pathOrApi, { oasClass = Oas } = {}) {
	const instances = await Promise.all(pathOrApi.map((p) => parse(p, {
		oasClass,
		enablePaths: false,
		canBundle: false
	})));
	if (instances.length === 0) throw new Error("No OAS instances provided for merging.");
	return parse(instances.reduce((acc, current) => {
		return mergeDeep(acc, current.document);
	}, {
		openapi: "3.0.0",
		info: {
			title: "Merged API",
			version: "1.0.0"
		},
		paths: {},
		components: { schemas: {} }
	}), { oasClass });
}
function parseFromConfig(config, oasClass = Oas) {
	if ("data" in config.input) {
		if (typeof config.input.data === "object") return parse(structuredClone(config.input.data), { oasClass });
		try {
			return parse(import_yaml.parse(config.input.data), { oasClass });
		} catch (_e) {
			return parse(config.input.data, { oasClass });
		}
	}
	if (Array.isArray(config.input)) return merge(config.input.map((input) => path.resolve(config.root, input.path)), { oasClass });
	if (new URLPath(config.input.path).isURL) return parse(config.input.path, { oasClass });
	return parse(path.resolve(config.root, config.input.path), { oasClass });
}
/**
* Flatten allOf schemas by merging keyword-only fragments.
* Only flattens schemas where allOf items don't contain structural keys or $refs.
*/
function flattenSchema(schema) {
	if (!schema?.allOf || schema.allOf.length === 0) return schema || null;
	if (schema.allOf.some((item) => isRef(item))) return schema;
	const isPlainFragment = (item) => !Object.keys(item).some((key) => STRUCTURAL_KEYS.has(key));
	if (!schema.allOf.every((item) => isPlainFragment(item))) return schema;
	const merged = { ...schema };
	delete merged.allOf;
	for (const fragment of schema.allOf) for (const [key, value] of Object.entries(fragment)) if (merged[key] === void 0) merged[key] = value;
	return merged;
}
/**
* Validate an OpenAPI document using oas-normalize.
*/
async function validate(document) {
	return new OASNormalize(document, {
		enablePaths: true,
		colorizeErrors: true
	}).validate({ parser: { validate: { errors: { colorize: true } } } });
}
/**
* Collect all schema $ref dependencies recursively.
*/
function collectRefs(schema, refs = /* @__PURE__ */ new Set()) {
	if (Array.isArray(schema)) {
		for (const item of schema) collectRefs(item, refs);
		return refs;
	}
	if (schema && typeof schema === "object") for (const [key, value] of Object.entries(schema)) if (key === "$ref" && typeof value === "string") {
		const match = value.match(/^#\/components\/schemas\/(.+)$/);
		if (match) refs.add(match[1]);
	} else collectRefs(value, refs);
	return refs;
}
/**
* Sort schemas topologically so referenced schemas appear first.
*/
function sortSchemas(schemas) {
	const deps = /* @__PURE__ */ new Map();
	for (const [name, schema] of Object.entries(schemas)) deps.set(name, Array.from(collectRefs(schema)));
	const sorted = [];
	const visited = /* @__PURE__ */ new Set();
	function visit(name, stack = /* @__PURE__ */ new Set()) {
		if (visited.has(name)) return;
		if (stack.has(name)) return;
		stack.add(name);
		const children = deps.get(name) || [];
		for (const child of children) if (deps.has(child)) visit(child, stack);
		stack.delete(name);
		visited.add(name);
		sorted.push(name);
	}
	for (const name of Object.keys(schemas)) visit(name);
	const sortedSchemas = {};
	for (const name of sorted) sortedSchemas[name] = schemas[name];
	return sortedSchemas;
}
/**
* Extract schema from content object (used by responses and requestBodies).
* Returns null if the schema is just a $ref (not a unique type definition).
*/
function extractSchemaFromContent(content, preferredContentType) {
	if (!content) return null;
	const firstContentType = Object.keys(content)[0] || "application/json";
	const schema = content[preferredContentType || firstContentType]?.schema;
	if (schema && "$ref" in schema) return null;
	return schema || null;
}
/**
* Get semantic suffix for a schema source.
*/
function getSemanticSuffix(source) {
	switch (source) {
		case "schemas": return "Schema";
		case "responses": return "Response";
		case "requestBodies": return "Request";
	}
}
/**
* Legacy resolution strategy - no collision detection, just use original names.
* This preserves backward compatibility when collisionDetection is false.
* @deprecated
*/
function legacyResolve(schemasWithMeta) {
	const schemas = {};
	const nameMapping = /* @__PURE__ */ new Map();
	for (const item of schemasWithMeta) {
		schemas[item.originalName] = item.schema;
		const refPath = `#/components/${item.source}/${item.originalName}`;
		nameMapping.set(refPath, item.originalName);
	}
	return {
		schemas,
		nameMapping
	};
}
/**
* Resolve name collisions by applying suffixes based on collision type.
*
* Strategy:
* - Same-component collisions (e.g., "Variant" + "variant" both in schemas): numeric suffixes (Variant, Variant2)
* - Cross-component collisions (e.g., "Pet" in schemas + "Pet" in requestBodies): semantic suffixes (PetSchema, PetRequest)
*/
function resolveCollisions(schemasWithMeta) {
	const schemas = {};
	const nameMapping = /* @__PURE__ */ new Map();
	const normalizedNames = /* @__PURE__ */ new Map();
	for (const item of schemasWithMeta) {
		const normalized = pascalCase(item.originalName);
		if (!normalizedNames.has(normalized)) normalizedNames.set(normalized, []);
		normalizedNames.get(normalized).push(item);
	}
	for (const [, items] of normalizedNames) {
		if (items.length === 1) {
			const item = items[0];
			schemas[item.originalName] = item.schema;
			const refPath = `#/components/${item.source}/${item.originalName}`;
			nameMapping.set(refPath, item.originalName);
			continue;
		}
		if (new Set(items.map((item) => item.source)).size === 1) items.forEach((item, index) => {
			const suffix = index === 0 ? "" : (index + 1).toString();
			const uniqueName = item.originalName + suffix;
			schemas[uniqueName] = item.schema;
			const refPath = `#/components/${item.source}/${item.originalName}`;
			nameMapping.set(refPath, uniqueName);
		});
		else items.forEach((item) => {
			const suffix = getSemanticSuffix(item.source);
			const uniqueName = item.originalName + suffix;
			schemas[uniqueName] = item.schema;
			const refPath = `#/components/${item.source}/${item.originalName}`;
			nameMapping.set(refPath, uniqueName);
		});
	}
	return {
		schemas,
		nameMapping
	};
}

//#endregion
//#region src/Oas.ts
var Oas = class extends BaseOas {
	#options = { discriminator: "strict" };
	document;
	constructor(document) {
		super(document, void 0);
		this.document = document;
	}
	setOptions(options) {
		this.#options = {
			...this.#options,
			...options
		};
		if (this.#options.discriminator === "inherit") this.#applyDiscriminatorInheritance();
	}
	get options() {
		return this.#options;
	}
	get($ref) {
		const origRef = $ref;
		$ref = $ref.trim();
		if ($ref === "") return null;
		if ($ref.startsWith("#")) $ref = globalThis.decodeURIComponent($ref.substring(1));
		else return null;
		const current = jsonpointer.get(this.api, $ref);
		if (!current) throw new Error(`Could not find a definition for ${origRef}.`);
		return current;
	}
	getKey($ref) {
		const key = $ref.split("/").pop();
		return key === "" ? void 0 : key;
	}
	set($ref, value) {
		$ref = $ref.trim();
		if ($ref === "") return false;
		if ($ref.startsWith("#")) {
			$ref = globalThis.decodeURIComponent($ref.substring(1));
			jsonpointer.set(this.api, $ref, value);
		}
	}
	#setDiscriminator(schema) {
		const { mapping = {}, propertyName } = schema.discriminator;
		if (this.#options.discriminator === "inherit") Object.entries(mapping).forEach(([mappingKey, mappingValue]) => {
			if (mappingValue) {
				const childSchema = this.get(mappingValue);
				if (!childSchema) return;
				if (!childSchema.properties) childSchema.properties = {};
				const property = childSchema.properties[propertyName];
				if (childSchema.properties) {
					childSchema.properties[propertyName] = {
						...childSchema.properties ? childSchema.properties[propertyName] : {},
						enum: [...property?.enum?.filter((value) => value !== mappingKey) ?? [], mappingKey]
					};
					childSchema.required = typeof childSchema.required === "boolean" ? childSchema.required : [...new Set([...childSchema.required ?? [], propertyName])];
					this.set(mappingValue, childSchema);
				}
			}
		});
	}
	getDiscriminator(schema) {
		if (!isDiscriminator(schema) || !schema) return null;
		const { mapping = {}, propertyName } = schema.discriminator;
		/**
		* Helper to extract discriminator value from a schema.
		* Checks in order:
		* 1. Extension property matching propertyName (e.g., x-linode-ref-name)
		* 2. Property with const value
		* 3. Property with single enum value
		* 4. Title as fallback
		*/
		const getDiscriminatorValue = (schema$1) => {
			if (!schema$1) return null;
			if (propertyName.startsWith("x-")) {
				const extensionValue = schema$1[propertyName];
				if (extensionValue && typeof extensionValue === "string") return extensionValue;
			}
			const propertySchema = schema$1.properties?.[propertyName];
			if (propertySchema && "const" in propertySchema && propertySchema.const !== void 0) return String(propertySchema.const);
			if (propertySchema && propertySchema.enum?.length === 1) return String(propertySchema.enum[0]);
			return schema$1.title || null;
		};
		/**
		* Process oneOf/anyOf items to build mapping.
		* Handles both $ref and inline schemas.
		*/
		const processSchemas = (schemas, existingMapping) => {
			schemas.forEach((schemaItem, index) => {
				if (isReference(schemaItem)) {
					const key = this.getKey(schemaItem.$ref);
					try {
						const discriminatorValue = getDiscriminatorValue(this.get(schemaItem.$ref));
						const canAdd = key && !Object.values(existingMapping).includes(schemaItem.$ref);
						if (canAdd && discriminatorValue) existingMapping[discriminatorValue] = schemaItem.$ref;
						else if (canAdd) existingMapping[key] = schemaItem.$ref;
					} catch (_error) {
						if (key && !Object.values(existingMapping).includes(schemaItem.$ref)) existingMapping[key] = schemaItem.$ref;
					}
				} else {
					const discriminatorValue = getDiscriminatorValue(schemaItem);
					if (discriminatorValue) existingMapping[discriminatorValue] = `#kubb-inline-${index}`;
				}
			});
		};
		if (schema.oneOf) processSchemas(schema.oneOf, mapping);
		if (schema.anyOf) processSchemas(schema.anyOf, mapping);
		return {
			...schema.discriminator,
			mapping
		};
	}
	dereferenceWithRef(schema) {
		if (isReference(schema)) return {
			...schema,
			...this.get(schema.$ref),
			$ref: schema.$ref
		};
		return schema;
	}
	#applyDiscriminatorInheritance() {
		const components = this.api.components;
		if (!components?.schemas) return;
		const visited = /* @__PURE__ */ new WeakSet();
		const enqueue = (value) => {
			if (!value) return;
			if (Array.isArray(value)) {
				for (const item of value) enqueue(item);
				return;
			}
			if (typeof value === "object") visit(value);
		};
		const visit = (schema) => {
			if (!schema || typeof schema !== "object") return;
			if (isReference(schema)) {
				visit(this.get(schema.$ref));
				return;
			}
			const schemaObject = schema;
			if (visited.has(schemaObject)) return;
			visited.add(schemaObject);
			if (isDiscriminator(schemaObject)) this.#setDiscriminator(schemaObject);
			if ("allOf" in schemaObject) enqueue(schemaObject.allOf);
			if ("oneOf" in schemaObject) enqueue(schemaObject.oneOf);
			if ("anyOf" in schemaObject) enqueue(schemaObject.anyOf);
			if ("not" in schemaObject) enqueue(schemaObject.not);
			if ("items" in schemaObject) enqueue(schemaObject.items);
			if ("prefixItems" in schemaObject) enqueue(schemaObject.prefixItems);
			if (schemaObject.properties) enqueue(Object.values(schemaObject.properties));
			if (schemaObject.additionalProperties && typeof schemaObject.additionalProperties === "object") enqueue(schemaObject.additionalProperties);
		};
		for (const schema of Object.values(components.schemas)) visit(schema);
	}
	/**
	* Oas does not have a getResponseBody(contentType)
	*/
	#getResponseBodyFactory(responseBody) {
		function hasResponseBody(res = responseBody) {
			return !!res;
		}
		return (contentType) => {
			if (!hasResponseBody(responseBody)) return false;
			if (isReference(responseBody)) return false;
			if (!responseBody.content) return false;
			if (contentType) {
				if (!(contentType in responseBody.content)) return false;
				return responseBody.content[contentType];
			}
			let availableContentType;
			const contentTypes = Object.keys(responseBody.content);
			contentTypes.forEach((mt) => {
				if (!availableContentType && matchesMimeType$1.json(mt)) availableContentType = mt;
			});
			if (!availableContentType) contentTypes.forEach((mt) => {
				if (!availableContentType) availableContentType = mt;
			});
			if (availableContentType) return [
				availableContentType,
				responseBody.content[availableContentType],
				...responseBody.description ? [responseBody.description] : []
			];
			return false;
		};
	}
	getResponseSchema(operation, statusCode) {
		if (operation.schema.responses) Object.keys(operation.schema.responses).forEach((key) => {
			const schema$1 = operation.schema.responses[key];
			const $ref = isReference(schema$1) ? schema$1.$ref : void 0;
			if (schema$1 && $ref) operation.schema.responses[key] = this.get($ref);
		});
		const getResponseBody = this.#getResponseBodyFactory(operation.getResponseByStatusCode(statusCode));
		const { contentType } = this.#options;
		const responseBody = getResponseBody(contentType);
		if (responseBody === false) return {};
		const schema = Array.isArray(responseBody) ? responseBody[1].schema : responseBody.schema;
		if (!schema) return {};
		return this.dereferenceWithRef(schema);
	}
	getRequestSchema(operation) {
		const { contentType } = this.#options;
		if (operation.schema.requestBody) operation.schema.requestBody = this.dereferenceWithRef(operation.schema.requestBody);
		const requestBody = operation.getRequestBody(contentType);
		if (requestBody === false) return;
		const schema = Array.isArray(requestBody) ? requestBody[1].schema : requestBody.schema;
		if (!schema) return;
		return this.dereferenceWithRef(schema);
	}
	getParametersSchema(operation, inKey) {
		const { contentType = operation.getContentType() } = this.#options;
		const params = operation.getParameters().map((schema) => {
			return this.dereferenceWithRef(schema);
		}).filter((v) => v.in === inKey);
		if (!params.length) return null;
		return params.reduce((schema, pathParameters) => {
			const property = pathParameters.content?.[contentType]?.schema ?? pathParameters.schema;
			const required = typeof schema.required === "boolean" ? schema.required : [...schema.required || [], pathParameters.required ? pathParameters.name : void 0].filter(Boolean);
			const getDefaultStyle = (location) => {
				if (location === "query") return "form";
				if (location === "path") return "simple";
				return "simple";
			};
			const style = pathParameters.style || getDefaultStyle(inKey);
			const explode = pathParameters.explode !== void 0 ? pathParameters.explode : style === "form";
			if (inKey === "query" && style === "form" && explode === true && property?.type === "object" && property?.additionalProperties && !property?.properties) return {
				...schema,
				description: pathParameters.description || schema.description,
				deprecated: schema.deprecated,
				example: property.example || schema.example,
				additionalProperties: property.additionalProperties
			};
			return {
				...schema,
				description: schema.description,
				deprecated: schema.deprecated,
				example: schema.example,
				required,
				properties: {
					...schema.properties,
					[pathParameters.name]: {
						description: pathParameters.description,
						...property
					}
				}
			};
		}, {
			type: "object",
			required: [],
			properties: {}
		});
	}
	async validate() {
		return validate(this.api);
	}
	flattenSchema(schema) {
		return flattenSchema(schema);
	}
	/**
	* Get schemas from OpenAPI components (schemas, responses, requestBodies).
	* Returns schemas in dependency order along with name mapping for collision resolution.
	*/
	getSchemas(options = {}) {
		const contentType = options.contentType ?? this.#options.contentType;
		const includes = options.includes ?? [
			"schemas",
			"requestBodies",
			"responses"
		];
		const shouldResolveCollisions = options.collisionDetection ?? this.#options.collisionDetection ?? false;
		const components = this.getDefinition().components;
		const schemasWithMeta = [];
		if (includes.includes("schemas")) {
			const componentSchemas = components?.schemas || {};
			for (const [name, schema] of Object.entries(componentSchemas)) schemasWithMeta.push({
				schema,
				source: "schemas",
				originalName: name
			});
		}
		if (includes.includes("responses")) {
			const responses = components?.responses || {};
			for (const [name, response] of Object.entries(responses)) {
				const schema = extractSchemaFromContent(response.content, contentType);
				if (schema) schemasWithMeta.push({
					schema,
					source: "responses",
					originalName: name
				});
			}
		}
		if (includes.includes("requestBodies")) {
			const requestBodies = components?.requestBodies || {};
			for (const [name, request] of Object.entries(requestBodies)) {
				const schema = extractSchemaFromContent(request.content, contentType);
				if (schema) schemasWithMeta.push({
					schema,
					source: "requestBodies",
					originalName: name
				});
			}
		}
		const { schemas, nameMapping } = shouldResolveCollisions ? resolveCollisions(schemasWithMeta) : legacyResolve(schemasWithMeta);
		return {
			schemas: sortSchemas(schemas),
			nameMapping
		};
	}
};

//#endregion
//#region src/types.ts
const HttpMethods = {
	GET: "get",
	POST: "post",
	PUT: "put",
	PATCH: "patch",
	DELETE: "delete",
	HEAD: "head",
	OPTIONS: "options",
	TRACE: "trace"
};

//#endregion
export { HttpMethods, Oas, findSchemaDefinition, getDefaultValue, isAllOptional, isDiscriminator, isNullable, isOpenApiV3_1Document, isOptional, isParameterObject, isReference, isRequired, matchesMimeType, merge, parse, parseFromConfig, validate };
//# sourceMappingURL=index.js.map