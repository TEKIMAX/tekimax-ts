import { i as __name } from "./chunk-BdfDOGov.js";
import { findSchemaDefinition, matchesMimeType } from "oas/utils";
import BaseOas from "oas";
import * as OasTypes from "oas/types";
import { DiscriminatorObject as DiscriminatorObject$1, HttpMethods as HttpMethods$1, MediaTypeObject as MediaTypeObject$1, OASDocument, ParameterObject, ResponseObject as ResponseObject$1, SchemaObject as SchemaObject$1 } from "oas/types";
import * as oas_normalize_lib_types0 from "oas-normalize/lib/types";
import { Operation as Operation$1 } from "oas/operation";
import { OpenAPIV3, OpenAPIV3 as OpenAPIV3$1, OpenAPIV3_1, OpenAPIV3_1 as OpenAPIV3_1$1 } from "openapi-types";
import { KubbFile } from "@kubb/fabric-core/types";
import { Fabric } from "@kubb/react-fabric";

//#region src/types.d.ts
type contentType = 'application/json' | (string & {});
type SchemaObject = SchemaObject$1 & {
  'x-nullable'?: boolean;
  $ref?: string;
};
declare const HttpMethods: {
  GET: "get";
  POST: "post";
  PUT: "put";
  PATCH: "patch";
  DELETE: "delete";
  HEAD: "head";
  OPTIONS: "options";
  TRACE: "trace";
};
type HttpMethod = HttpMethods$1;
type Document = OASDocument;
type Operation = Operation$1;
type DiscriminatorObject = DiscriminatorObject$1;
type ReferenceObject = OpenAPIV3$1.ReferenceObject;
type ResponseObject = ResponseObject$1;
type MediaTypeObject = MediaTypeObject$1;
//#endregion
//#region src/Oas.d.ts
type OasOptions = {
  contentType?: contentType;
  discriminator?: 'strict' | 'inherit';
  /**
   * Resolve name collisions when schemas from different components share the same name (case-insensitive).
   * @default false
   */
  collisionDetection?: boolean;
};
declare class Oas extends BaseOas {
  #private;
  document: Document;
  constructor(document: Document);
  setOptions(options: OasOptions): void;
  get options(): OasOptions;
  get<T = unknown>($ref: string): T | null;
  getKey($ref: string): string | undefined;
  set($ref: string, value: unknown): false | undefined;
  getDiscriminator(schema: SchemaObject | null): DiscriminatorObject | null;
  dereferenceWithRef<T = unknown>(schema?: T): T;
  getResponseSchema(operation: Operation, statusCode: string | number): SchemaObject;
  getRequestSchema(operation: Operation): SchemaObject | undefined;
  getParametersSchema(operation: Operation, inKey: 'path' | 'query' | 'header'): SchemaObject | null;
  validate(): Promise<oas_normalize_lib_types0.ValidationResult>;
  flattenSchema(schema: SchemaObject | null): SchemaObject | null;
  /**
   * Get schemas from OpenAPI components (schemas, responses, requestBodies).
   * Returns schemas in dependency order along with name mapping for collision resolution.
   */
  getSchemas(options?: {
    contentType?: contentType;
    includes?: Array<'schemas' | 'responses' | 'requestBodies'>;
    collisionDetection?: boolean;
  }): {
    schemas: Record<string, SchemaObject>;
    nameMapping: Map<string, string>;
  };
}
//#endregion
//#region ../core/src/Kubb.d.ts
type DebugEvent = {
  date: Date;
  logs: string[];
  fileName?: string;
};
type ProgressStartMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  hookName: H;
  plugins: Array<Plugin>;
};
type ProgressStopMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  hookName: H;
};
type ExecutingMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  strategy: Strategy;
  hookName: H;
  plugin: Plugin;
  parameters?: unknown[] | undefined;
  output?: unknown;
};
type ExecutedMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  duration: number;
  strategy: Strategy;
  hookName: H;
  plugin: Plugin;
  parameters?: unknown[] | undefined;
  output?: unknown;
};
/**
 * Events emitted during the Kubb code generation lifecycle.
 * These events can be listened to for logging, progress tracking, and custom integrations.
 *
 * @example
 * ```typescript
 * import type { AsyncEventEmitter } from '@kubb/core'
 * import type { KubbEvents } from '@kubb/core'
 *
 * const events: AsyncEventEmitter<KubbEvents> = new AsyncEventEmitter()
 *
 * events.on('lifecycle:start', () => {
 *   console.log('Starting Kubb generation')
 * })
 *
 * events.on('plugin:end', (plugin, { duration }) => {
 *   console.log(`Plugin ${plugin.name} completed in ${duration}ms`)
 * })
 * ```
 */
interface KubbEvents {
  /**
   * Emitted at the beginning of the Kubb lifecycle, before any code generation starts.
   */
  'lifecycle:start': [version: string];
  /**
   * Emitted at the end of the Kubb lifecycle, after all code generation is complete.
   */
  'lifecycle:end': [];
  /**
   * Emitted when configuration loading starts.
   */
  'config:start': [];
  /**
   * Emitted when configuration loading is complete.
   */
  'config:end': [configs: Array<Config>];
  /**
   * Emitted when code generation phase starts.
   */
  'generation:start': [config: Config];
  /**
   * Emitted when code generation phase completes.
   */
  'generation:end': [Config: Config];
  /**
   * Emitted with a summary of the generation results.
   * Contains summary lines, title, and success status.
   */
  'generation:summary': [Config: Config, {
    failedPlugins: Set<{
      plugin: Plugin;
      error: Error;
    }>;
    status: 'success' | 'failed';
    hrStart: [number, number];
    filesCreated: number;
    pluginTimings?: Map<string, number>;
  }];
  /**
   * Emitted when code formatting starts (e.g., running Biome or Prettier).
   */
  'format:start': [];
  /**
   * Emitted when code formatting completes.
   */
  'format:end': [];
  /**
   * Emitted when linting starts.
   */
  'lint:start': [];
  /**
   * Emitted when linting completes.
   */
  'lint:end': [];
  /**
   * Emitted when plugin hooks execution starts.
   */
  'hooks:start': [];
  /**
   * Emitted when plugin hooks execution completes.
   */
  'hooks:end': [];
  /**
   * Emitted when a single hook execution starts. (e.g., format or lint).
   * The callback should be invoked when the command completes.
   */
  'hook:start': [{
    id?: string;
    command: string;
    args?: readonly string[];
  }];
  /**
   * Emitted when a single hook execution completes.
   */
  'hook:end': [{
    id?: string;
    command: string;
    args?: readonly string[];
    success: boolean;
    error: Error | null;
  }];
  /**
   * Emitted when a new version of Kubb is available.
   */
  'version:new': [currentVersion: string, latestVersion: string];
  /**
   * Informational message event.
   */
  info: [message: string, info?: string];
  /**
   * Error event. Emitted when an error occurs during code generation.
   */
  error: [error: Error, meta?: Record<string, unknown>];
  /**
   * Success message event.
   */
  success: [message: string, info?: string];
  /**
   * Warning message event.
   */
  warn: [message: string, info?: string];
  /**
   * Debug event for detailed logging.
   * Contains timestamp, log messages, and optional filename.
   */
  debug: [meta: DebugEvent];
  /**
   * Emitted when file processing starts.
   * Contains the list of files to be processed.
   */
  'files:processing:start': [files: Array<KubbFile.ResolvedFile>];
  /**
   * Emitted for each file being processed, providing progress updates.
   * Contains processed count, total count, percentage, and file details.
   */
  'file:processing:update': [{
    /** Number of files processed so far */
    processed: number;
    /** Total number of files to process */
    total: number;
    /** Processing percentage (0-100) */
    percentage: number;
    /** Optional source identifier */
    source?: string;
    /** The file being processed */
    file: KubbFile.ResolvedFile;
    /**
     * Kubb configuration (not present in Fabric).
     * Provides access to the current config during file processing.
     */
    config: Config;
  }];
  /**
   * Emitted when file processing completes.
   * Contains the list of processed files.
   */
  'files:processing:end': [files: KubbFile.ResolvedFile[]];
  /**
   * Emitted when a plugin starts executing.
   */
  'plugin:start': [plugin: Plugin];
  /**
   * Emitted when a plugin completes execution.
   * Duration in ms
   */
  'plugin:end': [plugin: Plugin, meta: {
    duration: number;
    success: boolean;
    error?: Error;
  }];
  /**
   * Emitted when plugin hook progress tracking starts.
   * Contains the hook name and list of plugins to execute.
   */
  'plugins:hook:progress:start': [meta: ProgressStartMeta];
  /**
   * Emitted when plugin hook progress tracking ends.
   * Contains the hook name that completed.
   */
  'plugins:hook:progress:end': [meta: ProgressStopMeta];
  /**
   * Emitted when a plugin hook starts processing.
   * Contains strategy, hook name, plugin, parameters, and output.
   */
  'plugins:hook:processing:start': [meta: ExecutingMeta];
  /**
   * Emitted when a plugin hook completes processing.
   * Contains duration, strategy, hook name, plugin, parameters, and output.
   */
  'plugins:hook:processing:end': [meta: ExecutedMeta];
}
//#endregion
//#region ../core/src/utils/AsyncEventEmitter.d.ts
declare class AsyncEventEmitter<TEvents extends Record<string, any>> {
  #private;
  constructor(maxListener?: number);
  emit<TEventName extends keyof TEvents & string>(eventName: TEventName, ...eventArgs: TEvents[TEventName]): Promise<void>;
  on<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  onOnce<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArgs: TEvents[TEventName]) => void): void;
  off<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  removeAll(): void;
}
//#endregion
//#region ../core/src/utils/types.d.ts
type PossiblePromise<T> = Promise<T> | T;
//#endregion
//#region ../core/src/types.d.ts
declare global {
  namespace Kubb {
    interface PluginContext {}
  }
}
/**
 * Config used in `kubb.config.ts`
 *
 * @example
 * import { defineConfig } from '@kubb/core'
 * export default defineConfig({
 * ...
 * })
 */

type InputPath = {
  /**
   * Specify your Swagger/OpenAPI file, either as an absolute path or a path relative to the root.
   */
  path: string;
};
type InputData = {
  /**
   * A `string` or `object` that contains your Swagger/OpenAPI data.
   */
  data: string | unknown;
};
type Input = InputPath | InputData | Array<InputPath>;
type BarrelType = 'all' | 'named' | 'propagate';
/**
 * @private
 */
type Config<TInput = Input> = {
  /**
   * The name to display in the CLI output.
   */
  name?: string;
  /**
   * The project root directory, which can be either an absolute path or a path relative to the location of your `kubb.config.ts` file.
   * @default process.cwd()
   */
  root: string;
  /**
   * You can use either `input.path` or `input.data`, depending on your specific needs.
   */
  input: TInput;
  output: {
    /**
     * The path where all generated files receives exported.
     * This can be an absolute path or a path relative to the specified root option.
     */
    path: string;
    /**
     * Clean the output directory before each build.
     */
    clean?: boolean;
    /**
     * Save files to the file system.
     * @default true
     */
    write?: boolean;
    /**
     * Specifies the formatting tool to be used.
     * - 'auto' automatically detects and uses biome or prettier (in that order of preference).
     * - 'prettier' uses Prettier for code formatting.
     * - 'biome' uses Biome for code formatting.
     * - 'oxfmt' uses Oxfmt for code formatting.
     * - false disables code formatting.
     * @default 'prettier'
     */
    format?: 'auto' | 'prettier' | 'biome' | 'oxfmt' | false;
    /**
     * Specifies the linter that should be used to analyze the code.
     * - 'auto' automatically detects and uses biome, oxlint, or eslint (in that order of preference).
     * - 'eslint' uses ESLint for linting.
     * - 'biome' uses Biome for linting.
     * - 'oxlint' uses Oxlint for linting.
     * - false disables linting.
     * @default 'auto'
     */
    lint?: 'auto' | 'eslint' | 'biome' | 'oxlint' | false;
    /**
     * Overrides the extension for generated imports and exports. By default, each plugin adds an extension.
     * @default { '.ts': '.ts'}
     */
    extension?: Record<KubbFile.Extname, KubbFile.Extname | ''>;
    /**
     * Configures how `index.ts` files are created, including disabling barrel file generation. Each plugin has its own `barrelType` option; this setting controls the root barrel file (e.g., `src/gen/index.ts`).
     * @default 'named'
     */
    barrelType?: Exclude<BarrelType, 'propagate'> | false;
    /**
     * Adds a default banner to the start of every generated file indicating it was generated by Kubb.
     * - 'simple' adds banner with link to Kubb.
     * - 'full' adds source, title, description, and OpenAPI version.
     * - false disables banner generation.
     * @default 'simple'
     */
    defaultBanner?: 'simple' | 'full' | false;
    /**
     * Whether to override existing external files if they already exist.
     * When setting the option in the global configuration, all plugins inherit the same behavior by default.
     * However, all plugins also have an `output.override` option, which can be used to override the behavior for a specific plugin.
     * @default false
     */
    override?: boolean;
  };
  /**
   * An array of Kubb plugins that used in the generation.
   * Each plugin may include additional configurable options(defined in the plugin itself).
   * If a plugin depends on another plugin, an error is returned if the required dependency is missing. See pre for more details.
   */
  plugins?: Array<Plugin>;
  /**
   * Hooks triggered when a specific action occurs in Kubb.
   */
  hooks?: {
    /**
     * Hook that triggers at the end of all executions.
     * Useful for running Prettier or ESLint to format/lint your code.
     */
    done?: string | Array<string>;
  };
};
type PluginFactoryOptions<
/**
 * Name to be used for the plugin, this will also be used for they key.
 */
TName extends string = string,
/**
 * Options of the plugin.
 */
TOptions extends object = object,
/**
 * Options of the plugin that can be used later on, see `options` inside your plugin config.
 */
TResolvedOptions extends object = TOptions,
/**
 * Context that you want to expose to other plugins.
 */
TContext = any,
/**
 * When calling `resolvePath` you can specify better types.
 */
TResolvePathOptions extends object = object> = {
  name: TName;
  /**
   * Same behavior like what has been done with `QueryKey` in `@tanstack/react-query`
   */
  key: PluginKey<TName | string>;
  options: TOptions;
  resolvedOptions: TResolvedOptions;
  context: TContext;
  resolvePathOptions: TResolvePathOptions;
};
type PluginKey<TName> = [name: TName, identifier?: string | number];
type Plugin<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  /**
   * Unique name used for the plugin
   * @example @kubb/typescript
   */
  name: TOptions['name'];
  /**
   * Internal key used when a developer uses more than one of the same plugin
   * @private
   */
  key: TOptions['key'];
  /**
   * Specifies the preceding plugins for the current plugin. You can pass an array of preceding plugin names, and the current plugin is executed after these plugins.
   * Can be used to validate dependent plugins.
   */
  pre?: Array<string>;
  /**
   * Specifies the succeeding plugins for the current plugin. You can pass an array of succeeding plugin names, and the current plugin is executed before these plugins.
   */
  post?: Array<string>;
  /**
   * Options set for a specific plugin(see kubb.config.js), passthrough of options.
   */
  options: TOptions['resolvedOptions'];
  install: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => PossiblePromise<void>;
  /**
   * Define a context that can be used by other plugins, see `PluginManager' where we convert from `UserPlugin` to `Plugin`(used when calling `definePlugin`).
   */
  inject: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => TOptions['context'];
};
type PluginWithLifeCycle<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = Plugin<TOptions> & PluginLifecycle<TOptions>;
type PluginLifecycle<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  /**
   * Start of the lifecycle of a plugin.
   * @type hookParallel
   */
  install?: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => PossiblePromise<void>;
  /**
   * Resolve to a Path based on a baseName(example: `./Pet.ts`) and directory(example: `./models`).
   * Options can als be included.
   * @type hookFirst
   * @example ('./Pet.ts', './src/gen/') => '/src/gen/Pet.ts'
   */
  resolvePath?: (this: PluginContext<TOptions>, baseName: KubbFile.BaseName, mode?: KubbFile.Mode, options?: TOptions['resolvePathOptions']) => KubbFile.Path;
  /**
   * Resolve to a name based on a string.
   * Useful when converting to PascalCase or camelCase.
   * @type hookFirst
   * @example ('pet') => 'Pet'
   */
  resolveName?: (this: PluginContext<TOptions>, name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string;
};
type PluginLifecycleHooks = keyof PluginLifecycle;
type PluginParameter<H extends PluginLifecycleHooks> = Parameters<Required<PluginLifecycle>[H]>;
type ResolvePathParams<TOptions = object> = {
  pluginKey?: Plugin['key'];
  baseName: KubbFile.BaseName;
  mode?: KubbFile.Mode;
  /**
   * Options to be passed to 'resolvePath' 3th parameter
   */
  options?: TOptions;
};
type ResolveNameParams = {
  name: string;
  pluginKey?: Plugin['key'];
  /**
   * Specifies the type of entity being named.
   * - 'file' customizes the name of the created file (uses camelCase).
   * - 'function' customizes the exported function names (uses camelCase).
   * - 'type' customizes TypeScript types (uses PascalCase).
   * - 'const' customizes variable names (uses camelCase).
   * @default undefined
   */
  type?: 'file' | 'function' | 'type' | 'const';
};
type PluginContext<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  fabric: Fabric;
  config: Config;
  pluginManager: PluginManager;
  /**
   * Only add when the file does not exist yet
   */
  addFile: (...file: Array<KubbFile.File>) => Promise<void>;
  /**
   * merging multiple sources into the same output file
   */
  upsertFile: (...file: Array<KubbFile.File>) => Promise<void>;
  events: AsyncEventEmitter<KubbEvents>;
  mode: KubbFile.Mode;
  /**
   * Current plugin
   */
  plugin: Plugin<TOptions>;
} & Kubb.PluginContext;
//#endregion
//#region ../core/src/PluginManager.d.ts
type RequiredPluginLifecycle = Required<PluginLifecycle>;
type Strategy = 'hookFirst' | 'hookForPlugin' | 'hookParallel' | 'hookSeq';
type ParseResult<H extends PluginLifecycleHooks> = RequiredPluginLifecycle[H];
type SafeParseResult<H extends PluginLifecycleHooks, Result = ReturnType<ParseResult<H>>> = {
  result: Result;
  plugin: Plugin;
};
type Options = {
  fabric: Fabric;
  events: AsyncEventEmitter<KubbEvents>;
  /**
   * @default Number.POSITIVE_INFINITY
   */
  concurrency?: number;
};
type GetFileProps<TOptions = object> = {
  name: string;
  mode?: KubbFile.Mode;
  extname: KubbFile.Extname;
  pluginKey: Plugin['key'];
  options?: TOptions;
};
declare class PluginManager {
  #private;
  readonly config: Config;
  readonly options: Options;
  constructor(config: Config, options: Options);
  get events(): AsyncEventEmitter<KubbEvents>;
  getContext<TOptions extends PluginFactoryOptions>(plugin: Plugin<TOptions>): PluginContext<TOptions> & Record<string, any>;
  get plugins(): Array<Plugin>;
  getFile<TOptions = object>({
    name,
    mode,
    extname,
    pluginKey,
    options
  }: GetFileProps<TOptions>): KubbFile.File<{
    pluginKey: Plugin['key'];
  }>;
  resolvePath: <TOptions = object>(params: ResolvePathParams<TOptions>) => KubbFile.Path;
  resolveName: (params: ResolveNameParams) => string;
  /**
   * Run a specific hookName for plugin x.
   */
  hookForPlugin<H extends PluginLifecycleHooks>({
    pluginKey,
    hookName,
    parameters
  }: {
    pluginKey: Plugin['key'];
    hookName: H;
    parameters: PluginParameter<H>;
  }): Promise<Array<ReturnType<ParseResult<H>> | null>>;
  /**
   * Run a specific hookName for plugin x.
   */
  hookForPluginSync<H extends PluginLifecycleHooks>({
    pluginKey,
    hookName,
    parameters
  }: {
    pluginKey: Plugin['key'];
    hookName: H;
    parameters: PluginParameter<H>;
  }): Array<ReturnType<ParseResult<H>>> | null;
  /**
   * Returns the first non-null result.
   */
  hookFirst<H extends PluginLifecycleHooks>({
    hookName,
    parameters,
    skipped
  }: {
    hookName: H;
    parameters: PluginParameter<H>;
    skipped?: ReadonlySet<Plugin> | null;
  }): Promise<SafeParseResult<H>>;
  /**
   * Returns the first non-null result.
   */
  hookFirstSync<H extends PluginLifecycleHooks>({
    hookName,
    parameters,
    skipped
  }: {
    hookName: H;
    parameters: PluginParameter<H>;
    skipped?: ReadonlySet<Plugin> | null;
  }): SafeParseResult<H>;
  /**
   * Runs all plugins in parallel based on `this.plugin` order and `pre`/`post` settings.
   */
  hookParallel<H extends PluginLifecycleHooks, TOutput = void>({
    hookName,
    parameters
  }: {
    hookName: H;
    parameters?: Parameters<RequiredPluginLifecycle[H]> | undefined;
  }): Promise<Awaited<TOutput>[]>;
  /**
   * Chains plugins
   */
  hookSeq<H extends PluginLifecycleHooks>({
    hookName,
    parameters
  }: {
    hookName: H;
    parameters?: PluginParameter<H>;
  }): Promise<void>;
  getPluginByKey(pluginKey: Plugin['key']): Plugin | undefined;
  getPluginsByKey(hookName: keyof PluginWithLifeCycle, pluginKey: Plugin['key']): Plugin[];
}
//#endregion
//#region src/utils.d.ts
declare function isOpenApiV3_1Document(doc: any): doc is OpenAPIV3_1$1.Document;
declare function isParameterObject(obj: ParameterObject | SchemaObject$1): obj is ParameterObject;
/**
 * Determines if a schema is nullable, considering:
 * - OpenAPI 3.0 `nullable` / `x-nullable`
 * - OpenAPI 3.1 JSON Schema `type: ['null', ...]` or `type: 'null'`
 */
declare function isNullable(schema?: SchemaObject$1 & {
  'x-nullable'?: boolean;
}): boolean;
/**
 * Determines if the given object is an OpenAPI ReferenceObject.
 */
declare function isReference(obj?: any): obj is OpenAPIV3$1.ReferenceObject | OpenAPIV3_1$1.ReferenceObject;
/**
 * Determines if the given object is a SchemaObject with a discriminator property of type DiscriminatorObject.
 */
declare function isDiscriminator(obj?: any): obj is SchemaObject$1 & {
  discriminator: OpenAPIV3$1.DiscriminatorObject;
};
/**
 * Determines whether a schema is required.
 *
 * Returns true if the schema has a non-empty {@link SchemaObject.required} array or a truthy {@link SchemaObject.required} property.
 */
declare function isRequired(schema?: SchemaObject$1): boolean;
declare function isAllOptional(schema: unknown): boolean;
declare function isOptional(schema?: SchemaObject$1): boolean;
/**
 * Determines the appropriate default value for a schema parameter.
 * - For array types: returns '[]'
 * - For union types (anyOf/oneOf):
 *   - If at least one variant has all-optional fields: returns '{}'
 *   - Otherwise: returns undefined (no default)
 * - For object types with optional fields: returns '{}'
 * - For primitive types (string, number, boolean): returns undefined (no default)
 * - For required types: returns undefined (no default)
 */
declare function getDefaultValue(schema?: SchemaObject$1): string | undefined;
declare function parse(pathOrApi: string | Document, {
  oasClass,
  canBundle,
  enablePaths
}?: {
  oasClass?: typeof Oas;
  canBundle?: boolean;
  enablePaths?: boolean;
}): Promise<Oas>;
declare function merge(pathOrApi: Array<string | Document>, {
  oasClass
}?: {
  oasClass?: typeof Oas;
}): Promise<Oas>;
declare function parseFromConfig(config: Config, oasClass?: typeof Oas): Promise<Oas>;
/**
 * Validate an OpenAPI document using oas-normalize.
 */
declare function validate(document: Document): Promise<oas_normalize_lib_types0.ValidationResult>;
//#endregion
export { DiscriminatorObject, Document, HttpMethod, HttpMethods, MediaTypeObject, Oas, type OasTypes, type OpenAPIV3, type OpenAPIV3_1, Operation, ReferenceObject, ResponseObject, SchemaObject, contentType, findSchemaDefinition, getDefaultValue, isAllOptional, isDiscriminator, isNullable, isOpenApiV3_1Document, isOptional, isParameterObject, isReference, isRequired, matchesMimeType, merge, parse, parseFromConfig, validate };
//# sourceMappingURL=index.d.ts.map