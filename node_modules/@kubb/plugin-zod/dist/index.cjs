const require_components = require('./components-Cs1U51T4.cjs');
const require_generators = require('./generators-BeILgXPF.cjs');
let node_path = require("node:path");
node_path = require_components.__toESM(node_path);
let _kubb_core = require("@kubb/core");
let _kubb_core_transformers = require("@kubb/core/transformers");
let _kubb_core_utils = require("@kubb/core/utils");
let _kubb_plugin_oas = require("@kubb/plugin-oas");
let _kubb_plugin_ts = require("@kubb/plugin-ts");

//#region src/plugin.ts
const pluginZodName = "plugin-zod";
const pluginZod = (0, _kubb_core.definePlugin)((options) => {
	const { output = {
		path: "zod",
		barrelType: "named"
	}, group, exclude = [], include, override = [], transformers = {}, dateType = "string", unknownType = "any", emptySchemaType = unknownType, typed = false, mapper = {}, operations = false, mini = false, version = mini ? "4" : new _kubb_core.PackageManager().isValidSync("zod", ">=4") ? "4" : "3", importPath = mini ? "zod/mini" : version === "4" ? "zod/v4" : "zod", coercion = false, inferred = false, generators = [require_generators.zodGenerator, operations ? require_generators.operationsGenerator : void 0].filter(Boolean), wrapOutput = void 0, contentType } = options;
	return {
		name: pluginZodName,
		options: {
			output,
			transformers,
			include,
			exclude,
			override,
			typed,
			dateType,
			unknownType,
			emptySchemaType,
			mapper,
			importPath,
			coercion,
			operations,
			inferred,
			group,
			wrapOutput,
			version,
			mini,
			usedEnumNames: {}
		},
		pre: [_kubb_plugin_oas.pluginOasName, typed ? _kubb_plugin_ts.pluginTsName : void 0].filter(Boolean),
		resolvePath(baseName, pathMode, options$1) {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			if ((pathMode ?? (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path))) === "single")
 /**
			* when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend
			* Other plugins then need to call addOrAppend instead of just add from the fileManager class
			*/
			return node_path.default.resolve(root, output.path);
			if (group && (options$1?.group?.path || options$1?.group?.tag)) {
				const groupName = group?.name ? group.name : (ctx) => {
					if (group?.type === "path") return `${ctx.group.split("/")[1]}`;
					return `${(0, _kubb_core_transformers.camelCase)(ctx.group)}Controller`;
				};
				return node_path.default.resolve(root, output.path, groupName({ group: group.type === "path" ? options$1.group.path : options$1.group.tag }), baseName);
			}
			return node_path.default.resolve(root, output.path, baseName);
		},
		resolveName(name, type) {
			let resolvedName = (0, _kubb_core_transformers.camelCase)(name, {
				suffix: type ? "schema" : void 0,
				isFile: type === "file"
			});
			if (type === "type") resolvedName = (0, _kubb_core_transformers.pascalCase)(resolvedName);
			if (type) return transformers?.name?.(resolvedName, type) || resolvedName;
			return resolvedName;
		},
		async install() {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			const mode = (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path));
			const oas = await this.getOas();
			if (this.plugin.options.typed && this.plugin.options.version === "3") await this.addFile({
				baseName: "ToZod.ts",
				path: node_path.default.resolve(root, ".kubb/ToZod.ts"),
				sources: [{
					name: "ToZod",
					value: (0, _kubb_core_utils.resolveModuleSource)("@kubb/plugin-zod/templates/ToZod").source
				}],
				imports: [],
				exports: []
			});
			const schemaFiles = await new _kubb_plugin_oas.SchemaGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				include: void 0,
				override,
				mode,
				output: output.path
			}).build(...generators);
			await this.upsertFile(...schemaFiles);
			const operationFiles = await new _kubb_plugin_oas.OperationGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				exclude,
				include,
				override,
				mode
			}).build(...generators);
			await this.upsertFile(...operationFiles);
			const barrelFiles = await (0, _kubb_core.getBarrelFiles)(this.fabric.files, {
				type: output.barrelType ?? "named",
				root,
				output,
				meta: { pluginKey: this.plugin.key }
			});
			await this.upsertFile(...barrelFiles);
		}
	};
});

//#endregion
exports.pluginZod = pluginZod;
exports.pluginZodName = pluginZodName;
//# sourceMappingURL=index.cjs.map