import { t as __name } from "./chunk-eQyhnF5A.js";
import { n as operationsGenerator, t as zodGenerator } from "./generators-WdjCkovi.js";
import path from "node:path";
import { PackageManager, definePlugin, getBarrelFiles, getMode } from "@kubb/core";
import { camelCase, pascalCase } from "@kubb/core/transformers";
import { resolveModuleSource } from "@kubb/core/utils";
import { OperationGenerator, SchemaGenerator, pluginOasName } from "@kubb/plugin-oas";
import { pluginTsName } from "@kubb/plugin-ts";

//#region src/plugin.ts
const pluginZodName = "plugin-zod";
const pluginZod = definePlugin((options) => {
	const { output = {
		path: "zod",
		barrelType: "named"
	}, group, exclude = [], include, override = [], transformers: transformers$1 = {}, dateType = "string", unknownType = "any", emptySchemaType = unknownType, typed = false, mapper = {}, operations = false, mini = false, version = mini ? "4" : new PackageManager().isValidSync("zod", ">=4") ? "4" : "3", importPath = mini ? "zod/mini" : version === "4" ? "zod/v4" : "zod", coercion = false, inferred = false, generators = [zodGenerator, operations ? operationsGenerator : void 0].filter(Boolean), wrapOutput = void 0, contentType } = options;
	return {
		name: pluginZodName,
		options: {
			output,
			transformers: transformers$1,
			include,
			exclude,
			override,
			typed,
			dateType,
			unknownType,
			emptySchemaType,
			mapper,
			importPath,
			coercion,
			operations,
			inferred,
			group,
			wrapOutput,
			version,
			mini,
			usedEnumNames: {}
		},
		pre: [pluginOasName, typed ? pluginTsName : void 0].filter(Boolean),
		resolvePath(baseName, pathMode, options$1) {
			const root = path.resolve(this.config.root, this.config.output.path);
			if ((pathMode ?? getMode(path.resolve(root, output.path))) === "single")
 /**
			* when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend
			* Other plugins then need to call addOrAppend instead of just add from the fileManager class
			*/
			return path.resolve(root, output.path);
			if (group && (options$1?.group?.path || options$1?.group?.tag)) {
				const groupName = group?.name ? group.name : (ctx) => {
					if (group?.type === "path") return `${ctx.group.split("/")[1]}`;
					return `${camelCase(ctx.group)}Controller`;
				};
				return path.resolve(root, output.path, groupName({ group: group.type === "path" ? options$1.group.path : options$1.group.tag }), baseName);
			}
			return path.resolve(root, output.path, baseName);
		},
		resolveName(name, type) {
			let resolvedName = camelCase(name, {
				suffix: type ? "schema" : void 0,
				isFile: type === "file"
			});
			if (type === "type") resolvedName = pascalCase(resolvedName);
			if (type) return transformers$1?.name?.(resolvedName, type) || resolvedName;
			return resolvedName;
		},
		async install() {
			const root = path.resolve(this.config.root, this.config.output.path);
			const mode = getMode(path.resolve(root, output.path));
			const oas = await this.getOas();
			if (this.plugin.options.typed && this.plugin.options.version === "3") await this.addFile({
				baseName: "ToZod.ts",
				path: path.resolve(root, ".kubb/ToZod.ts"),
				sources: [{
					name: "ToZod",
					value: resolveModuleSource("@kubb/plugin-zod/templates/ToZod").source
				}],
				imports: [],
				exports: []
			});
			const schemaFiles = await new SchemaGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				include: void 0,
				override,
				mode,
				output: output.path
			}).build(...generators);
			await this.upsertFile(...schemaFiles);
			const operationFiles = await new OperationGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				exclude,
				include,
				override,
				mode
			}).build(...generators);
			await this.upsertFile(...operationFiles);
			const barrelFiles = await getBarrelFiles(this.fabric.files, {
				type: output.barrelType ?? "named",
				root,
				output,
				meta: { pluginKey: this.plugin.key }
			});
			await this.upsertFile(...barrelFiles);
		}
	};
});

//#endregion
export { pluginZod, pluginZodName };
//# sourceMappingURL=index.js.map