const require_components = require('./components-Cs1U51T4.cjs');
let node_path = require("node:path");
node_path = require_components.__toESM(node_path);
let _kubb_plugin_oas = require("@kubb/plugin-oas");
let _kubb_plugin_ts = require("@kubb/plugin-ts");
let _kubb_core_hooks = require("@kubb/core/hooks");
let _kubb_plugin_oas_generators = require("@kubb/plugin-oas/generators");
let _kubb_plugin_oas_hooks = require("@kubb/plugin-oas/hooks");
let _kubb_plugin_oas_utils = require("@kubb/plugin-oas/utils");
let _kubb_react_fabric = require("@kubb/react-fabric");
let _kubb_react_fabric_jsx_runtime = require("@kubb/react-fabric/jsx-runtime");

//#region src/generators/operationsGenerator.tsx
const operationsGenerator = (0, _kubb_plugin_oas_generators.createReactGenerator)({
	name: "operations",
	Operations({ operations, generator, plugin }) {
		const { key: pluginKey, options: { output, importPath } } = plugin;
		const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
		const oas = (0, _kubb_plugin_oas_hooks.useOas)();
		const { getFile, groupSchemasByName } = (0, _kubb_plugin_oas_hooks.useOperationManager)(generator);
		const name = "operations";
		const file = pluginManager.getFile({
			name,
			extname: ".ts",
			pluginKey
		});
		const transformedOperations = operations.map((operation) => ({
			operation,
			data: groupSchemasByName(operation, { type: "function" })
		}));
		const imports = Object.entries(transformedOperations).map(([key, { data, operation }]) => {
			const names = [
				data.request,
				...Object.values(data.responses),
				...Object.values(data.parameters)
			].filter(Boolean);
			return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
				name: names,
				root: file.path,
				path: getFile(operation).path
			}, key);
		}).filter(Boolean);
		return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File, {
			baseName: file.baseName,
			path: file.path,
			meta: file.meta,
			banner: (0, _kubb_plugin_oas_utils.getBanner)({
				oas,
				output,
				config: pluginManager.config
			}),
			footer: (0, _kubb_plugin_oas_utils.getFooter)({
				oas,
				output
			}),
			children: [
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					isTypeOnly: true,
					name: ["z"],
					path: importPath
				}),
				imports,
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(require_components.Operations, {
					name,
					operations: transformedOperations
				})
			]
		});
	}
});

//#endregion
//#region src/generators/zodGenerator.tsx
const zodGenerator = (0, _kubb_plugin_oas_generators.createReactGenerator)({
	name: "zod",
	Operation({ config, operation, generator, plugin }) {
		const { options, options: { coercion: globalCoercion, inferred, typed, mapper, wrapOutput, version, mini } } = plugin;
		const mode = (0, _kubb_core_hooks.useMode)();
		const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
		const oas = (0, _kubb_plugin_oas_hooks.useOas)();
		const { getSchemas, getFile, getGroup } = (0, _kubb_plugin_oas_hooks.useOperationManager)(generator);
		const schemaManager = (0, _kubb_plugin_oas_hooks.useSchemaManager)();
		const file = getFile(operation);
		const schemas = getSchemas(operation);
		const schemaGenerator = new _kubb_plugin_oas.SchemaGenerator(options, {
			fabric: generator.context.fabric,
			oas,
			plugin,
			pluginManager,
			events: generator.context.events,
			mode,
			override: options.override
		});
		const operationSchemas = [
			schemas.pathParams,
			schemas.queryParams,
			schemas.headerParams,
			schemas.statusCodes,
			schemas.request,
			schemas.response
		].flat().filter(Boolean);
		const mapOperationSchema = ({ name, schema: schemaOriginal, description, keysToOmit: keysToOmitOriginal, ...options$1 }) => {
			let schemaObject = schemaOriginal;
			let keysToOmit = keysToOmitOriginal;
			if ((schemaOriginal.anyOf || schemaOriginal.oneOf) && keysToOmitOriginal && keysToOmitOriginal.length > 0) {
				schemaObject = structuredClone(schemaOriginal);
				delete schemaObject.$ref;
				for (const key of keysToOmitOriginal) delete schemaObject.properties?.[key];
				if (Array.isArray(schemaObject.required)) schemaObject.required = schemaObject.required.filter((key) => !keysToOmitOriginal.includes(key));
				keysToOmit = void 0;
			}
			const hasProperties = Object.keys(schemaObject || {}).length > 0;
			const hasDefaults = Object.values(schemaObject.properties || {}).some((prop) => prop && Object.hasOwn(prop, "default"));
			const optional = !(Array.isArray(schemaObject?.required) ? schemaObject.required.length > 0 : !!schemaObject?.required) && !hasDefaults && hasProperties && name.includes("Params");
			if (!optional && Array.isArray(schemaObject.required) && !schemaObject.required.length) schemaObject.required = Object.entries(schemaObject.properties || {}).filter(([_key, value]) => value && Object.hasOwn(value, "default")).map(([key]) => key);
			const tree = [...schemaGenerator.parse({
				schema: schemaObject,
				name,
				parentName: null
			}), optional ? { keyword: _kubb_plugin_oas.schemaKeywords.optional } : void 0].filter(Boolean);
			const imports = schemaManager.getImports(tree);
			const group = options$1.operation ? getGroup(options$1.operation) : void 0;
			const coercion = name.includes("Params") ? {
				numbers: true,
				strings: false,
				dates: true
			} : globalCoercion;
			const zod = {
				name: schemaManager.getName(name, { type: "function" }),
				inferTypeName: schemaManager.getName(name, { type: "type" }),
				file: schemaManager.getFile(name)
			};
			const type = {
				name: schemaManager.getName(name, {
					type: "type",
					pluginKey: [_kubb_plugin_ts.pluginTsName]
				}),
				file: schemaManager.getFile(options$1.operationName || name, {
					pluginKey: [_kubb_plugin_ts.pluginTsName],
					group
				})
			};
			return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric_jsx_runtime.Fragment, { children: [
				typed && /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					isTypeOnly: true,
					root: file.path,
					path: type.file.path,
					name: [type.name]
				}),
				typed && version === "3" && /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					name: ["ToZod"],
					root: file.path,
					path: node_path.default.resolve(config.root, config.output.path, ".kubb/ToZod.ts")
				}),
				imports.map((imp) => /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					root: file.path,
					path: imp.path,
					name: imp.name
				}, [
					imp.path,
					imp.name,
					imp.isTypeOnly
				].join("-"))),
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(require_components.Zod, {
					name: zod.name,
					typeName: typed ? type.name : void 0,
					inferTypeName: inferred ? zod.inferTypeName : void 0,
					description,
					tree,
					schema: schemaObject,
					mapper,
					coercion,
					keysToOmit,
					wrapOutput,
					version: plugin.options.version,
					emptySchemaType: plugin.options.emptySchemaType,
					mini
				})
			] });
		};
		return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File, {
			baseName: file.baseName,
			path: file.path,
			meta: file.meta,
			banner: (0, _kubb_plugin_oas_utils.getBanner)({
				oas,
				output: plugin.options.output,
				config: pluginManager.config
			}),
			footer: (0, _kubb_plugin_oas_utils.getFooter)({
				oas,
				output: plugin.options.output
			}),
			children: [/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
				name: ["z"],
				path: plugin.options.importPath
			}), operationSchemas.map(mapOperationSchema)]
		});
	},
	Schema({ config, schema, plugin }) {
		const { getName, getFile, getImports } = (0, _kubb_plugin_oas_hooks.useSchemaManager)();
		const { options: { output, emptySchemaType, coercion, inferred, typed, mapper, importPath, wrapOutput, version, mini } } = plugin;
		const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
		const oas = (0, _kubb_plugin_oas_hooks.useOas)();
		const imports = getImports(schema.tree);
		const zod = {
			name: getName(schema.name, { type: "function" }),
			inferTypeName: getName(schema.name, { type: "type" }),
			file: getFile(schema.name)
		};
		const type = {
			name: getName(schema.name, {
				type: "type",
				pluginKey: [_kubb_plugin_ts.pluginTsName]
			}),
			file: getFile(schema.name, { pluginKey: [_kubb_plugin_ts.pluginTsName] })
		};
		return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File, {
			baseName: zod.file.baseName,
			path: zod.file.path,
			meta: zod.file.meta,
			banner: (0, _kubb_plugin_oas_utils.getBanner)({
				oas,
				output,
				config: pluginManager.config
			}),
			footer: (0, _kubb_plugin_oas_utils.getFooter)({
				oas,
				output
			}),
			children: [
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					name: ["z"],
					path: importPath
				}),
				typed && /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					isTypeOnly: true,
					root: zod.file.path,
					path: type.file.path,
					name: [type.name]
				}),
				typed && version === "3" && /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					name: ["ToZod"],
					root: zod.file.path,
					path: node_path.default.resolve(config.root, config.output.path, ".kubb/ToZod.ts")
				}),
				imports.map((imp) => /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
					root: zod.file.path,
					path: imp.path,
					name: imp.name
				}, [
					imp.path,
					imp.name,
					imp.isTypeOnly
				].join("-"))),
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(require_components.Zod, {
					name: zod.name,
					typeName: typed ? type.name : void 0,
					inferTypeName: inferred ? zod.inferTypeName : void 0,
					description: schema.value.description,
					tree: schema.tree,
					schema: schema.value,
					mapper,
					coercion,
					wrapOutput,
					version,
					emptySchemaType,
					mini
				})
			]
		});
	}
});

//#endregion
Object.defineProperty(exports, 'operationsGenerator', {
  enumerable: true,
  get: function () {
    return operationsGenerator;
  }
});
Object.defineProperty(exports, 'zodGenerator', {
  enumerable: true,
  get: function () {
    return zodGenerator;
  }
});
//# sourceMappingURL=generators-BeILgXPF.cjs.map