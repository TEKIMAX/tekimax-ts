{"version":3,"file":"components-BmXLaLL5.js","names":["schema","parserZod.sort","parserZod.filterMiniModifiers","parserZod.parse","parserZod.wrapWithMiniModifiers","parserZod.extractMiniModifiers"],"sources":["../src/components/Operations.tsx","../src/parser.ts","../src/components/Zod.tsx"],"sourcesContent":["import transformers from '@kubb/core/transformers'\nimport type { HttpMethod, Operation } from '@kubb/oas'\nimport type { SchemaNames } from '@kubb/plugin-oas/hooks'\nimport { Const, File, Type } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\n\ntype Props = {\n  name: string\n  operations: Array<{ operation: Operation; data: SchemaNames }>\n}\n\nexport function Operations({ name, operations }: Props): FabricReactNode {\n  const operationsJSON = operations.reduce(\n    (prev, acc) => {\n      prev[`\"${acc.operation.getOperationId()}\"`] = acc.data\n\n      return prev\n    },\n    {} as Record<string, unknown>,\n  )\n\n  const pathsJSON = operations.reduce(\n    (prev, acc) => {\n      prev[`\"${acc.operation.path}\"`] = {\n        ...(prev[`\"${acc.operation.path}\"`] || ({} as Record<HttpMethod, string>)),\n        [acc.operation.method]: `operations[\"${acc.operation.getOperationId()}\"]`,\n      }\n\n      return prev\n    },\n    {} as Record<string, Record<HttpMethod, string>>,\n  )\n\n  return (\n    <>\n      <File.Source name=\"OperationSchema\" isExportable isIndexable>\n        <Type name=\"OperationSchema\" export>{`{\n  readonly request: z.ZodTypeAny | undefined;\n  readonly parameters: {\n        readonly path: z.ZodTypeAny | undefined;\n        readonly query: z.ZodTypeAny | undefined;\n        readonly header: z.ZodTypeAny | undefined;\n  };\n  readonly responses: {\n        readonly [status: number]: z.ZodTypeAny;\n        readonly default: z.ZodTypeAny;\n  };\n  readonly errors: {\n        readonly [status: number]: z.ZodTypeAny;\n  };\n}`}</Type>\n      </File.Source>\n      <File.Source name=\"OperationsMap\" isExportable isIndexable>\n        <Type name=\"OperationsMap\" export>\n          {'Record<string, OperationSchema>'}\n        </Type>\n      </File.Source>\n      <File.Source name={name} isExportable isIndexable>\n        <Const export name={name} asConst>\n          {`{${transformers.stringifyObject(operationsJSON)}}`}\n        </Const>\n      </File.Source>\n      <File.Source name={'paths'} isExportable isIndexable>\n        <Const export name={'paths'} asConst>\n          {`{${transformers.stringifyObject(pathsJSON)}}`}\n        </Const>\n      </File.Source>\n    </>\n  )\n}\n","import transformers from '@kubb/core/transformers'\n\nimport type { Schema, SchemaMapper } from '@kubb/plugin-oas'\nimport { createParser, findSchemaKeyword, isKeyword, SchemaGenerator, type SchemaKeywordMapper, schemaKeywords } from '@kubb/plugin-oas'\n\n//TODO add zodKeywordMapper as function that returns 3 versions: v3, v4 and v4 mini, this can also be used to have the custom mapping(see object type)\n// also include shouldCoerce\n\n/**\n * Helper to build string/array length constraint checks for Zod Mini mode\n */\nfunction buildLengthChecks(min?: number, max?: number): string[] {\n  const checks: string[] = []\n  if (min !== undefined) checks.push(`z.minLength(${min})`)\n  if (max !== undefined) checks.push(`z.maxLength(${max})`)\n  return checks\n}\n\nconst zodKeywordMapper = {\n  any: () => 'z.any()',\n  unknown: () => 'z.unknown()',\n  void: () => 'z.void()',\n  number: (coercion?: boolean, min?: number, max?: number, exclusiveMinimum?: number, exclusiveMaximum?: number, mini?: boolean) => {\n    if (mini) {\n      const checks: string[] = []\n      if (min !== undefined) checks.push(`z.minimum(${min})`)\n      if (max !== undefined) checks.push(`z.maximum(${max})`)\n      if (exclusiveMinimum !== undefined) checks.push(`z.minimum(${exclusiveMinimum}, { exclusive: true })`)\n      if (exclusiveMaximum !== undefined) checks.push(`z.maximum(${exclusiveMaximum}, { exclusive: true })`)\n      if (checks.length > 0) {\n        return `z.number().check(${checks.join(', ')})`\n      }\n      return 'z.number()'\n    }\n    return [\n      coercion ? 'z.coerce.number()' : 'z.number()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n      exclusiveMinimum !== undefined ? `.gt(${exclusiveMinimum})` : undefined,\n      exclusiveMaximum !== undefined ? `.lt(${exclusiveMaximum})` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  integer: (coercion?: boolean, min?: number, max?: number, version: '3' | '4' = '3', exclusiveMinimum?: number, exclusiveMaximum?: number, mini?: boolean) => {\n    if (mini) {\n      const checks: string[] = []\n      if (min !== undefined) checks.push(`z.minimum(${min})`)\n      if (max !== undefined) checks.push(`z.maximum(${max})`)\n      if (exclusiveMinimum !== undefined) checks.push(`z.minimum(${exclusiveMinimum}, { exclusive: true })`)\n      if (exclusiveMaximum !== undefined) checks.push(`z.maximum(${exclusiveMaximum}, { exclusive: true })`)\n      if (checks.length > 0) {\n        return `z.int().check(${checks.join(', ')})`\n      }\n      return 'z.int()'\n    }\n    return [\n      coercion ? 'z.coerce.number().int()' : version === '4' ? 'z.int()' : 'z.number().int()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n      exclusiveMinimum !== undefined ? `.gt(${exclusiveMinimum})` : undefined,\n      exclusiveMaximum !== undefined ? `.lt(${exclusiveMaximum})` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  interface: (value?: string, strict?: boolean) => {\n    if (strict) {\n      return `z.strictInterface({\n    ${value}\n    })`\n    }\n    return `z.interface({\n    ${value}\n    })`\n  },\n  object: (value?: string, strict?: boolean, version: '3' | '4' = '3') => {\n    if (version === '4' && strict) {\n      return `z.strictObject({\n    ${value}\n    })`\n    }\n\n    if (strict) {\n      return `z.object({\n    ${value}\n    }).strict()`\n    }\n\n    return `z.object({\n    ${value}\n    })`\n  },\n  string: (coercion?: boolean, min?: number, max?: number, mini?: boolean) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      if (checks.length > 0) {\n        return `z.string().check(${checks.join(', ')})`\n      }\n      return 'z.string()'\n    }\n    return [coercion ? 'z.coerce.string()' : 'z.string()', min !== undefined ? `.min(${min})` : undefined, max !== undefined ? `.max(${max})` : undefined]\n      .filter(Boolean)\n      .join('')\n  },\n  //support for discriminatedUnion\n  boolean: () => 'z.boolean()',\n  undefined: () => 'z.undefined()',\n  nullable: (value?: string) => {\n    if (value) {\n      return `z.nullable(${value})`\n    }\n    return '.nullable()'\n  },\n  null: () => 'z.null()',\n  nullish: (value?: string) => {\n    if (value) {\n      return `z.nullish(${value})`\n    }\n    return '.nullish()'\n  },\n  array: (items: string[] = [], min?: number, max?: number, unique?: boolean, mini?: boolean) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      if (unique) checks.push(`z.refine(items => new Set(items).size === items.length, { message: \"Array entries must be unique\" })`)\n      if (checks.length > 0) {\n        return `z.array(${items?.join('')}).check(${checks.join(', ')})`\n      }\n      return `z.array(${items?.join('')})`\n    }\n    return [\n      `z.array(${items?.join('')})`,\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n      unique ? `.refine(items => new Set(items).size === items.length, { message: \"Array entries must be unique\" })` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  tuple: (items: string[] = []) => `z.tuple([${items?.join(', ')}])`,\n  enum: (items: string[] = []) => `z.enum([${items?.join(', ')}])`,\n  union: (items: string[] = []) => `z.union([${items?.join(', ')}])`,\n  const: (value?: string | number | boolean) => `z.literal(${value ?? ''})`,\n  /**\n   * ISO 8601\n   */\n  datetime: (offset = false, local = false, version: '3' | '4' = '3', mini?: boolean) => {\n    // Zod Mini doesn't support .datetime() method, use plain string\n    if (mini) {\n      return 'z.string()'\n    }\n\n    if (offset) {\n      return version === '4' ? `z.iso.datetime({ offset: ${offset} })` : `z.string().datetime({ offset: ${offset} })`\n    }\n\n    if (local) {\n      return version === '4' ? `z.iso.datetime({ local: ${local} })` : `z.string().datetime({ local: ${local} })`\n    }\n\n    return version === '4' ? 'z.iso.datetime()' : 'z.string().datetime()'\n  },\n  /**\n   * Type `'date'` Date\n   * Type `'string'` ISO date format (YYYY-MM-DD)\n   * @default ISO date format (YYYY-MM-DD)\n   */\n  date: (type: 'date' | 'string' = 'string', coercion?: boolean, version: '3' | '4' = '3') => {\n    if (type === 'string') {\n      return version === '4' ? 'z.iso.date()' : 'z.string().date()'\n    }\n\n    if (coercion) {\n      return 'z.coerce.date()'\n    }\n\n    return 'z.date()'\n  },\n  /**\n   * Type `'date'` Date\n   * Type `'string'` ISO time format (HH:mm:ss[.SSSSSS])\n   * @default ISO time format (HH:mm:ss[.SSSSSS])\n   */\n  time: (type: 'date' | 'string' = 'string', coercion?: boolean, version: '3' | '4' = '3') => {\n    if (type === 'string') {\n      return version === '4' ? 'z.iso.time()' : 'z.string().time()'\n    }\n\n    if (coercion) {\n      return 'z.coerce.date()'\n    }\n\n    return 'z.date()'\n  },\n  uuid: (coercion?: boolean, version: '3' | '4' = '3', min?: number, max?: number, mini?: boolean) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      if (checks.length > 0) {\n        return `z.uuid().check(${checks.join(', ')})`\n      }\n      return 'z.uuid()'\n    }\n    return [\n      coercion ? (version === '4' ? 'z.uuid()' : 'z.coerce.string().uuid()') : version === '4' ? 'z.uuid()' : 'z.string().uuid()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  url: (coercion?: boolean, version: '3' | '4' = '3', min?: number, max?: number, mini?: boolean) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      if (checks.length > 0) {\n        return `z.url().check(${checks.join(', ')})`\n      }\n      return 'z.url()'\n    }\n    return [\n      coercion ? (version === '4' ? 'z.url()' : 'z.coerce.string().url()') : version === '4' ? 'z.url()' : 'z.string().url()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  default: (value?: string | number | boolean | object, innerSchema?: string, mini?: boolean) => {\n    if (mini && innerSchema) {\n      const defaultValue = typeof value === 'object' ? '{}' : (value ?? '')\n      return `z._default(${innerSchema}, ${defaultValue})`\n    }\n\n    if (typeof value === 'object') {\n      return '.default({})'\n    }\n\n    if (value === undefined) {\n      return '.default()'\n    }\n\n    if (typeof value === 'string' && !value) {\n      return `.default('')`\n    }\n\n    return `.default(${value ?? ''})`\n  },\n  and: (items: string[] = [], mini?: boolean) => {\n    // zod/mini doesn't support .and() method, so we can't use intersection types\n    // In mini mode, we try to extract and append .check() calls instead\n    if (mini && items.length > 0) {\n      // Try to extract check calls from additional items\n      const checks: string[] = []\n      for (const item of items) {\n        // Extract .check(...) from patterns like \"z.string().check(...)\"\n        // Need to handle nested parentheses properly\n        const checkStart = item.indexOf('.check(')\n        if (checkStart !== -1) {\n          // Find the matching closing parenthesis\n          let depth = 0\n          let i = checkStart + 7 // length of '.check('\n          let checkContent = ''\n          while (i < item.length) {\n            const char = item[i]\n            if (char === '(') depth++\n            else if (char === ')') {\n              if (depth === 0) break\n              depth--\n            }\n            checkContent += char\n            i++\n          }\n          if (checkContent) {\n            checks.push(checkContent)\n          }\n        }\n      }\n\n      if (checks.length > 0) {\n        // Append checks to the base schema\n        return `.check(${checks.join(', ')})`\n      }\n\n      // If we can't extract checks, just use the first schema (limitation)\n      return ''\n    }\n    return items?.map((item) => `.and(${item})`).join('')\n  },\n  describe: (value = '', innerSchema?: string, mini?: boolean) => {\n    if (mini) {\n      return undefined\n    }\n\n    if (innerSchema) {\n      return `z.describe(${innerSchema}, ${value})`\n    }\n    return `.describe(${value})`\n  },\n  max: undefined,\n  min: undefined,\n  optional: (value?: string) => {\n    if (value) {\n      return `z.optional(${value})`\n    }\n    return '.optional()'\n  },\n  matches: (value = '', coercion?: boolean, mini?: boolean, min?: number, max?: number) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      checks.push(`z.regex(${value})`)\n      return `z.string().check(${checks.join(', ')})`\n    }\n    return [\n      coercion ? 'z.coerce.string()' : 'z.string()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n      `.regex(${value})`,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  email: (coercion?: boolean, version: '3' | '4' = '3', min?: number, max?: number, mini?: boolean) => {\n    if (mini) {\n      const checks = buildLengthChecks(min, max)\n      if (checks.length > 0) {\n        return `z.email().check(${checks.join(', ')})`\n      }\n      return 'z.email()'\n    }\n    return [\n      coercion ? (version === '4' ? 'z.email()' : 'z.coerce.string().email()') : version === '4' ? 'z.email()' : 'z.string().email()',\n      min !== undefined ? `.min(${min})` : undefined,\n      max !== undefined ? `.max(${max})` : undefined,\n    ]\n      .filter(Boolean)\n      .join('')\n  },\n  firstName: undefined,\n  lastName: undefined,\n  password: undefined,\n  phone: undefined,\n  readOnly: undefined,\n  writeOnly: undefined,\n  ref: (value?: string) => {\n    if (!value) {\n      return undefined\n    }\n\n    return `z.lazy(() => ${value})`\n  },\n  blob: () => 'z.instanceof(File)',\n  deprecated: undefined,\n  example: undefined,\n  schema: undefined,\n  catchall: (value?: string, mini?: boolean) => {\n    // Zod Mini doesn't support .catchall() method\n    if (mini) {\n      return undefined\n    }\n    return value ? `.catchall(${value})` : undefined\n  },\n  name: undefined,\n  exclusiveMinimum: undefined,\n  exclusiveMaximum: undefined,\n} satisfies SchemaMapper<string | null | undefined>\n\n/**\n * @link based on https://github.com/cellular/oazapfts/blob/7ba226ebb15374e8483cc53e7532f1663179a22c/src/codegen/generate.ts#L398\n */\n\nexport function sort(items?: Schema[]): Schema[] {\n  const order: string[] = [\n    schemaKeywords.string,\n    schemaKeywords.datetime,\n    schemaKeywords.date,\n    schemaKeywords.time,\n    schemaKeywords.tuple,\n    schemaKeywords.number,\n    schemaKeywords.object,\n    schemaKeywords.enum,\n    schemaKeywords.url,\n    schemaKeywords.email,\n    schemaKeywords.firstName,\n    schemaKeywords.lastName,\n    schemaKeywords.password,\n    schemaKeywords.matches,\n    schemaKeywords.uuid,\n    schemaKeywords.null,\n    schemaKeywords.min,\n    schemaKeywords.max,\n    schemaKeywords.default,\n    schemaKeywords.describe,\n    schemaKeywords.optional,\n    schemaKeywords.nullable,\n    schemaKeywords.nullish,\n  ]\n\n  if (!items) {\n    return []\n  }\n\n  return transformers.orderBy(items, [(v) => order.indexOf(v.keyword)], ['asc'])\n}\n\ntype MiniModifiers = {\n  hasOptional?: boolean\n  hasNullable?: boolean\n  hasNullish?: boolean\n  defaultValue?: string | number | true | object\n}\n\n/**\n * Keywords that represent modifiers for mini mode\n * These are separated from the base schema and wrapped around it\n * Note: describe is included to filter it out, but won't be wrapped (Zod Mini doesn't support describe)\n */\nexport const miniModifierKeywords = [schemaKeywords.optional, schemaKeywords.nullable, schemaKeywords.nullish, schemaKeywords.default, schemaKeywords.describe]\n\n/**\n * Extracts mini mode modifiers from a schemas array\n * This can be reused by other parsers (e.g., valibot) that need similar functionality\n * Note: describe is not included as Zod Mini doesn't support it\n */\nexport function extractMiniModifiers(schemas: Schema[]): MiniModifiers {\n  const defaultSchema = schemas.find((item) => isKeyword(item, schemaKeywords.default)) as { keyword: string; args: unknown } | undefined\n\n  return {\n    hasOptional: schemas.some((item) => isKeyword(item, schemaKeywords.optional)),\n    hasNullable: schemas.some((item) => isKeyword(item, schemaKeywords.nullable)),\n    hasNullish: schemas.some((item) => isKeyword(item, schemaKeywords.nullish)),\n    defaultValue: defaultSchema?.args as string | number | true | object | undefined,\n  }\n}\n\n/**\n * Filters out modifier keywords from schemas for mini mode base schema parsing\n * This can be reused by other parsers (e.g., valibot) that need similar functionality\n */\nexport function filterMiniModifiers(schemas: Schema[]): Schema[] {\n  return schemas.filter((item) => !miniModifierKeywords.some((keyword) => isKeyword(item, keyword)))\n}\n\n/**\n * Wraps an output string with Zod Mini functional modifiers\n * Order: default (innermost) -> nullable -> optional (outermost)\n * OR: default -> nullish\n * Note: describe is not supported in Zod Mini and is skipped\n */\nexport function wrapWithMiniModifiers(output: string, modifiers: MiniModifiers): string {\n  let result = output\n\n  // Apply default first (innermost wrapper)\n  if (modifiers.defaultValue !== undefined) {\n    result = zodKeywordMapper.default(modifiers.defaultValue, result, true)!\n  }\n\n  // Apply nullish, nullable, or optional (outer wrappers for optionality)\n  if (modifiers.hasNullish) {\n    result = zodKeywordMapper.nullish(result)!\n  } else {\n    if (modifiers.hasNullable) {\n      result = zodKeywordMapper.nullable(result)!\n    }\n    if (modifiers.hasOptional) {\n      result = zodKeywordMapper.optional(result)!\n    }\n  }\n\n  return result\n}\n\nconst shouldCoerce = (coercion: ParserOptions['coercion'] | undefined, type: 'dates' | 'strings' | 'numbers'): boolean => {\n  if (coercion === undefined) {\n    return false\n  }\n  if (typeof coercion === 'boolean') {\n    return coercion\n  }\n\n  return !!coercion[type]\n}\n\ntype ParserOptions = {\n  mapper?: Record<string, string>\n  coercion?: boolean | { dates?: boolean; strings?: boolean; numbers?: boolean }\n  wrapOutput?: (opts: { output: string; schema: any }) => string | undefined\n  version: '3' | '4'\n  skipLazyForRefs?: boolean\n  mini?: boolean\n}\n\n// Create the parser using createParser\nexport const parse = createParser<string, ParserOptions>({\n  mapper: zodKeywordMapper,\n  handlers: {\n    union(tree, options) {\n      const { current, schema, parent, name, siblings } = tree\n\n      // zod union type needs at least 2 items\n      if (Array.isArray(current.args) && current.args.length === 1) {\n        return this.parse({ schema, parent, name, current: current.args[0] as Schema, siblings }, options)\n      }\n      if (Array.isArray(current.args) && !current.args.length) {\n        return ''\n      }\n\n      return zodKeywordMapper.union(\n        sort(current.args)\n          .map((it, _index, siblings) => this.parse({ schema, parent: current, name, current: it, siblings }, options))\n          .filter(Boolean),\n      )\n    },\n    and(tree, options) {\n      const { current, schema, name } = tree\n\n      const items = sort(current.args)\n        .filter((schema: Schema) => {\n          return ![schemaKeywords.optional, schemaKeywords.describe].includes(schema.keyword as typeof schemaKeywords.describe)\n        })\n        .map((it: Schema, _index, siblings) => this.parse({ schema, parent: current, name, current: it, siblings }, options))\n        .filter(Boolean)\n\n      return `${items.slice(0, 1)}${zodKeywordMapper.and(items.slice(1), options.mini)}`\n    },\n    array(tree, options) {\n      const { current, schema, name } = tree\n\n      return zodKeywordMapper.array(\n        sort(current.args.items)\n          .map((it, _index, siblings) => {\n            return this.parse({ schema, parent: current, name, current: it, siblings }, options)\n          })\n          .filter(Boolean),\n        current.args.min,\n        current.args.max,\n        current.args.unique,\n        options.mini,\n      )\n    },\n    enum(tree, options) {\n      const { current, schema, name } = tree\n\n      if (current.args.asConst) {\n        if (current.args.items.length === 1) {\n          const child = {\n            keyword: schemaKeywords.const,\n            args: current.args.items[0],\n          }\n          return this.parse({ schema, parent: current, name, current: child, siblings: [child] }, options)\n        }\n\n        return zodKeywordMapper.union(\n          current.args.items\n            .map((schema) => ({\n              keyword: schemaKeywords.const,\n              args: schema,\n            }))\n            .map((it, _index, siblings) => {\n              return this.parse({ schema, parent: current, name, current: it, siblings }, options)\n            })\n            .filter(Boolean),\n        )\n      }\n\n      return zodKeywordMapper.enum(\n        current.args.items.map((schema) => {\n          if (schema.format === 'boolean') {\n            return transformers.stringify(schema.value)\n          }\n\n          if (schema.format === 'number') {\n            return transformers.stringify(schema.value)\n          }\n          return transformers.stringify(schema.value)\n        }),\n      )\n    },\n    ref(tree, options) {\n      const { current } = tree\n\n      // Skip z.lazy wrapper if skipLazyForRefs is true (e.g., inside v4 getters)\n      if (options.skipLazyForRefs) {\n        return current.args?.name\n      }\n      return zodKeywordMapper.ref(current.args?.name)\n    },\n    object(tree, options) {\n      const { current, schema, name } = tree\n\n      const propertyEntries = Object.entries(current.args?.properties || {}).filter((item) => {\n        const schema = item[1]\n        return schema && typeof schema.map === 'function'\n      })\n\n      const properties = propertyEntries\n        .map(([propertyName, schemas]) => {\n          const nameSchema = schemas.find((it) => it.keyword === schemaKeywords.name) as SchemaKeywordMapper['name']\n          const isNullable = schemas.some((it) => isKeyword(it, schemaKeywords.nullable))\n          const isNullish = schemas.some((it) => isKeyword(it, schemaKeywords.nullish))\n          const isOptional = schemas.some((it) => isKeyword(it, schemaKeywords.optional))\n          const hasRef = !!SchemaGenerator.find(schemas, schemaKeywords.ref)\n\n          const mappedName = nameSchema?.args || propertyName\n\n          // custom mapper(pluginOptions)\n          // Use Object.hasOwn to avoid matching inherited properties like 'toString', 'valueOf', etc.\n          if (options.mapper && Object.hasOwn(options.mapper, mappedName)) {\n            return `\"${propertyName}\": ${options.mapper?.[mappedName]}`\n          }\n\n          const baseSchemaOutput = sort(schemas)\n            .filter((schema) => {\n              return !isKeyword(schema, schemaKeywords.optional) && !isKeyword(schema, schemaKeywords.nullable) && !isKeyword(schema, schemaKeywords.nullish)\n            })\n            .map((it) => {\n              // For v4 with refs, skip z.lazy wrapper since the getter provides lazy evaluation\n              const skipLazyForRefs = options.version === '4' && hasRef\n              return this.parse({ schema, parent: current, name, current: it, siblings: schemas }, { ...options, skipLazyForRefs })\n            })\n            .filter(Boolean)\n            .join('')\n\n          const objectValue = options.wrapOutput\n            ? options.wrapOutput({ output: baseSchemaOutput, schema: schema?.properties?.[propertyName] }) || baseSchemaOutput\n            : baseSchemaOutput\n\n          if (options.version === '4' && hasRef) {\n            // In mini mode, use functional wrappers instead of chainable methods\n            if (options.mini) {\n              // both optional and nullable\n              if (isNullish) {\n                return `get \"${propertyName}\"(){\n                return ${zodKeywordMapper.nullish(objectValue)}\n              }`\n              }\n\n              // undefined\n              if (isOptional) {\n                return `get \"${propertyName}\"(){\n                return ${zodKeywordMapper.optional(objectValue)}\n              }`\n              }\n\n              // null\n              if (isNullable) {\n                return `get \"${propertyName}\"(){\n                return ${zodKeywordMapper.nullable(objectValue)}\n              }`\n              }\n\n              return `get \"${propertyName}\"(){\n                return ${objectValue}\n              }`\n            }\n\n            // Non-mini mode uses chainable methods\n            // both optional and nullable\n            if (isNullish) {\n              return `get \"${propertyName}\"(){\n                return ${objectValue}${zodKeywordMapper.nullish()}\n              }`\n            }\n\n            // undefined\n            if (isOptional) {\n              return `get \"${propertyName}\"(){\n                return ${objectValue}${zodKeywordMapper.optional()}\n              }`\n            }\n\n            // null\n            if (isNullable) {\n              return `get \"${propertyName}\"(){\n               return ${objectValue}${zodKeywordMapper.nullable()}\n              }`\n            }\n\n            return `get \"${propertyName}\"(){\n                return ${objectValue}\n              }`\n          }\n\n          // both optional and nullable\n          if (isNullish && options.mini) {\n            return `\"${propertyName}\": ${zodKeywordMapper.nullish(objectValue)}`\n          }\n\n          if (isNullish && !options.mini) {\n            return `\"${propertyName}\": ${objectValue}${zodKeywordMapper.nullish()}`\n          }\n\n          // undefined\n          if (isOptional) {\n            return `\"${propertyName}\": ${zodKeywordMapper.optional(objectValue)}`\n          }\n\n          // null\n          if (isNullable) {\n            return `\"${propertyName}\": ${zodKeywordMapper.nullable(objectValue)}`\n          }\n\n          return `\"${propertyName}\": ${objectValue}`\n        })\n        .join(',\\n')\n\n      const additionalProperties = current.args?.additionalProperties?.length\n        ? current.args.additionalProperties\n            .map((it, _index, siblings) => this.parse({ schema, parent: current, name, current: it, siblings }, options))\n            .filter(Boolean)\n            .join('')\n        : undefined\n\n      const text = [\n        zodKeywordMapper.object(properties, current.args?.strict, options.version),\n        additionalProperties ? zodKeywordMapper.catchall(additionalProperties, options.mini) : undefined,\n      ].filter(Boolean)\n\n      return text.join('')\n    },\n    tuple(tree, options) {\n      const { current, schema, name } = tree\n\n      return zodKeywordMapper.tuple(\n        current.args.items.map((it, _index, siblings) => this.parse({ schema, parent: current, name, current: it, siblings }, options)).filter(Boolean),\n      )\n    },\n    const(tree, _options) {\n      const { current } = tree\n\n      if (current.args.format === 'number' && current.args.value !== undefined) {\n        return zodKeywordMapper.const(Number(current.args.value))\n      }\n\n      if (current.args.format === 'boolean' && current.args.value !== undefined) {\n        return zodKeywordMapper.const(typeof current.args.value === 'boolean' ? current.args.value : undefined)\n      }\n      return zodKeywordMapper.const(transformers.stringify(current.args.value))\n    },\n    matches(tree, options) {\n      const { current, siblings } = tree\n\n      // Early exit: if siblings contain both matches and ref â†’ skip matches entirely\n      const hasRef = siblings.some((it) => isKeyword(it, schemaKeywords.ref))\n      if (hasRef) {\n        return undefined // strip matches\n      }\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n\n      if (current.args) {\n        return zodKeywordMapper.matches(\n          transformers.toRegExpString(current.args, null),\n          shouldCoerce(options.coercion, 'strings'),\n          options.mini,\n          minSchema?.args,\n          maxSchema?.args,\n        )\n      }\n      return undefined\n    },\n    default(tree, options) {\n      const { current } = tree\n\n      // In mini mode, default is handled by wrapWithMiniModifiers\n      if (options.mini) {\n        return undefined\n      }\n      if (current.args !== undefined) {\n        return zodKeywordMapper.default(current.args)\n      }\n      // When args is undefined, call the mapper without arguments\n      return zodKeywordMapper.default()\n    },\n    describe(tree, options) {\n      const { current } = tree\n\n      if (current.args) {\n        return zodKeywordMapper.describe(transformers.stringify(current.args.toString()), undefined, options.mini)\n      }\n      return undefined\n    },\n    string(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n\n      return zodKeywordMapper.string(shouldCoerce(options.coercion, 'strings'), minSchema?.args, maxSchema?.args, options.mini)\n    },\n    uuid(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n\n      return zodKeywordMapper.uuid(shouldCoerce(options.coercion, 'strings'), options.version, minSchema?.args, maxSchema?.args, options.mini)\n    },\n    email(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n\n      return zodKeywordMapper.email(shouldCoerce(options.coercion, 'strings'), options.version, minSchema?.args, maxSchema?.args, options.mini)\n    },\n    url(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n\n      return zodKeywordMapper.url(shouldCoerce(options.coercion, 'strings'), options.version, minSchema?.args, maxSchema?.args, options.mini)\n    },\n    number(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n      const exclusiveMinimumSchema = findSchemaKeyword(siblings, 'exclusiveMinimum')\n      const exclusiveMaximumSchema = findSchemaKeyword(siblings, 'exclusiveMaximum')\n\n      return zodKeywordMapper.number(\n        shouldCoerce(options.coercion, 'numbers'),\n        minSchema?.args,\n        maxSchema?.args,\n        exclusiveMinimumSchema?.args,\n        exclusiveMaximumSchema?.args,\n        options.mini,\n      )\n    },\n    integer(tree, options) {\n      const { siblings } = tree\n\n      const minSchema = findSchemaKeyword(siblings, 'min')\n      const maxSchema = findSchemaKeyword(siblings, 'max')\n      const exclusiveMinimumSchema = findSchemaKeyword(siblings, 'exclusiveMinimum')\n      const exclusiveMaximumSchema = findSchemaKeyword(siblings, 'exclusiveMaximum')\n\n      return zodKeywordMapper.integer(\n        shouldCoerce(options.coercion, 'numbers'),\n        minSchema?.args,\n        maxSchema?.args,\n        options.version,\n        exclusiveMinimumSchema?.args,\n        exclusiveMaximumSchema?.args,\n        options.mini,\n      )\n    },\n    datetime(tree, options) {\n      const { current } = tree\n\n      return zodKeywordMapper.datetime(current.args.offset, current.args.local, options.version, options.mini)\n    },\n    date(tree, options) {\n      const { current } = tree\n\n      return zodKeywordMapper.date(current.args.type, shouldCoerce(options.coercion, 'dates'), options.version)\n    },\n    time(tree, options) {\n      const { current } = tree\n\n      return zodKeywordMapper.time(current.args.type, shouldCoerce(options.coercion, 'dates'), options.version)\n    },\n  },\n})\n","import transformers from '@kubb/core/transformers'\nimport type { SchemaObject } from '@kubb/oas'\nimport { isKeyword, type Schema, SchemaGenerator, schemaKeywords } from '@kubb/plugin-oas'\nimport { Const, File, Type } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport * as parserZod from '../parser.ts'\nimport type { PluginZod } from '../types.ts'\n\ntype Props = {\n  name: string\n  typeName?: string\n  inferTypeName?: string\n  tree: Array<Schema>\n  schema: SchemaObject\n  description?: string\n  coercion: PluginZod['resolvedOptions']['coercion']\n  mapper: PluginZod['resolvedOptions']['mapper']\n  keysToOmit?: string[]\n  wrapOutput?: PluginZod['resolvedOptions']['wrapOutput']\n  version: '3' | '4'\n  emptySchemaType: PluginZod['resolvedOptions']['emptySchemaType']\n  mini?: boolean\n}\n\nexport function Zod({\n  name,\n  typeName,\n  tree,\n  schema,\n  inferTypeName,\n  mapper,\n  coercion,\n  keysToOmit,\n  description,\n  wrapOutput,\n  version,\n  emptySchemaType,\n  mini = false,\n}: Props): FabricReactNode {\n  const hasTuple = !!SchemaGenerator.find(tree, schemaKeywords.tuple)\n\n  const schemas = parserZod.sort(tree).filter((item) => {\n    if (hasTuple && (isKeyword(item, schemaKeywords.min) || isKeyword(item, schemaKeywords.max))) {\n      return false\n    }\n\n    return true\n  })\n\n  // In mini mode, filter out modifiers from the main schema parsing\n  const baseSchemas = mini ? parserZod.filterMiniModifiers(schemas) : schemas\n\n  const output = baseSchemas\n    .map((schemaKeyword, index) => {\n      const siblings = baseSchemas.filter((_, i) => i !== index)\n\n      return parserZod.parse({ schema, parent: undefined, current: schemaKeyword, siblings, name }, { mapper, coercion, wrapOutput, version, mini })\n    })\n    .filter(Boolean)\n    .join('')\n\n  let suffix = ''\n  const firstSchema = schemas.at(0)\n  const lastSchema = schemas.at(-1)\n\n  if (!mini && lastSchema && isKeyword(lastSchema, schemaKeywords.nullable)) {\n    if (firstSchema && isKeyword(firstSchema, schemaKeywords.ref)) {\n      if (version === '3') {\n        suffix = '.unwrap().schema.unwrap()'\n      } else {\n        suffix = '.unwrap().unwrap()'\n      }\n    } else {\n      suffix = '.unwrap()'\n    }\n  } else if (!mini) {\n    if (firstSchema && isKeyword(firstSchema, schemaKeywords.ref)) {\n      if (version === '3') {\n        suffix = '.schema'\n      } else {\n        suffix = '.unwrap()'\n      }\n    }\n  }\n\n  const emptyValue = parserZod.parse(\n    {\n      schema,\n      parent: undefined,\n      current: {\n        keyword: schemaKeywords[emptySchemaType],\n      },\n      siblings: [],\n    },\n    { mapper, coercion, wrapOutput, version, mini },\n  )\n\n  let baseSchemaOutput =\n    [output, keysToOmit?.length ? `${suffix}.omit({ ${keysToOmit.map((key) => `'${key}': true`).join(',')} })` : undefined].filter(Boolean).join('') ||\n    emptyValue ||\n    ''\n\n  // For mini mode, wrap the output with modifiers using the parser function\n  if (mini) {\n    baseSchemaOutput = parserZod.wrapWithMiniModifiers(baseSchemaOutput, parserZod.extractMiniModifiers(schemas))\n  }\n\n  const wrappedSchemaOutput = wrapOutput ? wrapOutput({ output: baseSchemaOutput, schema }) || baseSchemaOutput : baseSchemaOutput\n  const finalOutput = typeName ? `${wrappedSchemaOutput} as unknown as ${version === '4' ? 'z.ZodType' : 'ToZod'}<${typeName}>` : wrappedSchemaOutput\n\n  return (\n    <>\n      <File.Source name={name} isExportable isIndexable>\n        <Const\n          export\n          name={name}\n          JSDoc={{\n            comments: [description ? `@description ${transformers.jsStringEscape(description)}` : undefined].filter(Boolean),\n          }}\n        >\n          {finalOutput}\n        </Const>\n      </File.Source>\n      {inferTypeName && (\n        <File.Source name={inferTypeName} isExportable isIndexable isTypeOnly>\n          {typeName && (\n            <Type export name={inferTypeName}>\n              {typeName}\n            </Type>\n          )}\n          {!typeName && (\n            <Type export name={inferTypeName}>\n              {`z.infer<typeof ${name}>`}\n            </Type>\n          )}\n        </File.Source>\n      )}\n    </>\n  )\n}\n"],"mappings":"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"}