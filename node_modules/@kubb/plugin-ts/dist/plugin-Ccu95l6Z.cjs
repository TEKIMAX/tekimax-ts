const require_components = require('./components-ORNo_nJW.cjs');
let node_path = require("node:path");
node_path = require_components.__toESM(node_path);
let _kubb_core = require("@kubb/core");
let _kubb_core_transformers = require("@kubb/core/transformers");
_kubb_core_transformers = require_components.__toESM(_kubb_core_transformers);
let _kubb_plugin_oas = require("@kubb/plugin-oas");
let _kubb_core_hooks = require("@kubb/core/hooks");
let _kubb_fabric_core_parsers_typescript = require("@kubb/fabric-core/parsers/typescript");
let _kubb_plugin_oas_generators = require("@kubb/plugin-oas/generators");
let _kubb_plugin_oas_hooks = require("@kubb/plugin-oas/hooks");
let _kubb_plugin_oas_utils = require("@kubb/plugin-oas/utils");
let _kubb_react_fabric = require("@kubb/react-fabric");
let typescript = require("typescript");
typescript = require_components.__toESM(typescript);
let _kubb_react_fabric_jsx_runtime = require("@kubb/react-fabric/jsx-runtime");

//#region src/generators/typeGenerator.tsx
function printCombinedSchema({ name, schemas, pluginManager }) {
	const properties = {};
	if (schemas.response) properties["response"] = require_components.createUnionDeclaration({ nodes: schemas.responses.map((res) => {
		const identifier = pluginManager.resolveName({
			name: res.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		return require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}) });
	if (schemas.request) {
		const identifier = pluginManager.resolveName({
			name: schemas.request.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		properties["request"] = require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}
	if (schemas.pathParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.pathParams.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		properties["pathParams"] = require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}
	if (schemas.queryParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.queryParams.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		properties["queryParams"] = require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}
	if (schemas.headerParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.headerParams.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		properties["headerParams"] = require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}
	if (schemas.errors) properties["errors"] = require_components.createUnionDeclaration({ nodes: schemas.errors.map((error) => {
		const identifier = pluginManager.resolveName({
			name: error.name,
			pluginKey: [pluginTsName],
			type: "function"
		});
		return require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0);
	}) });
	return (0, _kubb_fabric_core_parsers_typescript.safePrint)(require_components.createTypeAliasDeclaration({
		name,
		type: require_components.createTypeLiteralNode(Object.keys(properties).map((key) => {
			const type = properties[key];
			if (!type) return;
			return require_components.createPropertySignature({
				name: _kubb_core_transformers.default.pascalCase(key),
				type
			});
		}).filter(Boolean)),
		modifiers: [require_components.modifiers.export]
	}));
}
function printRequestSchema({ baseName, operation, schemas, pluginManager }) {
	const name = pluginManager.resolveName({
		name: `${baseName} Request`,
		pluginKey: [pluginTsName],
		type: "type"
	});
	const results = [];
	const dataRequestProperties = [];
	if (schemas.request) {
		const identifier = pluginManager.resolveName({
			name: schemas.request.name,
			pluginKey: [pluginTsName],
			type: "type"
		});
		dataRequestProperties.push(require_components.createPropertySignature({
			name: "data",
			questionToken: true,
			type: require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0)
		}));
	} else dataRequestProperties.push(require_components.createPropertySignature({
		name: "data",
		questionToken: true,
		type: require_components.keywordTypeNodes.never
	}));
	if (schemas.pathParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.pathParams.name,
			pluginKey: [pluginTsName],
			type: "type"
		});
		dataRequestProperties.push(require_components.createPropertySignature({
			name: "pathParams",
			type: require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0)
		}));
	} else dataRequestProperties.push(require_components.createPropertySignature({
		name: "pathParams",
		questionToken: true,
		type: require_components.keywordTypeNodes.never
	}));
	if (schemas.queryParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.queryParams.name,
			pluginKey: [pluginTsName],
			type: "type"
		});
		dataRequestProperties.push(require_components.createPropertySignature({
			name: "queryParams",
			questionToken: true,
			type: require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0)
		}));
	} else dataRequestProperties.push(require_components.createPropertySignature({
		name: "queryParams",
		questionToken: true,
		type: require_components.keywordTypeNodes.never
	}));
	if (schemas.headerParams) {
		const identifier = pluginManager.resolveName({
			name: schemas.headerParams.name,
			pluginKey: [pluginTsName],
			type: "type"
		});
		dataRequestProperties.push(require_components.createPropertySignature({
			name: "headerParams",
			questionToken: true,
			type: require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0)
		}));
	} else dataRequestProperties.push(require_components.createPropertySignature({
		name: "headerParams",
		questionToken: true,
		type: require_components.keywordTypeNodes.never
	}));
	dataRequestProperties.push(require_components.createPropertySignature({
		name: "url",
		type: require_components.createUrlTemplateType(operation.path)
	}));
	const dataRequestNode = require_components.createTypeAliasDeclaration({
		name,
		type: require_components.createTypeLiteralNode(dataRequestProperties),
		modifiers: [require_components.modifiers.export]
	});
	results.push((0, _kubb_fabric_core_parsers_typescript.safePrint)(dataRequestNode));
	return results.join("\n\n");
}
function printResponseSchema({ baseName, schemas, pluginManager, unknownType }) {
	const results = [];
	const name = pluginManager.resolveName({
		name: `${baseName} ResponseData`,
		pluginKey: [pluginTsName],
		type: "type"
	});
	if (schemas.responses && schemas.responses.length > 0) {
		const responsesProperties = schemas.responses.map((res) => {
			const identifier = pluginManager.resolveName({
				name: res.name,
				pluginKey: [pluginTsName],
				type: "type"
			});
			return require_components.createPropertySignature({
				name: res.statusCode?.toString() ?? "default",
				type: require_components.createTypeReferenceNode(require_components.createIdentifier(identifier), void 0)
			});
		});
		const responsesNode = require_components.createTypeAliasDeclaration({
			name: `${baseName}Responses`,
			type: require_components.createTypeLiteralNode(responsesProperties),
			modifiers: [require_components.modifiers.export]
		});
		results.push((0, _kubb_fabric_core_parsers_typescript.safePrint)(responsesNode));
		const responseNode = require_components.createTypeAliasDeclaration({
			name,
			type: require_components.createIndexedAccessTypeNode(require_components.createTypeReferenceNode(require_components.createIdentifier(`${baseName}Responses`), void 0), require_components.createTypeOperatorNode(typescript.default.SyntaxKind.KeyOfKeyword, require_components.createTypeReferenceNode(require_components.createIdentifier(`${baseName}Responses`), void 0))),
			modifiers: [require_components.modifiers.export]
		});
		results.push((0, _kubb_fabric_core_parsers_typescript.safePrint)(responseNode));
	} else {
		const responseNode = require_components.createTypeAliasDeclaration({
			name,
			modifiers: [require_components.modifiers.export],
			type: require_components.getUnknownType(unknownType)
		});
		results.push((0, _kubb_fabric_core_parsers_typescript.safePrint)(responseNode));
	}
	return results.join("\n\n");
}
const typeGenerator = (0, _kubb_plugin_oas_generators.createReactGenerator)({
	name: "typescript",
	Operation({ operation, generator, plugin }) {
		const { options, options: { mapper, enumType, enumKeyCasing, syntaxType, optionalType, arrayType, unknownType } } = plugin;
		const mode = (0, _kubb_core_hooks.useMode)();
		const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
		const oas = (0, _kubb_plugin_oas_hooks.useOas)();
		const { getSchemas, getFile, getName, getGroup } = (0, _kubb_plugin_oas_hooks.useOperationManager)(generator);
		const schemaManager = (0, _kubb_plugin_oas_hooks.useSchemaManager)();
		const name = getName(operation, {
			type: "type",
			pluginKey: [pluginTsName]
		});
		const file = getFile(operation);
		const schemas = getSchemas(operation);
		const schemaGenerator = new _kubb_plugin_oas.SchemaGenerator(options, {
			fabric: generator.context.fabric,
			oas,
			events: generator.context.events,
			plugin,
			pluginManager,
			mode,
			override: options.override
		});
		const operationSchemas = [
			schemas.pathParams,
			schemas.queryParams,
			schemas.headerParams,
			schemas.statusCodes,
			schemas.request,
			schemas.response
		].flat().filter(Boolean);
		const mapOperationSchema = ({ name: name$1, schema, description, keysToOmit, ...options$1 }) => {
			const tree = schemaGenerator.parse({
				schema,
				name: name$1,
				parentName: null
			});
			const imports = schemaManager.getImports(tree);
			const group = options$1.operation ? getGroup(options$1.operation) : void 0;
			const type = {
				name: schemaManager.getName(name$1, { type: "type" }),
				typedName: schemaManager.getName(name$1, { type: "type" }),
				file: schemaManager.getFile(options$1.operationName || name$1, { group })
			};
			return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric_jsx_runtime.Fragment, { children: [mode === "split" && imports.map((imp) => /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
				root: file.path,
				path: imp.path,
				name: imp.name,
				isTypeOnly: true
			}, [
				name$1,
				imp.name,
				imp.path,
				imp.isTypeOnly
			].join("-"))), /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(require_components.Type, {
				name: type.name,
				typedName: type.typedName,
				description,
				tree,
				schema,
				mapper,
				enumType,
				enumKeyCasing,
				optionalType,
				arrayType,
				keysToOmit,
				syntaxType
			})] });
		};
		const responseName = schemaManager.getName(schemas.response.name, { type: "type" });
		const combinedSchemaName = operation.method === "get" ? `${name}Query` : `${name}Mutation`;
		return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File, {
			baseName: file.baseName,
			path: file.path,
			meta: file.meta,
			banner: (0, _kubb_plugin_oas_utils.getBanner)({
				oas,
				output: plugin.options.output,
				config: pluginManager.config
			}),
			footer: (0, _kubb_plugin_oas_utils.getFooter)({
				oas,
				output: plugin.options.output
			}),
			children: [operationSchemas.map(mapOperationSchema), generator.context.UNSTABLE_NAMING ? /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
				name: `${name}Request`,
				isExportable: true,
				isIndexable: true,
				isTypeOnly: true,
				children: printRequestSchema({
					baseName: name,
					operation,
					schemas,
					pluginManager
				})
			}), /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
				name: responseName,
				isExportable: true,
				isIndexable: true,
				isTypeOnly: true,
				children: printResponseSchema({
					baseName: name,
					schemas,
					pluginManager,
					unknownType
				})
			})] }) : /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
				name: combinedSchemaName,
				isExportable: true,
				isIndexable: true,
				isTypeOnly: true,
				children: printCombinedSchema({
					name: combinedSchemaName,
					schemas,
					pluginManager
				})
			})]
		});
	},
	Schema({ schema, plugin }) {
		const { options: { mapper, enumType, enumKeyCasing, syntaxType, optionalType, arrayType, output } } = plugin;
		const mode = (0, _kubb_core_hooks.useMode)();
		const oas = (0, _kubb_plugin_oas_hooks.useOas)();
		const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
		const { getName, getImports, getFile } = (0, _kubb_plugin_oas_hooks.useSchemaManager)();
		const imports = getImports(schema.tree);
		const schemaFromTree = schema.tree.find((item) => item.keyword === _kubb_plugin_oas.schemaKeywords.schema);
		let typedName = getName(schema.name, { type: "type" });
		if (enumType === "asConst" && schemaFromTree && (0, _kubb_plugin_oas.isKeyword)(schemaFromTree, _kubb_plugin_oas.schemaKeywords.enum)) typedName = typedName += "Key";
		const type = {
			name: getName(schema.name, { type: "function" }),
			typedName,
			file: getFile(schema.name)
		};
		return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File, {
			baseName: type.file.baseName,
			path: type.file.path,
			meta: type.file.meta,
			banner: (0, _kubb_plugin_oas_utils.getBanner)({
				oas,
				output,
				config: pluginManager.config
			}),
			footer: (0, _kubb_plugin_oas_utils.getFooter)({
				oas,
				output
			}),
			children: [mode === "split" && imports.map((imp) => /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Import, {
				root: type.file.path,
				path: imp.path,
				name: imp.name,
				isTypeOnly: true
			}, [
				schema.name,
				imp.path,
				imp.isTypeOnly
			].join("-"))), /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(require_components.Type, {
				name: type.name,
				typedName: type.typedName,
				description: schema.value.description,
				tree: schema.tree,
				schema: schema.value,
				mapper,
				enumType,
				enumKeyCasing,
				optionalType,
				arrayType,
				syntaxType
			})]
		});
	}
});

//#endregion
//#region src/plugin.ts
const pluginTsName = "plugin-ts";
const pluginTs = (0, _kubb_core.definePlugin)((options) => {
	const { output = {
		path: "types",
		barrelType: "named"
	}, group, exclude = [], include, override = [], enumType = "asConst", enumKeyCasing = "none", enumSuffix = "enum", dateType = "string", unknownType = "any", optionalType = "questionToken", arrayType = "array", emptySchemaType = unknownType, syntaxType = "type", transformers: transformers$1 = {}, mapper = {}, generators = [typeGenerator].filter(Boolean), contentType, UNSTABLE_NAMING } = options;
	return {
		name: pluginTsName,
		options: {
			output,
			transformers: transformers$1,
			dateType,
			optionalType,
			arrayType,
			enumType,
			enumKeyCasing,
			enumSuffix,
			unknownType,
			emptySchemaType,
			syntaxType,
			group,
			override,
			mapper,
			usedEnumNames: {}
		},
		pre: [_kubb_plugin_oas.pluginOasName],
		resolvePath(baseName, pathMode, options$1) {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			if ((pathMode ?? (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path))) === "single")
 /**
			* when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend
			* Other plugins then need to call addOrAppend instead of just add from the fileManager class
			*/
			return node_path.default.resolve(root, output.path);
			if (group && (options$1?.group?.path || options$1?.group?.tag)) {
				const groupName = group?.name ? group.name : (ctx) => {
					if (group?.type === "path") return `${ctx.group.split("/")[1]}`;
					return `${(0, _kubb_core_transformers.camelCase)(ctx.group)}Controller`;
				};
				return node_path.default.resolve(root, output.path, groupName({ group: group.type === "path" ? options$1.group.path : options$1.group.tag }), baseName);
			}
			return node_path.default.resolve(root, output.path, baseName);
		},
		resolveName(name, type) {
			const resolvedName = (0, _kubb_core_transformers.pascalCase)(name, { isFile: type === "file" });
			if (type) return transformers$1?.name?.(resolvedName, type) || resolvedName;
			return resolvedName;
		},
		async install() {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			const mode = (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path));
			const oas = await this.getOas();
			const schemaFiles = await new _kubb_plugin_oas.SchemaGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				include: void 0,
				override,
				mode,
				output: output.path
			}).build(...generators);
			await this.upsertFile(...schemaFiles);
			const operationFiles = await new _kubb_plugin_oas.OperationGenerator(this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				exclude,
				include,
				override,
				mode,
				UNSTABLE_NAMING
			}).build(...generators);
			await this.upsertFile(...operationFiles);
			const barrelFiles = await (0, _kubb_core.getBarrelFiles)(this.fabric.files, {
				type: output.barrelType ?? "named",
				root,
				output,
				meta: { pluginKey: this.plugin.key }
			});
			await this.upsertFile(...barrelFiles);
		}
	};
});

//#endregion
Object.defineProperty(exports, 'pluginTs', {
  enumerable: true,
  get: function () {
    return pluginTs;
  }
});
Object.defineProperty(exports, 'pluginTsName', {
  enumerable: true,
  get: function () {
    return pluginTsName;
  }
});
Object.defineProperty(exports, 'typeGenerator', {
  enumerable: true,
  get: function () {
    return typeGenerator;
  }
});
//# sourceMappingURL=plugin-Ccu95l6Z.cjs.map