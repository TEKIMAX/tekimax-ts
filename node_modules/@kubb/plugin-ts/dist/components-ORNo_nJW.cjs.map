{"version":3,"file":"components-ORNo_nJW.cjs","names":["ts","modifiers","questionToken","transformers","factory.createTypeLiteralNode","factory.createArrayDeclaration","factory.createOptionalTypeNode","factory.createRestTypeNode","factory.createArrayTypeNode","factory.createTupleTypeNode","factory.createTypeReferenceNode","factory.createUnionDeclaration","factory.createLiteralTypeNode","factory.createTrue","factory.createFalse","factory.createNumericLiteral","factory.createStringLiteral","factory.createIdentifier","factory.createIntersectionDeclaration","propertyName","name","schema","schemaKeywords","factory.createPropertySignature","factory.appendJSDocToNode","transformers","factory.createIndexSignature","schemaKeywords","SchemaGenerator","factory.createTypeReferenceNode","factory.createIdentifier","factory.createArrayTypeNode","factory.createUnionDeclaration","factory.createTypeDeclaration","factory.createOmitDeclaration","transformers","name","factory.createEnumDeclaration","File"],"sources":["../src/factory.ts","../src/parser.ts","../src/components/Type.tsx"],"sourcesContent":["import transformers from '@kubb/core/transformers'\nimport { orderBy } from 'natural-orderby'\nimport { isNumber } from 'remeda'\nimport ts from 'typescript'\n\nconst { SyntaxKind, factory } = ts\n\n// https://ts-ast-viewer.com/\n\nexport const modifiers = {\n  async: factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n  export: factory.createModifier(ts.SyntaxKind.ExportKeyword),\n  const: factory.createModifier(ts.SyntaxKind.ConstKeyword),\n  static: factory.createModifier(ts.SyntaxKind.StaticKeyword),\n} as const\n\nexport const syntaxKind = {\n  union: SyntaxKind.UnionType as 192,\n} as const\n\nexport function getUnknownType(unknownType: 'any' | 'unknown' | 'void' | undefined) {\n  if (unknownType === 'any') {\n    return keywordTypeNodes.any\n  }\n  if (unknownType === 'void') {\n    return keywordTypeNodes.void\n  }\n\n  return keywordTypeNodes.unknown\n}\nfunction isValidIdentifier(str: string): boolean {\n  if (!str.length || str.trim() !== str) {\n    return false\n  }\n  const node = ts.parseIsolatedEntityName(str, ts.ScriptTarget.Latest)\n\n  return !!node && node.kind === ts.SyntaxKind.Identifier && ts.identifierToKeywordKind(node.kind as unknown as ts.Identifier) === undefined\n}\n\nfunction propertyName(name: string | ts.PropertyName): ts.PropertyName {\n  if (typeof name === 'string') {\n    const isValid = isValidIdentifier(name)\n    return isValid ? factory.createIdentifier(name) : factory.createStringLiteral(name)\n  }\n  return name\n}\n\nconst questionToken = factory.createToken(ts.SyntaxKind.QuestionToken)\n\nexport function createQuestionToken(token?: boolean | ts.QuestionToken) {\n  if (!token) {\n    return undefined\n  }\n  if (token === true) {\n    return questionToken\n  }\n  return token\n}\n\nexport function createIntersectionDeclaration({ nodes, withParentheses }: { nodes: Array<ts.TypeNode>; withParentheses?: boolean }): ts.TypeNode | null {\n  if (!nodes.length) {\n    return null\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] || null\n  }\n\n  const node = factory.createIntersectionTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\n/**\n * Minimum nodes length of 2\n * @example `string & number`\n */\nexport function createTupleDeclaration({ nodes, withParentheses }: { nodes: Array<ts.TypeNode>; withParentheses?: boolean }): ts.TypeNode | null {\n  if (!nodes.length) {\n    return null\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] || null\n  }\n\n  const node = factory.createTupleTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\nexport function createArrayDeclaration({ nodes, arrayType = 'array' }: { nodes: Array<ts.TypeNode>; arrayType?: 'array' | 'generic' }): ts.TypeNode | null {\n  if (!nodes.length) {\n    return factory.createTupleTypeNode([])\n  }\n\n  if (nodes.length === 1) {\n    const node = nodes[0]\n    if (!node) {\n      return null\n    }\n    if (arrayType === 'generic') {\n      return factory.createTypeReferenceNode(factory.createIdentifier('Array'), [node])\n    }\n    return factory.createArrayTypeNode(node)\n  }\n\n  // For union types (multiple nodes), respect arrayType preference\n  const unionType = factory.createUnionTypeNode(nodes)\n  if (arrayType === 'generic') {\n    return factory.createTypeReferenceNode(factory.createIdentifier('Array'), [unionType])\n  }\n  // For array syntax with unions, we need parentheses: (string | number)[]\n  return factory.createArrayTypeNode(factory.createParenthesizedType(unionType))\n}\n\n/**\n * Minimum nodes length of 2\n * @example `string | number`\n */\nexport function createUnionDeclaration({ nodes, withParentheses }: { nodes: Array<ts.TypeNode>; withParentheses?: boolean }): ts.TypeNode {\n  if (!nodes.length) {\n    return keywordTypeNodes.any\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] as ts.TypeNode\n  }\n\n  const node = factory.createUnionTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\nexport function createPropertySignature({\n  readOnly,\n  modifiers = [],\n  name,\n  questionToken,\n  type,\n}: {\n  readOnly?: boolean\n  modifiers?: Array<ts.Modifier>\n  name: ts.PropertyName | string\n  questionToken?: ts.QuestionToken | boolean\n  type?: ts.TypeNode\n}) {\n  return factory.createPropertySignature(\n    [...modifiers, readOnly ? factory.createToken(ts.SyntaxKind.ReadonlyKeyword) : undefined].filter(Boolean),\n    propertyName(name),\n    createQuestionToken(questionToken),\n    type,\n  )\n}\n\nexport function createParameterSignature(\n  name: string | ts.BindingName,\n  {\n    modifiers,\n    dotDotDotToken,\n    questionToken,\n    type,\n    initializer,\n  }: {\n    decorators?: Array<ts.Decorator>\n    modifiers?: Array<ts.Modifier>\n    dotDotDotToken?: ts.DotDotDotToken\n    questionToken?: ts.QuestionToken | boolean\n    type?: ts.TypeNode\n    initializer?: ts.Expression\n  },\n): ts.ParameterDeclaration {\n  return factory.createParameterDeclaration(modifiers, dotDotDotToken, name, createQuestionToken(questionToken), type, initializer)\n}\n\nexport function createJSDoc({ comments }: { comments: string[] }) {\n  if (!comments.length) {\n    return null\n  }\n  return factory.createJSDocComment(\n    factory.createNodeArray(\n      comments.map((comment, i) => {\n        if (i === comments.length - 1) {\n          return factory.createJSDocText(comment)\n        }\n\n        return factory.createJSDocText(`${comment}\\n`)\n      }),\n    ),\n  )\n}\n\n/**\n * @link https://github.com/microsoft/TypeScript/issues/44151\n */\nexport function appendJSDocToNode<TNode extends ts.Node>({ node, comments }: { node: TNode; comments: Array<string | undefined> }) {\n  const filteredComments = comments.filter(Boolean)\n\n  if (!filteredComments.length) {\n    return node\n  }\n\n  const text = filteredComments.reduce((acc = '', comment = '') => {\n    return `${acc}\\n * ${comment.replaceAll('*/', '*\\\\/')}`\n  }, '*')\n\n  // Use the node directly instead of spreading to avoid creating Unknown nodes\n  // TypeScript's addSyntheticLeadingComment accepts the node as-is\n  return ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, `${text || '*'}\\n`, true)\n}\n\nexport function createIndexSignature(\n  type: ts.TypeNode,\n  {\n    modifiers,\n    indexName = 'key',\n    indexType = factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  }: {\n    indexName?: string\n    indexType?: ts.TypeNode\n    decorators?: Array<ts.Decorator>\n    modifiers?: Array<ts.Modifier>\n  } = {},\n) {\n  return factory.createIndexSignature(modifiers, [createParameterSignature(indexName, { type: indexType })], type)\n}\n\nexport function createTypeAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>\n  name: string | ts.Identifier\n  typeParameters?: Array<ts.TypeParameterDeclaration>\n  type: ts.TypeNode\n}) {\n  return factory.createTypeAliasDeclaration(modifiers, name, typeParameters, type)\n}\n\nexport function createInterfaceDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  members,\n}: {\n  modifiers?: Array<ts.Modifier>\n  name: string | ts.Identifier\n  typeParameters?: Array<ts.TypeParameterDeclaration>\n  members: Array<ts.TypeElement>\n}) {\n  return factory.createInterfaceDeclaration(modifiers, name, typeParameters, undefined, members)\n}\n\nexport function createTypeDeclaration({\n  syntax,\n  isExportable,\n  comments,\n  name,\n  type,\n}: {\n  syntax: 'type' | 'interface'\n  comments: Array<string | undefined>\n  isExportable?: boolean\n  name: string | ts.Identifier\n  type: ts.TypeNode\n}) {\n  if (syntax === 'interface' && 'members' in type) {\n    const node = createInterfaceDeclaration({\n      members: type.members as Array<ts.TypeElement>,\n      modifiers: isExportable ? [modifiers.export] : [],\n      name,\n      typeParameters: undefined,\n    })\n\n    return appendJSDocToNode({\n      node,\n      comments,\n    })\n  }\n\n  const node = createTypeAliasDeclaration({\n    type,\n    modifiers: isExportable ? [modifiers.export] : [],\n    name,\n    typeParameters: undefined,\n  })\n\n  return appendJSDocToNode({\n    node,\n    comments,\n  })\n}\n\nexport function createNamespaceDeclaration({ statements, name }: { name: string; statements: ts.Statement[] }) {\n  return factory.createModuleDeclaration(\n    [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n    factory.createIdentifier(name),\n    factory.createModuleBlock(statements),\n    ts.NodeFlags.Namespace,\n  )\n}\n\n/**\n * In { propertyName: string; name?: string } is `name` being used to make the type more unique when multiple same names are used.\n * @example `import { Pet as Cat } from './Pet'`\n */\nexport function createImportDeclaration({\n  name,\n  path,\n  isTypeOnly = false,\n  isNameSpace = false,\n}: {\n  name: string | Array<string | { propertyName: string; name?: string }>\n  path: string\n  isTypeOnly?: boolean\n  isNameSpace?: boolean\n}) {\n  if (!Array.isArray(name)) {\n    let importPropertyName: ts.Identifier | undefined = factory.createIdentifier(name)\n    let importName: ts.NamedImportBindings | undefined\n\n    if (isNameSpace) {\n      importPropertyName = undefined\n      importName = factory.createNamespaceImport(factory.createIdentifier(name))\n    }\n\n    return factory.createImportDeclaration(\n      undefined,\n      factory.createImportClause(isTypeOnly, importPropertyName, importName),\n      factory.createStringLiteral(path),\n      undefined,\n    )\n  }\n\n  // Sort the imports alphabetically for consistent output across platforms\n  const sortedName = orderBy(name, [(item) => (typeof item === 'object' ? item.propertyName : item)])\n\n  return factory.createImportDeclaration(\n    undefined,\n    factory.createImportClause(\n      isTypeOnly,\n      undefined,\n      factory.createNamedImports(\n        sortedName.map((item) => {\n          if (typeof item === 'object') {\n            const obj = item as { propertyName: string; name?: string }\n            if (obj.name) {\n              return factory.createImportSpecifier(false, factory.createIdentifier(obj.propertyName), factory.createIdentifier(obj.name))\n            }\n\n            return factory.createImportSpecifier(false, undefined, factory.createIdentifier(obj.propertyName))\n          }\n\n          return factory.createImportSpecifier(false, undefined, factory.createIdentifier(item))\n        }),\n      ),\n    ),\n    factory.createStringLiteral(path),\n    undefined,\n  )\n}\n\nexport function createExportDeclaration({\n  path,\n  asAlias,\n  isTypeOnly = false,\n  name,\n}: {\n  path: string\n  asAlias?: boolean\n  isTypeOnly?: boolean\n  name?: string | Array<ts.Identifier | string>\n}) {\n  if (name && !Array.isArray(name) && !asAlias) {\n    console.warn(`When using name as string, asAlias should be true ${name}`)\n  }\n\n  if (!Array.isArray(name)) {\n    const parsedName = name?.match(/^\\d/) ? `_${name?.slice(1)}` : name\n\n    return factory.createExportDeclaration(\n      undefined,\n      isTypeOnly,\n      asAlias && parsedName ? factory.createNamespaceExport(factory.createIdentifier(parsedName)) : undefined,\n      factory.createStringLiteral(path),\n      undefined,\n    )\n  }\n\n  // Sort the exports alphabetically for consistent output across platforms\n  const sortedName = orderBy(name, [(propertyName) => (typeof propertyName === 'string' ? propertyName : propertyName.text)])\n\n  return factory.createExportDeclaration(\n    undefined,\n    isTypeOnly,\n    factory.createNamedExports(\n      sortedName.map((propertyName) => {\n        return factory.createExportSpecifier(false, undefined, typeof propertyName === 'string' ? factory.createIdentifier(propertyName) : propertyName)\n      }),\n    ),\n    factory.createStringLiteral(path),\n    undefined,\n  )\n}\n\n/**\n * Apply casing transformation to enum keys\n */\nfunction applyEnumKeyCasing(key: string, casing: 'screamingSnakeCase' | 'snakeCase' | 'pascalCase' | 'camelCase' | 'none' = 'none'): string {\n  if (casing === 'none') {\n    return key\n  }\n  if (casing === 'screamingSnakeCase') {\n    return transformers.screamingSnakeCase(key)\n  }\n  if (casing === 'snakeCase') {\n    return transformers.snakeCase(key)\n  }\n  if (casing === 'pascalCase') {\n    return transformers.pascalCase(key)\n  }\n  if (casing === 'camelCase') {\n    return transformers.camelCase(key)\n  }\n  return key\n}\n\nexport function createEnumDeclaration({\n  type = 'enum',\n  name,\n  typeName,\n  enums,\n  enumKeyCasing = 'none',\n}: {\n  /**\n   * Choose to use `enum`, `asConst`, `asPascalConst`, `constEnum`, or `literal` for enums.\n   * - `enum`: TypeScript enum\n   * - `asConst`: const with camelCase name (e.g., `petType`)\n   * - `asPascalConst`: const with PascalCase name (e.g., `PetType`)\n   * - `constEnum`: const enum\n   * - `literal`: literal union type\n   * @default `'enum'`\n   */\n  type?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal' | 'inlineLiteral'\n  /**\n   * Enum name in camelCase.\n   */\n  name: string\n  /**\n   * Enum name in PascalCase.\n   */\n  typeName: string\n  enums: [key: string | number, value: string | number | boolean][]\n  /**\n   * Choose the casing for enum key names.\n   * @default 'none'\n   */\n  enumKeyCasing?: 'screamingSnakeCase' | 'snakeCase' | 'pascalCase' | 'camelCase' | 'none'\n}): [name: ts.Node | undefined, type: ts.Node] {\n  if (type === 'literal' || type === 'inlineLiteral') {\n    return [\n      undefined,\n      factory.createTypeAliasDeclaration(\n        [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n        factory.createIdentifier(typeName),\n        undefined,\n        factory.createUnionTypeNode(\n          enums\n            .map(([_key, value]) => {\n              if (isNumber(value)) {\n                return factory.createLiteralTypeNode(factory.createNumericLiteral(value?.toString()))\n              }\n\n              if (typeof value === 'boolean') {\n                return factory.createLiteralTypeNode(value ? factory.createTrue() : factory.createFalse())\n              }\n              if (value) {\n                return factory.createLiteralTypeNode(factory.createStringLiteral(value.toString()))\n              }\n\n              return undefined\n            })\n            .filter(Boolean),\n        ),\n      ),\n    ]\n  }\n\n  if (type === 'enum' || type === 'constEnum') {\n    return [\n      undefined,\n      factory.createEnumDeclaration(\n        [factory.createToken(ts.SyntaxKind.ExportKeyword), type === 'constEnum' ? factory.createToken(ts.SyntaxKind.ConstKeyword) : undefined].filter(Boolean),\n        factory.createIdentifier(typeName),\n        enums\n          .map(([key, value]) => {\n            let initializer: ts.Expression = factory.createStringLiteral(value?.toString())\n            const isExactNumber = Number.parseInt(value.toString(), 10) === value\n\n            if (isExactNumber && isNumber(Number.parseInt(value.toString(), 10))) {\n              initializer = factory.createNumericLiteral(value as number)\n            }\n\n            if (typeof value === 'boolean') {\n              initializer = value ? factory.createTrue() : factory.createFalse()\n            }\n\n            if (isNumber(Number.parseInt(key.toString(), 10))) {\n              const casingKey = applyEnumKeyCasing(`${typeName}_${key}`, enumKeyCasing)\n              return factory.createEnumMember(propertyName(casingKey), initializer)\n            }\n\n            if (key) {\n              const casingKey = applyEnumKeyCasing(key.toString(), enumKeyCasing)\n              return factory.createEnumMember(propertyName(casingKey), initializer)\n            }\n\n            return undefined\n          })\n          .filter(Boolean),\n      ),\n    ]\n  }\n\n  // used when using `as const` instead of an TypeScript enum.\n  const identifierName = type === 'asPascalConst' ? typeName : name\n\n  return [\n    factory.createVariableStatement(\n      [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      factory.createVariableDeclarationList(\n        [\n          factory.createVariableDeclaration(\n            factory.createIdentifier(identifierName),\n            undefined,\n            undefined,\n            factory.createAsExpression(\n              factory.createObjectLiteralExpression(\n                enums\n                  .map(([key, value]) => {\n                    let initializer: ts.Expression = factory.createStringLiteral(value?.toString())\n\n                    if (isNumber(value)) {\n                      // Error: Negative numbers should be created in combination with createPrefixUnaryExpression factory.\n                      // The method createNumericLiteral only accepts positive numbers\n                      // or those combined with createPrefixUnaryExpression.\n                      // Therefore, we need to ensure that the number is not negative.\n                      if (value < 0) {\n                        initializer = factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, factory.createNumericLiteral(Math.abs(value)))\n                      } else {\n                        initializer = factory.createNumericLiteral(value)\n                      }\n                    }\n\n                    if (typeof value === 'boolean') {\n                      initializer = value ? factory.createTrue() : factory.createFalse()\n                    }\n\n                    if (key) {\n                      const casingKey = applyEnumKeyCasing(key.toString(), enumKeyCasing)\n                      return factory.createPropertyAssignment(propertyName(casingKey), initializer)\n                    }\n\n                    return undefined\n                  })\n                  .filter(Boolean),\n                true,\n              ),\n              factory.createTypeReferenceNode(factory.createIdentifier('const'), undefined),\n            ),\n          ),\n        ],\n        ts.NodeFlags.Const,\n      ),\n    ),\n    factory.createTypeAliasDeclaration(\n      [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      factory.createIdentifier(typeName),\n      undefined,\n      factory.createIndexedAccessTypeNode(\n        factory.createParenthesizedType(factory.createTypeQueryNode(factory.createIdentifier(identifierName), undefined)),\n        factory.createTypeOperatorNode(ts.SyntaxKind.KeyOfKeyword, factory.createTypeQueryNode(factory.createIdentifier(identifierName), undefined)),\n      ),\n    ),\n  ]\n}\n\nexport function createOmitDeclaration({ keys, type, nonNullable }: { keys: Array<string> | string; type: ts.TypeNode; nonNullable?: boolean }) {\n  const node = nonNullable ? factory.createTypeReferenceNode(factory.createIdentifier('NonNullable'), [type]) : type\n\n  if (Array.isArray(keys)) {\n    return factory.createTypeReferenceNode(factory.createIdentifier('Omit'), [\n      node,\n      factory.createUnionTypeNode(\n        keys.map((key) => {\n          return factory.createLiteralTypeNode(factory.createStringLiteral(key))\n        }),\n      ),\n    ])\n  }\n\n  return factory.createTypeReferenceNode(factory.createIdentifier('Omit'), [node, factory.createLiteralTypeNode(factory.createStringLiteral(keys))])\n}\n\nexport const keywordTypeNodes = {\n  any: factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  unknown: factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n  void: factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),\n  number: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  integer: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  object: factory.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword),\n  string: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  boolean: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),\n  undefined: factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n  null: factory.createLiteralTypeNode(factory.createToken(ts.SyntaxKind.NullKeyword)),\n  never: factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword),\n} as const\n\n/**\n * Converts a path like '/pet/{petId}/uploadImage' to a template literal type\n * like `/pet/${string}/uploadImage`\n */\nexport function createUrlTemplateType(path: string): ts.TypeNode {\n  // If no parameters, return literal string type\n  if (!path.includes('{')) {\n    return factory.createLiteralTypeNode(factory.createStringLiteral(path))\n  }\n\n  // Split path by parameter placeholders, e.g. '/pet/{petId}/upload' -> ['/pet/', 'petId', '/upload']\n  const segments = path.split(/(\\{[^}]+\\})/)\n\n  // Separate static parts from parameter placeholders\n  const parts: string[] = []\n  const parameterIndices: number[] = []\n\n  segments.forEach((segment) => {\n    if (segment.startsWith('{') && segment.endsWith('}')) {\n      // This is a parameter placeholder\n      parameterIndices.push(parts.length)\n      parts.push(segment) // Will be replaced with ${string}\n    } else if (segment) {\n      // This is a static part\n      parts.push(segment)\n    }\n  })\n\n  // Build template literal type\n  // Template literal structure: head + templateSpans[]\n  // For '/pet/{petId}/upload': head = '/pet/', spans = [{ type: string, literal: '/upload' }]\n\n  const head = ts.factory.createTemplateHead(parts[0] || '')\n  const templateSpans: ts.TemplateLiteralTypeSpan[] = []\n\n  parameterIndices.forEach((paramIndex, i) => {\n    const isLast = i === parameterIndices.length - 1\n    const nextPart = parts[paramIndex + 1] || ''\n\n    const literal = isLast ? ts.factory.createTemplateTail(nextPart) : ts.factory.createTemplateMiddle(nextPart)\n\n    templateSpans.push(ts.factory.createTemplateLiteralTypeSpan(keywordTypeNodes.string, literal))\n  })\n\n  return ts.factory.createTemplateLiteralType(head, templateSpans)\n}\n\nexport const createTypeLiteralNode = factory.createTypeLiteralNode\n\nexport const createTypeReferenceNode = factory.createTypeReferenceNode\nexport const createNumericLiteral = factory.createNumericLiteral\nexport const createStringLiteral = factory.createStringLiteral\n\nexport const createArrayTypeNode = factory.createArrayTypeNode\nexport const createParenthesizedType = factory.createParenthesizedType\n\nexport const createLiteralTypeNode = factory.createLiteralTypeNode\nexport const createNull = factory.createNull\nexport const createIdentifier = factory.createIdentifier\n\nexport const createOptionalTypeNode = factory.createOptionalTypeNode\nexport const createTupleTypeNode = factory.createTupleTypeNode\nexport const createRestTypeNode = factory.createRestTypeNode\nexport const createTrue = factory.createTrue\nexport const createFalse = factory.createFalse\nexport const createIndexedAccessTypeNode = factory.createIndexedAccessTypeNode\nexport const createTypeOperatorNode = factory.createTypeOperatorNode\n","import transformers from '@kubb/core/transformers'\nimport type { SchemaKeywordMapper, SchemaMapper } from '@kubb/plugin-oas'\nimport { createParser, isKeyword, schemaKeywords } from '@kubb/plugin-oas'\nimport type ts from 'typescript'\nimport * as factory from './factory.ts'\n\nexport const typeKeywordMapper = {\n  any: () => factory.keywordTypeNodes.any,\n  unknown: () => factory.keywordTypeNodes.unknown,\n  void: () => factory.keywordTypeNodes.void,\n  number: () => factory.keywordTypeNodes.number,\n  integer: () => factory.keywordTypeNodes.number,\n  object: (nodes?: ts.TypeElement[]) => {\n    if (!nodes || !nodes.length) {\n      return factory.keywordTypeNodes.object\n    }\n\n    return factory.createTypeLiteralNode(nodes)\n  },\n  string: () => factory.keywordTypeNodes.string,\n  boolean: () => factory.keywordTypeNodes.boolean,\n  undefined: () => factory.keywordTypeNodes.undefined,\n  nullable: undefined,\n  null: () => factory.keywordTypeNodes.null,\n  nullish: undefined,\n  array: (nodes?: ts.TypeNode[], arrayType?: 'array' | 'generic') => {\n    if (!nodes) {\n      return undefined\n    }\n\n    return factory.createArrayDeclaration({ nodes, arrayType })\n  },\n  tuple: (nodes?: ts.TypeNode[], rest?: ts.TypeNode, min?: number, max?: number) => {\n    if (!nodes) {\n      return undefined\n    }\n\n    if (max) {\n      nodes = nodes.slice(0, max)\n\n      if (nodes.length < max && rest) {\n        nodes = [...nodes, ...Array(max - nodes.length).fill(rest)]\n      }\n    }\n\n    if (min) {\n      nodes = nodes.map((node, index) => (index >= min ? factory.createOptionalTypeNode(node) : node))\n    }\n\n    if (typeof max === 'undefined' && rest) {\n      nodes.push(factory.createRestTypeNode(factory.createArrayTypeNode(rest)))\n    }\n\n    return factory.createTupleTypeNode(nodes)\n  },\n  enum: (name?: string) => {\n    if (!name) {\n      return undefined\n    }\n\n    return factory.createTypeReferenceNode(name, undefined)\n  },\n  union: (nodes?: ts.TypeNode[]) => {\n    if (!nodes) {\n      return undefined\n    }\n\n    return factory.createUnionDeclaration({\n      withParentheses: true,\n      nodes,\n    })\n  },\n  const: (name?: string | number | boolean, format?: 'string' | 'number' | 'boolean') => {\n    if (name === null || name === undefined || name === '') {\n      return undefined\n    }\n\n    if (format === 'boolean') {\n      if (name === true) {\n        return factory.createLiteralTypeNode(factory.createTrue())\n      }\n\n      return factory.createLiteralTypeNode(factory.createFalse())\n    }\n\n    if (format === 'number' && typeof name === 'number') {\n      return factory.createLiteralTypeNode(factory.createNumericLiteral(name))\n    }\n\n    return factory.createLiteralTypeNode(factory.createStringLiteral(name.toString()))\n  },\n  datetime: () => factory.keywordTypeNodes.string,\n  date: (type: 'date' | 'string' = 'string') =>\n    type === 'string' ? factory.keywordTypeNodes.string : factory.createTypeReferenceNode(factory.createIdentifier('Date')),\n  time: (type: 'date' | 'string' = 'string') =>\n    type === 'string' ? factory.keywordTypeNodes.string : factory.createTypeReferenceNode(factory.createIdentifier('Date')),\n  uuid: () => factory.keywordTypeNodes.string,\n  url: () => factory.keywordTypeNodes.string,\n  default: undefined,\n  and: (nodes?: ts.TypeNode[]) => {\n    if (!nodes) {\n      return undefined\n    }\n\n    return factory.createIntersectionDeclaration({\n      withParentheses: true,\n      nodes,\n    })\n  },\n  describe: undefined,\n  min: undefined,\n  max: undefined,\n  optional: undefined,\n  matches: () => factory.keywordTypeNodes.string,\n  email: () => factory.keywordTypeNodes.string,\n  firstName: undefined,\n  lastName: undefined,\n  password: undefined,\n  phone: undefined,\n  readOnly: undefined,\n  writeOnly: undefined,\n  ref: (propertyName?: string) => {\n    if (!propertyName) {\n      return undefined\n    }\n\n    return factory.createTypeReferenceNode(propertyName, undefined)\n  },\n  blob: () => factory.createTypeReferenceNode('Blob', []),\n  deprecated: undefined,\n  example: undefined,\n  schema: undefined,\n  catchall: undefined,\n  name: undefined,\n  interface: undefined,\n  exclusiveMaximum: undefined,\n  exclusiveMinimum: undefined,\n} satisfies SchemaMapper<ts.TypeNode | null | undefined>\n\ntype ParserOptions = {\n  /**\n   * @default `'questionToken'`\n   */\n  optionalType: 'questionToken' | 'undefined' | 'questionTokenAndUndefined'\n  /**\n   * @default `'array'`\n   */\n  arrayType: 'array' | 'generic'\n  /**\n   * Choose to use `enum`, `asConst`, `asPascalConst`, `constEnum`, `literal`, or `inlineLiteral` for enums.\n   * - `enum`: TypeScript enum\n   * - `asConst`: const with camelCase name (e.g., `petType`)\n   * - `asPascalConst`: const with PascalCase name (e.g., `PetType`)\n   * - `constEnum`: const enum\n   * - `literal`: literal union type\n   * - `inlineLiteral`: inline enum values directly into the type (default in v5)\n   * @default `'asConst'`\n   * @note In Kubb v5, `inlineLiteral` becomes the default.\n   */\n  enumType: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal' | 'inlineLiteral'\n  mapper?: Record<string, ts.PropertySignature>\n}\n\n/**\n * Recursively parses a schema tree node into a corresponding TypeScript AST node.\n *\n * Maps OpenAPI schema keywords to TypeScript AST nodes using the `typeKeywordMapper`, handling complex types such as unions, intersections, arrays, tuples (with optional/rest elements and length constraints), enums, constants, references, and objects with property modifiers and documentation annotations.\n *\n * @param current - The schema node to parse.\n * @param siblings - Sibling schema nodes, used for context in certain mappings.\n * @param name - The name of the schema or property being parsed.\n * @param options - Parsing options controlling output style, property handling, and custom mappers.\n * @returns The generated TypeScript AST node, or `undefined` if the schema keyword is not mapped.\n */\nexport const parse = createParser<ts.Node | null, ParserOptions>({\n  mapper: typeKeywordMapper,\n  handlers: {\n    union(tree, options) {\n      const { current, schema, name } = tree\n\n      return typeKeywordMapper.union(\n        current.args.map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options)).filter(Boolean) as ts.TypeNode[],\n      )\n    },\n    and(tree, options) {\n      const { current, schema, name } = tree\n\n      return typeKeywordMapper.and(\n        current.args.map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options)).filter(Boolean) as ts.TypeNode[],\n      )\n    },\n    array(tree, options) {\n      const { current, schema, name } = tree\n\n      return typeKeywordMapper.array(\n        current.args.items.map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options)).filter(Boolean) as ts.TypeNode[],\n        options.arrayType,\n      )\n    },\n    enum(tree, options) {\n      const { current } = tree\n\n      // If enumType is 'inlineLiteral', generate the literal union inline instead of a type reference\n      if (options.enumType === 'inlineLiteral') {\n        const enumValues = current.args.items\n          .map((item) => item.value)\n          .filter((value): value is string | number | boolean => value !== undefined && value !== null)\n          .map((value) => {\n            const format = typeof value === 'number' ? 'number' : typeof value === 'boolean' ? 'boolean' : 'string'\n            return typeKeywordMapper.const(value, format)\n          })\n          .filter(Boolean) as ts.TypeNode[]\n\n        return typeKeywordMapper.union(enumValues)\n      }\n\n      // Adding suffix to enum (see https://github.com/kubb-labs/kubb/issues/1873)\n      return typeKeywordMapper.enum(options.enumType === 'asConst' ? `${current.args.typeName}Key` : current.args.typeName)\n    },\n    ref(tree, _options) {\n      const { current } = tree\n\n      return typeKeywordMapper.ref(current.args.name)\n    },\n    blob() {\n      return typeKeywordMapper.blob()\n    },\n    tuple(tree, options) {\n      const { current, schema, name } = tree\n\n      return typeKeywordMapper.tuple(\n        current.args.items.map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options)).filter(Boolean) as ts.TypeNode[],\n        current.args.rest &&\n          ((this.parse({ schema, parent: current, name, current: current.args.rest, siblings: [] }, options) ?? undefined) as ts.TypeNode | undefined),\n        current.args.min,\n        current.args.max,\n      )\n    },\n    const(tree, _options) {\n      const { current } = tree\n\n      return typeKeywordMapper.const(current.args.name, current.args.format)\n    },\n    object(tree, options) {\n      const { current, schema, name } = tree\n\n      const properties = Object.entries(current.args?.properties || {})\n        .filter((item) => {\n          const schemas = item[1]\n          return schemas && typeof schemas.map === 'function'\n        })\n        .map(([name, schemas]) => {\n          const nameSchema = schemas.find((schema) => schema.keyword === schemaKeywords.name) as SchemaKeywordMapper['name']\n          const mappedName = nameSchema?.args || name\n\n          // custom mapper(pluginOptions)\n          // Use Object.hasOwn to avoid matching inherited properties like 'toString', 'valueOf', etc.\n          if (options.mapper && Object.hasOwn(options.mapper, mappedName)) {\n            return options.mapper[mappedName]\n          }\n\n          const isNullish = schemas.some((schema) => schema.keyword === schemaKeywords.nullish)\n          const isNullable = schemas.some((schema) => schema.keyword === schemaKeywords.nullable)\n          const isOptional = schemas.some((schema) => schema.keyword === schemaKeywords.optional)\n          const isReadonly = schemas.some((schema) => schema.keyword === schemaKeywords.readOnly)\n          const describeSchema = schemas.find((schema) => schema.keyword === schemaKeywords.describe) as SchemaKeywordMapper['describe'] | undefined\n          const deprecatedSchema = schemas.find((schema) => schema.keyword === schemaKeywords.deprecated) as SchemaKeywordMapper['deprecated'] | undefined\n          const defaultSchema = schemas.find((schema) => schema.keyword === schemaKeywords.default) as SchemaKeywordMapper['default'] | undefined\n          const exampleSchema = schemas.find((schema) => schema.keyword === schemaKeywords.example) as SchemaKeywordMapper['example'] | undefined\n          const schemaSchema = schemas.find((schema) => schema.keyword === schemaKeywords.schema) as SchemaKeywordMapper['schema'] | undefined\n          const minSchema = schemas.find((schema) => schema.keyword === schemaKeywords.min) as SchemaKeywordMapper['min'] | undefined\n          const maxSchema = schemas.find((schema) => schema.keyword === schemaKeywords.max) as SchemaKeywordMapper['max'] | undefined\n          const matchesSchema = schemas.find((schema) => schema.keyword === schemaKeywords.matches) as SchemaKeywordMapper['matches'] | undefined\n\n          let type = schemas\n            .map((it) =>\n              this.parse(\n                {\n                  schema,\n                  parent: current,\n                  name,\n                  current: it,\n                  siblings: schemas,\n                },\n                options,\n              ),\n            )\n            .filter(Boolean)[0] as ts.TypeNode\n\n          if (isNullable) {\n            type = factory.createUnionDeclaration({\n              nodes: [type, factory.keywordTypeNodes.null],\n            }) as ts.TypeNode\n          }\n\n          if (isNullish && ['undefined', 'questionTokenAndUndefined'].includes(options.optionalType as string)) {\n            type = factory.createUnionDeclaration({\n              nodes: [type, factory.keywordTypeNodes.undefined],\n            }) as ts.TypeNode\n          }\n\n          if (isOptional && ['undefined', 'questionTokenAndUndefined'].includes(options.optionalType as string)) {\n            type = factory.createUnionDeclaration({\n              nodes: [type, factory.keywordTypeNodes.undefined],\n            }) as ts.TypeNode\n          }\n\n          const propertyNode = factory.createPropertySignature({\n            questionToken: isOptional || isNullish ? ['questionToken', 'questionTokenAndUndefined'].includes(options.optionalType as string) : false,\n            name: mappedName,\n            type,\n            readOnly: isReadonly,\n          })\n\n          return factory.appendJSDocToNode({\n            node: propertyNode,\n            comments: [\n              describeSchema ? `@description ${transformers.jsStringEscape(describeSchema.args)}` : undefined,\n              deprecatedSchema ? '@deprecated' : undefined,\n              minSchema ? `@minLength ${minSchema.args}` : undefined,\n              maxSchema ? `@maxLength ${maxSchema.args}` : undefined,\n              matchesSchema ? `@pattern ${matchesSchema.args}` : undefined,\n              defaultSchema ? `@default ${defaultSchema.args}` : undefined,\n              exampleSchema ? `@example ${exampleSchema.args}` : undefined,\n              schemaSchema?.args?.type || schemaSchema?.args?.format\n                ? [`@type ${schemaSchema?.args?.type || 'unknown'}${!isOptional ? '' : ' | undefined'}`, schemaSchema?.args?.format].filter(Boolean).join(', ')\n                : undefined,\n            ].filter(Boolean),\n          })\n        })\n\n      let additionalProperties: any\n\n      if (current.args?.additionalProperties?.length) {\n        let additionalPropertiesType = current.args.additionalProperties\n          .map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options))\n          .filter(Boolean)\n          .at(0) as ts.TypeNode\n\n        const isNullable = current.args?.additionalProperties.some((schema) => isKeyword(schema, schemaKeywords.nullable))\n        if (isNullable) {\n          additionalPropertiesType = factory.createUnionDeclaration({\n            nodes: [additionalPropertiesType, factory.keywordTypeNodes.null],\n          }) as ts.TypeNode\n        }\n\n        // When there are typed properties alongside additionalProperties, use 'unknown' type\n        // for the index signature to avoid TS2411 errors (index signature type conflicts with property types).\n        // This occurs commonly in QueryParams where some params are typed (enums, objects) and\n        // others are dynamic (additionalProperties with explode=true).\n        const hasTypedProperties = properties.length > 0\n        const indexSignatureType = hasTypedProperties ? factory.keywordTypeNodes.unknown : additionalPropertiesType\n\n        additionalProperties = factory.createIndexSignature(indexSignatureType)\n      }\n\n      let patternProperties: ts.TypeNode | ts.IndexSignatureDeclaration | undefined\n\n      if (current.args?.patternProperties) {\n        const allPatternSchemas = Object.values(current.args.patternProperties).flat()\n\n        if (allPatternSchemas.length > 0) {\n          patternProperties = allPatternSchemas\n            .map((it) => this.parse({ schema, parent: current, name, current: it, siblings: [] }, options))\n            .filter(Boolean)\n            .at(0) as ts.TypeNode\n\n          const isNullable = allPatternSchemas.some((schema) => isKeyword(schema, schemaKeywords.nullable))\n          if (isNullable) {\n            patternProperties = factory.createUnionDeclaration({\n              nodes: [patternProperties, factory.keywordTypeNodes.null],\n            }) as ts.TypeNode\n          }\n\n          patternProperties = factory.createIndexSignature(patternProperties)\n        }\n      }\n\n      return typeKeywordMapper.object([...properties, additionalProperties, patternProperties].filter(Boolean))\n    },\n    datetime() {\n      return typeKeywordMapper.datetime()\n    },\n    date(tree) {\n      const { current } = tree\n\n      return typeKeywordMapper.date(current.args.type)\n    },\n    time(tree) {\n      const { current } = tree\n\n      return typeKeywordMapper.time(current.args.type)\n    },\n  },\n})\n","import transformers from '@kubb/core/transformers'\nimport { safePrint } from '@kubb/fabric-core/parsers/typescript'\nimport type { SchemaObject } from '@kubb/oas'\nimport { isKeyword, type Schema, SchemaGenerator, schemaKeywords } from '@kubb/plugin-oas'\nimport { File } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport type ts from 'typescript'\nimport * as factory from '../factory.ts'\nimport { parse, typeKeywordMapper } from '../parser.ts'\nimport type { PluginTs } from '../types.ts'\n\ntype Props = {\n  name: string\n  typedName: string\n  schema: SchemaObject\n  tree: Array<Schema>\n  optionalType: PluginTs['resolvedOptions']['optionalType']\n  arrayType: PluginTs['resolvedOptions']['arrayType']\n  enumType: PluginTs['resolvedOptions']['enumType']\n  enumKeyCasing: PluginTs['resolvedOptions']['enumKeyCasing']\n  mapper: PluginTs['resolvedOptions']['mapper']\n  syntaxType: PluginTs['resolvedOptions']['syntaxType']\n  description?: string\n  keysToOmit?: string[]\n}\n\nexport function Type({\n  name,\n  typedName,\n  tree,\n  keysToOmit,\n  schema,\n  optionalType,\n  arrayType,\n  syntaxType,\n  enumType,\n  enumKeyCasing,\n  mapper,\n  description,\n}: Props): FabricReactNode {\n  const typeNodes: ts.Node[] = []\n\n  if (!tree.length) {\n    return ''\n  }\n\n  const schemaFromTree = tree.find((item) => item.keyword === schemaKeywords.schema)\n  const enumSchemas = SchemaGenerator.deepSearch(tree, schemaKeywords.enum)\n\n  let type =\n    (tree\n      .map((current, _index, siblings) =>\n        parse(\n          { name, schema, parent: undefined, current, siblings },\n          {\n            optionalType,\n            arrayType,\n            enumType,\n            mapper,\n          },\n        ),\n      )\n      .filter(Boolean)\n      .at(0) as ts.TypeNode) || typeKeywordMapper.undefined()\n\n  // Add a \"Key\" suffix to avoid collisions where necessary\n  if (enumType === 'asConst' && enumSchemas.length > 0) {\n    const isDirectEnum = schema.type === 'array' && schema.items !== undefined\n    const isEnumOnly = 'enum' in schema && schema.enum\n\n    if (isDirectEnum || isEnumOnly) {\n      const enumSchema = enumSchemas[0]!\n      const typeNameWithKey = `${enumSchema.args.typeName}Key`\n\n      type = factory.createTypeReferenceNode(typeNameWithKey)\n\n      if (schema.type === 'array') {\n        if (arrayType === 'generic') {\n          type = factory.createTypeReferenceNode(factory.createIdentifier('Array'), [type])\n        } else {\n          type = factory.createArrayTypeNode(type)\n        }\n      }\n    }\n  }\n\n  if (schemaFromTree && isKeyword(schemaFromTree, schemaKeywords.schema)) {\n    const isNullish = tree.some((item) => item.keyword === schemaKeywords.nullish)\n    const isNullable = tree.some((item) => item.keyword === schemaKeywords.nullable)\n    const isOptional = tree.some((item) => item.keyword === schemaKeywords.optional)\n\n    if (isNullable) {\n      type = factory.createUnionDeclaration({\n        nodes: [type, factory.keywordTypeNodes.null],\n      }) as ts.TypeNode\n    }\n\n    if (isNullish && ['undefined', 'questionTokenAndUndefined'].includes(optionalType as string)) {\n      type = factory.createUnionDeclaration({\n        nodes: [type, factory.keywordTypeNodes.undefined],\n      }) as ts.TypeNode\n    }\n\n    if (isOptional && ['undefined', 'questionTokenAndUndefined'].includes(optionalType as string)) {\n      type = factory.createUnionDeclaration({\n        nodes: [type, factory.keywordTypeNodes.undefined],\n      }) as ts.TypeNode\n    }\n  }\n\n  const useTypeGeneration = syntaxType === 'type' || [factory.syntaxKind.union].includes(type.kind as typeof factory.syntaxKind.union) || !!keysToOmit?.length\n\n  typeNodes.push(\n    factory.createTypeDeclaration({\n      name,\n      isExportable: true,\n      type: keysToOmit?.length\n        ? factory.createOmitDeclaration({\n            keys: keysToOmit,\n            type,\n            nonNullable: true,\n          })\n        : type,\n      syntax: useTypeGeneration ? 'type' : 'interface',\n      comments: [\n        description ? `@description ${transformers.jsStringEscape(description)}` : undefined,\n        schema.deprecated ? '@deprecated' : undefined,\n        schema.minLength ? `@minLength ${schema.minLength}` : undefined,\n        schema.maxLength ? `@maxLength ${schema.maxLength}` : undefined,\n        schema.pattern ? `@pattern ${schema.pattern}` : undefined,\n        schema.default ? `@default ${schema.default}` : undefined,\n        schema.example ? `@example ${schema.example}` : undefined,\n      ],\n    }),\n  )\n\n  const enums = [...new Set(enumSchemas)].map((enumSchema) => {\n    const name = enumType === 'asPascalConst' ? transformers.pascalCase(enumSchema.args.name) : transformers.camelCase(enumSchema.args.name)\n    const typeName = enumType === 'asConst' ? `${enumSchema.args.typeName}Key` : enumSchema.args.typeName\n\n    const [nameNode, typeNode] = factory.createEnumDeclaration({\n      name,\n      typeName,\n      enums: enumSchema.args.items\n        .map((item) => (item.value === undefined ? undefined : [transformers.trimQuotes(item.name?.toString()), item.value]))\n        .filter(Boolean) as unknown as Array<[string, string]>,\n      type: enumType,\n      enumKeyCasing,\n    })\n\n    return {\n      nameNode,\n      typeNode,\n      name,\n      typeName,\n    }\n  })\n\n  // Skip enum exports when using inlineLiteral\n  const shouldExportEnums = enumType !== 'inlineLiteral'\n  const shouldExportType = enumType === 'inlineLiteral' || enums.every((item) => item.typeName !== name)\n\n  return (\n    <>\n      {shouldExportEnums &&\n        enums.map(({ name, nameNode, typeName, typeNode }) => (\n          <>\n            {nameNode && (\n              <File.Source name={name} isExportable isIndexable>\n                {safePrint(nameNode)}\n              </File.Source>\n            )}\n            {\n              <File.Source\n                name={typeName}\n                isIndexable\n                isExportable={['enum', 'asConst', 'asPascalConst', 'constEnum', 'literal', undefined].includes(enumType)}\n                isTypeOnly={['asConst', 'asPascalConst', 'literal', undefined].includes(enumType)}\n              >\n                {safePrint(typeNode)}\n              </File.Source>\n            }\n          </>\n        ))}\n      {shouldExportType && (\n        <File.Source name={typedName} isTypeOnly isExportable isIndexable>\n          {safePrint(...typeNodes)}\n        </File.Source>\n      )}\n    </>\n  )\n}\n"],"mappings":"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"}