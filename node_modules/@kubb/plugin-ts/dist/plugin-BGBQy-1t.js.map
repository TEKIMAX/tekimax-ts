{"version":3,"file":"plugin-BGBQy-1t.js","names":["factory.createUnionDeclaration","factory.createTypeReferenceNode","factory.createIdentifier","factory.createTypeAliasDeclaration","factory.createTypeLiteralNode","factory.createPropertySignature","factory.createIndexedAccessTypeNode","factory.createTypeOperatorNode","options","name","options","transformers"],"sources":["../src/generators/typeGenerator.tsx","../src/plugin.ts"],"sourcesContent":["import type { PluginManager } from '@kubb/core'\nimport { useMode, usePluginManager } from '@kubb/core/hooks'\nimport transformers from '@kubb/core/transformers'\nimport { safePrint } from '@kubb/fabric-core/parsers/typescript'\nimport type { Operation } from '@kubb/oas'\nimport { isKeyword, type OperationSchemas, type OperationSchema as OperationSchemaType, SchemaGenerator, schemaKeywords } from '@kubb/plugin-oas'\nimport { createReactGenerator } from '@kubb/plugin-oas/generators'\nimport { useOas, useOperationManager, useSchemaManager } from '@kubb/plugin-oas/hooks'\nimport { getBanner, getFooter } from '@kubb/plugin-oas/utils'\nimport { File } from '@kubb/react-fabric'\nimport ts from 'typescript'\nimport { Type } from '../components'\nimport * as factory from '../factory.ts'\nimport { createUrlTemplateType, getUnknownType, keywordTypeNodes } from '../factory.ts'\nimport { pluginTsName } from '../plugin.ts'\nimport type { PluginTs } from '../types'\n\nfunction printCombinedSchema({ name, schemas, pluginManager }: { name: string; schemas: OperationSchemas; pluginManager: PluginManager }): string {\n  const properties: Record<string, ts.TypeNode> = {}\n\n  if (schemas.response) {\n    properties['response'] = factory.createUnionDeclaration({\n      nodes: schemas.responses.map((res) => {\n        const identifier = pluginManager.resolveName({\n          name: res.name,\n          pluginKey: [pluginTsName],\n          type: 'function',\n        })\n\n        return factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n      }),\n    })!\n  }\n\n  if (schemas.request) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.request.name,\n      pluginKey: [pluginTsName],\n      type: 'function',\n    })\n    properties['request'] = factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n  }\n\n  if (schemas.pathParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.pathParams.name,\n      pluginKey: [pluginTsName],\n      type: 'function',\n    })\n    properties['pathParams'] = factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n  }\n\n  if (schemas.queryParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.queryParams.name,\n      pluginKey: [pluginTsName],\n      type: 'function',\n    })\n    properties['queryParams'] = factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n  }\n\n  if (schemas.headerParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.headerParams.name,\n      pluginKey: [pluginTsName],\n      type: 'function',\n    })\n    properties['headerParams'] = factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n  }\n\n  if (schemas.errors) {\n    properties['errors'] = factory.createUnionDeclaration({\n      nodes: schemas.errors.map((error) => {\n        const identifier = pluginManager.resolveName({\n          name: error.name,\n          pluginKey: [pluginTsName],\n          type: 'function',\n        })\n\n        return factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined)\n      }),\n    })!\n  }\n\n  const namespaceNode = factory.createTypeAliasDeclaration({\n    name,\n    type: factory.createTypeLiteralNode(\n      Object.keys(properties)\n        .map((key) => {\n          const type = properties[key]\n          if (!type) {\n            return undefined\n          }\n\n          return factory.createPropertySignature({\n            name: transformers.pascalCase(key),\n            type,\n          })\n        })\n        .filter(Boolean),\n    ),\n    modifiers: [factory.modifiers.export],\n  })\n\n  return safePrint(namespaceNode)\n}\n\nfunction printRequestSchema({\n  baseName,\n  operation,\n  schemas,\n  pluginManager,\n}: {\n  baseName: string\n  operation: Operation\n  schemas: OperationSchemas\n  pluginManager: PluginManager\n}): string {\n  const name = pluginManager.resolveName({\n    name: `${baseName} Request`,\n    pluginKey: [pluginTsName],\n    type: 'type',\n  })\n\n  const results: string[] = []\n\n  // Generate DataRequest type\n  const dataRequestProperties: ts.PropertySignature[] = []\n\n  if (schemas.request) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.request.name,\n      pluginKey: [pluginTsName],\n      type: 'type',\n    })\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'data',\n        questionToken: true,\n        type: factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined),\n      }),\n    )\n  } else {\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'data',\n        questionToken: true,\n        type: keywordTypeNodes.never,\n      }),\n    )\n  }\n\n  // Add pathParams property\n  if (schemas.pathParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.pathParams.name,\n      pluginKey: [pluginTsName],\n      type: 'type',\n    })\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'pathParams',\n        type: factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined),\n      }),\n    )\n  } else {\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'pathParams',\n        questionToken: true,\n        type: keywordTypeNodes.never,\n      }),\n    )\n  }\n\n  // Add queryParams property\n  if (schemas.queryParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.queryParams.name,\n      pluginKey: [pluginTsName],\n      type: 'type',\n    })\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'queryParams',\n        questionToken: true,\n        type: factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined),\n      }),\n    )\n  } else {\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'queryParams',\n        questionToken: true,\n        type: keywordTypeNodes.never,\n      }),\n    )\n  }\n\n  // Add headerParams property\n  if (schemas.headerParams) {\n    const identifier = pluginManager.resolveName({\n      name: schemas.headerParams.name,\n      pluginKey: [pluginTsName],\n      type: 'type',\n    })\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'headerParams',\n        questionToken: true,\n        type: factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined),\n      }),\n    )\n  } else {\n    dataRequestProperties.push(\n      factory.createPropertySignature({\n        name: 'headerParams',\n        questionToken: true,\n        type: keywordTypeNodes.never,\n      }),\n    )\n  }\n\n  // Add url property with template literal type\n  dataRequestProperties.push(\n    factory.createPropertySignature({\n      name: 'url',\n      type: createUrlTemplateType(operation.path),\n    }),\n  )\n\n  const dataRequestNode = factory.createTypeAliasDeclaration({\n    name,\n    type: factory.createTypeLiteralNode(dataRequestProperties),\n    modifiers: [factory.modifiers.export],\n  })\n\n  results.push(safePrint(dataRequestNode))\n\n  return results.join('\\n\\n')\n}\n\nfunction printResponseSchema({\n  baseName,\n  schemas,\n  pluginManager,\n  unknownType,\n}: {\n  baseName: string\n  schemas: OperationSchemas\n  pluginManager: PluginManager\n  unknownType: PluginTs['resolvedOptions']['unknownType']\n}): string {\n  const results: string[] = []\n\n  const name = pluginManager.resolveName({\n    name: `${baseName} ResponseData`,\n    pluginKey: [pluginTsName],\n    type: 'type',\n  })\n\n  // Generate Responses type (mapping status codes to response types)\n  if (schemas.responses && schemas.responses.length > 0) {\n    const responsesProperties: ts.PropertySignature[] = schemas.responses.map((res) => {\n      const identifier = pluginManager.resolveName({\n        name: res.name,\n        pluginKey: [pluginTsName],\n        type: 'type',\n      })\n\n      return factory.createPropertySignature({\n        name: res.statusCode?.toString() ?? 'default',\n        type: factory.createTypeReferenceNode(factory.createIdentifier(identifier), undefined),\n      })\n    })\n\n    const responsesNode = factory.createTypeAliasDeclaration({\n      name: `${baseName}Responses`,\n      type: factory.createTypeLiteralNode(responsesProperties),\n      modifiers: [factory.modifiers.export],\n    })\n\n    results.push(safePrint(responsesNode))\n\n    // Generate Response type (union via indexed access)\n    const responseNode = factory.createTypeAliasDeclaration({\n      name,\n      type: factory.createIndexedAccessTypeNode(\n        factory.createTypeReferenceNode(factory.createIdentifier(`${baseName}Responses`), undefined),\n        factory.createTypeOperatorNode(\n          ts.SyntaxKind.KeyOfKeyword,\n          factory.createTypeReferenceNode(factory.createIdentifier(`${baseName}Responses`), undefined),\n        ),\n      ),\n      modifiers: [factory.modifiers.export],\n    })\n\n    results.push(safePrint(responseNode))\n  } else {\n    const responseNode = factory.createTypeAliasDeclaration({\n      name,\n      modifiers: [factory.modifiers.export],\n      type: getUnknownType(unknownType),\n    })\n\n    results.push(safePrint(responseNode))\n  }\n\n  return results.join('\\n\\n')\n}\n\nexport const typeGenerator = createReactGenerator<PluginTs>({\n  name: 'typescript',\n  Operation({ operation, generator, plugin }) {\n    const {\n      options,\n      options: { mapper, enumType, enumKeyCasing, syntaxType, optionalType, arrayType, unknownType },\n    } = plugin\n\n    const mode = useMode()\n    const pluginManager = usePluginManager()\n\n    const oas = useOas()\n    const { getSchemas, getFile, getName, getGroup } = useOperationManager(generator)\n    const schemaManager = useSchemaManager()\n\n    const name = getName(operation, { type: 'type', pluginKey: [pluginTsName] })\n\n    const file = getFile(operation)\n    const schemas = getSchemas(operation)\n    const schemaGenerator = new SchemaGenerator(options, {\n      fabric: generator.context.fabric,\n      oas,\n      events: generator.context.events,\n      plugin,\n      pluginManager,\n      mode,\n      override: options.override,\n    })\n\n    const operationSchemas = [schemas.pathParams, schemas.queryParams, schemas.headerParams, schemas.statusCodes, schemas.request, schemas.response]\n      .flat()\n      .filter(Boolean)\n\n    const mapOperationSchema = ({ name, schema, description, keysToOmit, ...options }: OperationSchemaType) => {\n      const tree = schemaGenerator.parse({ schema, name, parentName: null })\n      const imports = schemaManager.getImports(tree)\n      const group = options.operation ? getGroup(options.operation) : undefined\n\n      const type = {\n        name: schemaManager.getName(name, { type: 'type' }),\n        typedName: schemaManager.getName(name, { type: 'type' }),\n        file: schemaManager.getFile(options.operationName || name, { group }),\n      }\n\n      return (\n        <>\n          {mode === 'split' &&\n            imports.map((imp) => (\n              <File.Import key={[name, imp.name, imp.path, imp.isTypeOnly].join('-')} root={file.path} path={imp.path} name={imp.name} isTypeOnly />\n            ))}\n          <Type\n            name={type.name}\n            typedName={type.typedName}\n            description={description}\n            tree={tree}\n            schema={schema}\n            mapper={mapper}\n            enumType={enumType}\n            enumKeyCasing={enumKeyCasing}\n            optionalType={optionalType}\n            arrayType={arrayType}\n            keysToOmit={keysToOmit}\n            syntaxType={syntaxType}\n          />\n        </>\n      )\n    }\n\n    const responseName = schemaManager.getName(schemas.response.name, {\n      type: 'type',\n    })\n    const combinedSchemaName = operation.method === 'get' ? `${name}Query` : `${name}Mutation`\n\n    return (\n      <File\n        baseName={file.baseName}\n        path={file.path}\n        meta={file.meta}\n        banner={getBanner({ oas, output: plugin.options.output, config: pluginManager.config })}\n        footer={getFooter({ oas, output: plugin.options.output })}\n      >\n        {operationSchemas.map(mapOperationSchema)}\n\n        {generator.context.UNSTABLE_NAMING ? (\n          <>\n            <File.Source name={`${name}Request`} isExportable isIndexable isTypeOnly>\n              {printRequestSchema({ baseName: name, operation, schemas, pluginManager })}\n            </File.Source>\n            <File.Source name={responseName} isExportable isIndexable isTypeOnly>\n              {printResponseSchema({ baseName: name, schemas, pluginManager, unknownType })}\n            </File.Source>\n          </>\n        ) : (\n          <File.Source name={combinedSchemaName} isExportable isIndexable isTypeOnly>\n            {printCombinedSchema({ name: combinedSchemaName, schemas, pluginManager })}\n          </File.Source>\n        )}\n      </File>\n    )\n  },\n  Schema({ schema, plugin }) {\n    const {\n      options: { mapper, enumType, enumKeyCasing, syntaxType, optionalType, arrayType, output },\n    } = plugin\n    const mode = useMode()\n\n    const oas = useOas()\n    const pluginManager = usePluginManager()\n\n    const { getName, getImports, getFile } = useSchemaManager()\n    const imports = getImports(schema.tree)\n    const schemaFromTree = schema.tree.find((item) => item.keyword === schemaKeywords.schema)\n\n    let typedName = getName(schema.name, { type: 'type' })\n\n    if (enumType === 'asConst' && schemaFromTree && isKeyword(schemaFromTree, schemaKeywords.enum)) {\n      typedName = typedName += 'Key' //Suffix for avoiding collisions (https://github.com/kubb-labs/kubb/issues/1873)\n    }\n\n    const type = {\n      name: getName(schema.name, { type: 'function' }),\n      typedName,\n      file: getFile(schema.name),\n    }\n\n    return (\n      <File\n        baseName={type.file.baseName}\n        path={type.file.path}\n        meta={type.file.meta}\n        banner={getBanner({ oas, output, config: pluginManager.config })}\n        footer={getFooter({ oas, output })}\n      >\n        {mode === 'split' &&\n          imports.map((imp) => (\n            <File.Import key={[schema.name, imp.path, imp.isTypeOnly].join('-')} root={type.file.path} path={imp.path} name={imp.name} isTypeOnly />\n          ))}\n        <Type\n          name={type.name}\n          typedName={type.typedName}\n          description={schema.value.description}\n          tree={schema.tree}\n          schema={schema.value}\n          mapper={mapper}\n          enumType={enumType}\n          enumKeyCasing={enumKeyCasing}\n          optionalType={optionalType}\n          arrayType={arrayType}\n          syntaxType={syntaxType}\n        />\n      </File>\n    )\n  },\n})\n","import path from 'node:path'\nimport { definePlugin, type Group, getBarrelFiles, getMode } from '@kubb/core'\nimport { camelCase, pascalCase } from '@kubb/core/transformers'\nimport { OperationGenerator, pluginOasName, SchemaGenerator } from '@kubb/plugin-oas'\nimport { typeGenerator } from './generators'\nimport type { PluginTs } from './types.ts'\n\nexport const pluginTsName = 'plugin-ts' satisfies PluginTs['name']\n\nexport const pluginTs = definePlugin<PluginTs>((options) => {\n  const {\n    output = { path: 'types', barrelType: 'named' },\n    group,\n    exclude = [],\n    include,\n    override = [],\n    enumType = 'asConst',\n    enumKeyCasing = 'none',\n    enumSuffix = 'enum',\n    dateType = 'string',\n    unknownType = 'any',\n    optionalType = 'questionToken',\n    arrayType = 'array',\n    emptySchemaType = unknownType,\n    syntaxType = 'type',\n    transformers = {},\n    mapper = {},\n    generators = [typeGenerator].filter(Boolean),\n    contentType,\n    UNSTABLE_NAMING,\n  } = options\n\n  // @deprecated Will be removed in v5 when collisionDetection defaults to true\n  const usedEnumNames = {}\n\n  return {\n    name: pluginTsName,\n    options: {\n      output,\n      transformers,\n      dateType,\n      optionalType,\n      arrayType,\n      enumType,\n      enumKeyCasing,\n      enumSuffix,\n      unknownType,\n      emptySchemaType,\n      syntaxType,\n      group,\n      override,\n      mapper,\n      usedEnumNames,\n    },\n    pre: [pluginOasName],\n    resolvePath(baseName, pathMode, options) {\n      const root = path.resolve(this.config.root, this.config.output.path)\n      const mode = pathMode ?? getMode(path.resolve(root, output.path))\n\n      if (mode === 'single') {\n        /**\n         * when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend\n         * Other plugins then need to call addOrAppend instead of just add from the fileManager class\n         */\n        return path.resolve(root, output.path)\n      }\n\n      if (group && (options?.group?.path || options?.group?.tag)) {\n        const groupName: Group['name'] = group?.name\n          ? group.name\n          : (ctx) => {\n              if (group?.type === 'path') {\n                return `${ctx.group.split('/')[1]}`\n              }\n              return `${camelCase(ctx.group)}Controller`\n            }\n\n        return path.resolve(\n          root,\n          output.path,\n          groupName({\n            group: group.type === 'path' ? options.group.path! : options.group.tag!,\n          }),\n          baseName,\n        )\n      }\n\n      return path.resolve(root, output.path, baseName)\n    },\n    resolveName(name, type) {\n      const resolvedName = pascalCase(name, { isFile: type === 'file' })\n\n      if (type) {\n        return transformers?.name?.(resolvedName, type) || resolvedName\n      }\n\n      return resolvedName\n    },\n    async install() {\n      const root = path.resolve(this.config.root, this.config.output.path)\n      const mode = getMode(path.resolve(root, output.path))\n      const oas = await this.getOas()\n\n      const schemaGenerator = new SchemaGenerator(this.plugin.options, {\n        fabric: this.fabric,\n        oas,\n        pluginManager: this.pluginManager,\n        events: this.events,\n        plugin: this.plugin,\n        contentType,\n        include: undefined,\n        override,\n        mode,\n        output: output.path,\n      })\n\n      const schemaFiles = await schemaGenerator.build(...generators)\n      await this.upsertFile(...schemaFiles)\n\n      const operationGenerator = new OperationGenerator(this.plugin.options, {\n        fabric: this.fabric,\n        oas,\n        pluginManager: this.pluginManager,\n        events: this.events,\n        plugin: this.plugin,\n        contentType,\n        exclude,\n        include,\n        override,\n        mode,\n        UNSTABLE_NAMING,\n      })\n\n      const operationFiles = await operationGenerator.build(...generators)\n      await this.upsertFile(...operationFiles)\n\n      const barrelFiles = await getBarrelFiles(this.fabric.files, {\n        type: output.barrelType ?? 'named',\n        root,\n        output,\n        meta: {\n          pluginKey: this.plugin.key,\n        },\n      })\n\n      await this.upsertFile(...barrelFiles)\n    },\n  }\n})\n"],"mappings":"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"}