const require_chunk = require('./chunk-C1_xRkKa.cjs');
const require_generators = require('./generators-BPQFq13R.cjs');
let node_path = require("node:path");
node_path = require_chunk.__toESM(node_path);
let _kubb_core = require("@kubb/core");
let _kubb_core_transformers = require("@kubb/core/transformers");
let _kubb_core_utils = require("@kubb/core/utils");
let _kubb_plugin_oas = require("@kubb/plugin-oas");
let _kubb_plugin_zod = require("@kubb/plugin-zod");

//#region src/plugin.ts
const pluginClientName = "plugin-client";
const pluginClient = (0, _kubb_core.definePlugin)((options) => {
	const { output = {
		path: "clients",
		barrelType: "named"
	}, group, urlType = false, exclude = [], include, override = [], transformers = {}, dataReturnType = "data", paramsType = "inline", pathParamsType = paramsType === "object" ? "object" : options.pathParamsType || "inline", operations = false, baseURL, paramsCasing, clientType = "function", parser = "client", client = "axios", importPath, contentType, bundle = false } = options;
	const resolvedImportPath = importPath ?? (!bundle ? `@kubb/plugin-client/clients/${client}` : void 0);
	const defaultGenerators = [
		clientType === "staticClass" ? require_generators.staticClassClientGenerator : clientType === "class" ? require_generators.classClientGenerator : require_generators.clientGenerator,
		group && clientType === "function" ? require_generators.groupedClientGenerator : void 0,
		operations ? require_generators.operationsGenerator : void 0
	].filter(Boolean);
	const generators = options.generators ?? defaultGenerators;
	return {
		name: pluginClientName,
		options: {
			client,
			clientType,
			bundle,
			output,
			group,
			parser,
			dataReturnType,
			importPath: resolvedImportPath,
			paramsType,
			paramsCasing,
			pathParamsType,
			baseURL,
			urlType
		},
		pre: [_kubb_plugin_oas.pluginOasName, parser === "zod" ? _kubb_plugin_zod.pluginZodName : void 0].filter(Boolean),
		resolvePath(baseName, pathMode, options$1) {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			if ((pathMode ?? (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path))) === "single")
 /**
			* when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend
			* Other plugins then need to call addOrAppend instead of just add from the fileManager class
			*/
			return node_path.default.resolve(root, output.path);
			if (group && (options$1?.group?.path || options$1?.group?.tag)) {
				const groupName = group?.name ? group.name : (ctx) => {
					if (group?.type === "path") return `${ctx.group.split("/")[1]}`;
					return `${(0, _kubb_core_transformers.camelCase)(ctx.group)}Controller`;
				};
				return node_path.default.resolve(root, output.path, groupName({ group: group.type === "path" ? options$1.group.path : options$1.group.tag }), baseName);
			}
			return node_path.default.resolve(root, output.path, baseName);
		},
		resolveName(name, type) {
			const resolvedName = (0, _kubb_core_transformers.camelCase)(name, { isFile: type === "file" });
			if (type) return transformers?.name?.(resolvedName, type) || resolvedName;
			return resolvedName;
		},
		async install() {
			const root = node_path.default.resolve(this.config.root, this.config.output.path);
			const mode = (0, _kubb_core.getMode)(node_path.default.resolve(root, output.path));
			const oas = await this.getOas();
			const baseURL$1 = await this.getBaseURL();
			if (bundle && !this.plugin.options.importPath) await this.addFile({
				baseName: "fetch.ts",
				path: node_path.default.resolve(root, ".kubb/fetch.ts"),
				sources: [{
					name: "fetch",
					value: (0, _kubb_core_utils.resolveModuleSource)(this.plugin.options.client === "fetch" ? "@kubb/plugin-client/templates/clients/fetch" : "@kubb/plugin-client/templates/clients/axios").source,
					isExportable: true,
					isIndexable: true
				}],
				imports: [],
				exports: []
			});
			await this.addFile({
				baseName: "config.ts",
				path: node_path.default.resolve(root, ".kubb/config.ts"),
				sources: [{
					name: "config",
					value: (0, _kubb_core_utils.resolveModuleSource)("@kubb/plugin-client/templates/config").source,
					isExportable: false,
					isIndexable: false
				}],
				imports: [],
				exports: []
			});
			const files = await new _kubb_plugin_oas.OperationGenerator(baseURL$1 ? {
				...this.plugin.options,
				baseURL: baseURL$1
			} : this.plugin.options, {
				fabric: this.fabric,
				oas,
				pluginManager: this.pluginManager,
				events: this.events,
				plugin: this.plugin,
				contentType,
				exclude,
				include,
				override,
				mode
			}).build(...generators);
			await this.upsertFile(...files);
			const barrelFiles = await (0, _kubb_core.getBarrelFiles)(this.fabric.files, {
				type: output.barrelType ?? "named",
				root,
				output,
				meta: { pluginKey: this.plugin.key }
			});
			await this.upsertFile(...barrelFiles);
		}
	};
});

//#endregion
exports.pluginClient = pluginClient;
exports.pluginClientName = pluginClientName;
//# sourceMappingURL=index.cjs.map