import { t as __name } from "./chunk-iVr_oF3V.js";
import { a as Url, i as Client, n as Operations, r as ClassClient, t as StaticClassClient } from "./StaticClassClient-yRrX6THy.js";
import path from "node:path";
import { camelCase, pascalCase } from "@kubb/core/transformers";
import { pluginZodName } from "@kubb/plugin-zod";
import { usePluginManager } from "@kubb/core/hooks";
import { createReactGenerator } from "@kubb/plugin-oas/generators";
import { useOas, useOperationManager } from "@kubb/plugin-oas/hooks";
import { getBanner, getFooter } from "@kubb/plugin-oas/utils";
import { pluginTsName } from "@kubb/plugin-ts";
import { File, Function } from "@kubb/react-fabric";
import { Fragment, jsx, jsxs } from "@kubb/react-fabric/jsx-runtime";

//#region src/generators/classClientGenerator.tsx
const classClientGenerator = createReactGenerator({
	name: "classClient",
	Operations({ operations, generator, plugin, config }) {
		const { options, key: pluginKey } = plugin;
		const pluginManager = usePluginManager();
		const oas = useOas();
		const { getName, getFile, getGroup, getSchemas } = useOperationManager(generator);
		function buildOperationData(operation) {
			const type = {
				file: getFile(operation, { pluginKey: [pluginTsName] }),
				schemas: getSchemas(operation, {
					pluginKey: [pluginTsName],
					type: "type"
				})
			};
			const zod = {
				file: getFile(operation, { pluginKey: [pluginZodName] }),
				schemas: getSchemas(operation, {
					pluginKey: [pluginZodName],
					type: "function"
				})
			};
			return {
				operation,
				name: getName(operation, { type: "function" }),
				typeSchemas: type.schemas,
				zodSchemas: zod.schemas,
				typeFile: type.file,
				zodFile: zod.file
			};
		}
		const controllers = operations.reduce((acc, operation) => {
			const group = getGroup(operation);
			const groupName = group?.tag ? options.group?.name?.({ group: camelCase(group.tag) }) ?? pascalCase(group.tag) : "Client";
			if (!group?.tag && !options.group) {
				const name = "ApiClient";
				const file = pluginManager.getFile({
					name,
					extname: ".ts",
					pluginKey
				});
				const operationData = buildOperationData(operation);
				const previousFile = acc.find((item) => item.file.path === file.path);
				if (previousFile) previousFile.operations.push(operationData);
				else acc.push({
					name,
					file,
					operations: [operationData]
				});
			} else if (group?.tag) {
				const name = groupName;
				const file = pluginManager.getFile({
					name,
					extname: ".ts",
					pluginKey,
					options: { group }
				});
				const operationData = buildOperationData(operation);
				const previousFile = acc.find((item) => item.file.path === file.path);
				if (previousFile) previousFile.operations.push(operationData);
				else acc.push({
					name,
					file,
					operations: [operationData]
				});
			}
			return acc;
		}, []);
		function collectTypeImports(ops) {
			const typeImportsByFile = /* @__PURE__ */ new Map();
			const typeFilesByPath = /* @__PURE__ */ new Map();
			ops.forEach((op) => {
				const { typeSchemas, typeFile } = op;
				if (!typeImportsByFile.has(typeFile.path)) typeImportsByFile.set(typeFile.path, /* @__PURE__ */ new Set());
				const typeImports = typeImportsByFile.get(typeFile.path);
				if (typeSchemas.request?.name) typeImports.add(typeSchemas.request.name);
				if (typeSchemas.response?.name) typeImports.add(typeSchemas.response.name);
				if (typeSchemas.pathParams?.name) typeImports.add(typeSchemas.pathParams.name);
				if (typeSchemas.queryParams?.name) typeImports.add(typeSchemas.queryParams.name);
				if (typeSchemas.headerParams?.name) typeImports.add(typeSchemas.headerParams.name);
				typeSchemas.statusCodes?.forEach((item) => {
					if (item?.name) typeImports.add(item.name);
				});
				typeFilesByPath.set(typeFile.path, typeFile);
			});
			return {
				typeImportsByFile,
				typeFilesByPath
			};
		}
		function collectZodImports(ops) {
			const zodImportsByFile = /* @__PURE__ */ new Map();
			const zodFilesByPath = /* @__PURE__ */ new Map();
			ops.forEach((op) => {
				const { zodSchemas, zodFile } = op;
				if (!zodImportsByFile.has(zodFile.path)) zodImportsByFile.set(zodFile.path, /* @__PURE__ */ new Set());
				const zodImports = zodImportsByFile.get(zodFile.path);
				if (zodSchemas?.response?.name) zodImports.add(zodSchemas.response.name);
				if (zodSchemas?.request?.name) zodImports.add(zodSchemas.request.name);
				zodFilesByPath.set(zodFile.path, zodFile);
			});
			return {
				zodImportsByFile,
				zodFilesByPath
			};
		}
		return controllers.map(({ name, file, operations: ops }) => {
			const { typeImportsByFile, typeFilesByPath } = collectTypeImports(ops);
			const { zodImportsByFile, zodFilesByPath } = options.parser === "zod" ? collectZodImports(ops) : {
				zodImportsByFile: /* @__PURE__ */ new Map(),
				zodFilesByPath: /* @__PURE__ */ new Map()
			};
			const hasFormData = ops.some((op) => op.operation.getContentType() === "multipart/form-data");
			return /* @__PURE__ */ jsxs(File, {
				baseName: file.baseName,
				path: file.path,
				meta: file.meta,
				banner: getBanner({
					oas,
					output: options.output,
					config: pluginManager.config
				}),
				footer: getFooter({
					oas,
					output: options.output
				}),
				children: [
					options.importPath ? /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
						name: "fetch",
						path: options.importPath
					}), /* @__PURE__ */ jsx(File.Import, {
						name: ["RequestConfig", "ResponseErrorConfig"],
						path: options.importPath,
						isTypeOnly: true
					})] }) : /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
						name: ["fetch"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts")
					}), /* @__PURE__ */ jsx(File.Import, {
						name: ["RequestConfig", "ResponseErrorConfig"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts"),
						isTypeOnly: true
					})] }),
					hasFormData && /* @__PURE__ */ jsx(File.Import, {
						name: ["buildFormData"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/config.ts")
					}),
					Array.from(typeImportsByFile.entries()).map(([filePath, imports]) => {
						const typeFile = typeFilesByPath.get(filePath);
						if (!typeFile) return null;
						const importNames = Array.from(imports).filter(Boolean);
						if (importNames.length === 0) return null;
						return /* @__PURE__ */ jsx(File.Import, {
							name: importNames,
							root: file.path,
							path: typeFile.path,
							isTypeOnly: true
						}, filePath);
					}),
					options.parser === "zod" && Array.from(zodImportsByFile.entries()).map(([filePath, imports]) => {
						const zodFile = zodFilesByPath.get(filePath);
						if (!zodFile) return null;
						const importNames = Array.from(imports).filter(Boolean);
						if (importNames.length === 0) return null;
						return /* @__PURE__ */ jsx(File.Import, {
							name: importNames,
							root: file.path,
							path: zodFile.path
						}, filePath);
					}),
					/* @__PURE__ */ jsx(ClassClient, {
						name,
						operations: ops,
						baseURL: options.baseURL,
						dataReturnType: options.dataReturnType,
						pathParamsType: options.pathParamsType,
						paramsCasing: options.paramsCasing,
						paramsType: options.paramsType,
						parser: options.parser
					})
				]
			}, file.path);
		});
	}
});

//#endregion
//#region src/generators/clientGenerator.tsx
const clientGenerator = createReactGenerator({
	name: "client",
	Operation({ config, plugin, operation, generator }) {
		const pluginManager = usePluginManager();
		const { options, options: { output, urlType } } = plugin;
		const oas = useOas();
		const { getSchemas, getName, getFile } = useOperationManager(generator);
		const client = {
			name: getName(operation, { type: "function" }),
			file: getFile(operation)
		};
		const url = {
			name: getName(operation, {
				type: "function",
				suffix: "url",
				prefix: "get"
			}),
			file: getFile(operation)
		};
		const type = {
			file: getFile(operation, { pluginKey: [pluginTsName] }),
			schemas: getSchemas(operation, {
				pluginKey: [pluginTsName],
				type: "type"
			})
		};
		const zod = {
			file: getFile(operation, { pluginKey: [pluginZodName] }),
			schemas: getSchemas(operation, {
				pluginKey: [pluginZodName],
				type: "function"
			})
		};
		const isFormData = operation.getContentType() === "multipart/form-data";
		return /* @__PURE__ */ jsxs(File, {
			baseName: client.file.baseName,
			path: client.file.path,
			meta: client.file.meta,
			banner: getBanner({
				oas,
				output,
				config: pluginManager.config
			}),
			footer: getFooter({
				oas,
				output
			}),
			children: [
				options.importPath ? /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
					name: "fetch",
					path: options.importPath
				}), /* @__PURE__ */ jsx(File.Import, {
					name: ["RequestConfig", "ResponseErrorConfig"],
					path: options.importPath,
					isTypeOnly: true
				})] }) : /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
					name: ["fetch"],
					root: client.file.path,
					path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts")
				}), /* @__PURE__ */ jsx(File.Import, {
					name: ["RequestConfig", "ResponseErrorConfig"],
					root: client.file.path,
					path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts"),
					isTypeOnly: true
				})] }),
				isFormData && type.schemas.request?.name && /* @__PURE__ */ jsx(File.Import, {
					name: ["buildFormData"],
					root: client.file.path,
					path: path.resolve(config.root, config.output.path, ".kubb/config.ts")
				}),
				options.parser === "zod" && /* @__PURE__ */ jsx(File.Import, {
					name: [zod.schemas.response.name, zod.schemas.request?.name].filter(Boolean),
					root: client.file.path,
					path: zod.file.path
				}),
				/* @__PURE__ */ jsx(File.Import, {
					name: [
						type.schemas.request?.name,
						type.schemas.response.name,
						type.schemas.pathParams?.name,
						type.schemas.queryParams?.name,
						type.schemas.headerParams?.name,
						...type.schemas.statusCodes?.map((item) => item.name) || []
					].filter(Boolean),
					root: client.file.path,
					path: type.file.path,
					isTypeOnly: true
				}),
				/* @__PURE__ */ jsx(Url, {
					name: url.name,
					baseURL: options.baseURL,
					pathParamsType: options.pathParamsType,
					paramsCasing: options.paramsCasing,
					paramsType: options.paramsType,
					typeSchemas: type.schemas,
					operation,
					isIndexable: urlType === "export",
					isExportable: urlType === "export"
				}),
				/* @__PURE__ */ jsx(Client, {
					name: client.name,
					urlName: url.name,
					baseURL: options.baseURL,
					dataReturnType: options.dataReturnType,
					pathParamsType: options.pathParamsType,
					paramsCasing: options.paramsCasing,
					paramsType: options.paramsType,
					typeSchemas: type.schemas,
					operation,
					parser: options.parser,
					zodSchemas: zod.schemas
				})
			]
		});
	}
});

//#endregion
//#region src/generators/groupedClientGenerator.tsx
const groupedClientGenerator = createReactGenerator({
	name: "groupedClient",
	Operations({ operations, generator, plugin }) {
		const { options, key: pluginKey } = plugin;
		const pluginManager = usePluginManager();
		const oas = useOas();
		const { getName, getFile, getGroup } = useOperationManager(generator);
		return operations.reduce((acc, operation) => {
			if (options.group?.type === "tag") {
				const group = getGroup(operation);
				const name = group?.tag ? options.group?.name?.({ group: camelCase(group.tag) }) : void 0;
				if (!group?.tag || !name) return acc;
				const file = pluginManager.getFile({
					name,
					extname: ".ts",
					pluginKey,
					options: { group }
				});
				const client = {
					name: getName(operation, { type: "function" }),
					file: getFile(operation)
				};
				const previousFile = acc.find((item) => item.file.path === file.path);
				if (previousFile) previousFile.clients.push(client);
				else acc.push({
					name,
					file,
					clients: [client]
				});
			}
			return acc;
		}, []).map(({ name, file, clients }) => {
			return /* @__PURE__ */ jsxs(File, {
				baseName: file.baseName,
				path: file.path,
				meta: file.meta,
				banner: getBanner({
					oas,
					output: options.output,
					config: pluginManager.config
				}),
				footer: getFooter({
					oas,
					output: options.output
				}),
				children: [clients.map((client) => /* @__PURE__ */ jsx(File.Import, {
					name: [client.name],
					root: file.path,
					path: client.file.path
				}, client.name)), /* @__PURE__ */ jsx(File.Source, {
					name,
					isExportable: true,
					isIndexable: true,
					children: /* @__PURE__ */ jsx(Function, {
						export: true,
						name,
						children: `return { ${clients.map((client) => client.name).join(", ")} }`
					})
				})]
			}, file.path);
		});
	}
});

//#endregion
//#region src/generators/operationsGenerator.tsx
const operationsGenerator = createReactGenerator({
	name: "client",
	Operations({ operations, plugin }) {
		const { key: pluginKey, options: { output } } = plugin;
		const pluginManager = usePluginManager();
		const oas = useOas();
		const name = "operations";
		const file = pluginManager.getFile({
			name,
			extname: ".ts",
			pluginKey
		});
		return /* @__PURE__ */ jsx(File, {
			baseName: file.baseName,
			path: file.path,
			meta: file.meta,
			banner: getBanner({
				oas,
				output,
				config: pluginManager.config
			}),
			footer: getFooter({
				oas,
				output
			}),
			children: /* @__PURE__ */ jsx(Operations, {
				name,
				operations
			})
		});
	}
});

//#endregion
//#region src/generators/staticClassClientGenerator.tsx
const staticClassClientGenerator = createReactGenerator({
	name: "staticClassClient",
	Operations({ operations, generator, plugin, config }) {
		const { options, key: pluginKey } = plugin;
		const pluginManager = usePluginManager();
		const oas = useOas();
		const { getName, getFile, getGroup, getSchemas } = useOperationManager(generator);
		function buildOperationData(operation) {
			const type = {
				file: getFile(operation, { pluginKey: [pluginTsName] }),
				schemas: getSchemas(operation, {
					pluginKey: [pluginTsName],
					type: "type"
				})
			};
			const zod = {
				file: getFile(operation, { pluginKey: [pluginZodName] }),
				schemas: getSchemas(operation, {
					pluginKey: [pluginZodName],
					type: "function"
				})
			};
			return {
				operation,
				name: getName(operation, { type: "function" }),
				typeSchemas: type.schemas,
				zodSchemas: zod.schemas,
				typeFile: type.file,
				zodFile: zod.file
			};
		}
		const controllers = operations.reduce((acc, operation) => {
			const group = getGroup(operation);
			const groupName = group?.tag ? options.group?.name?.({ group: camelCase(group.tag) }) ?? pascalCase(group.tag) : "Client";
			if (!group?.tag && !options.group) {
				const name = "ApiClient";
				const file = pluginManager.getFile({
					name,
					extname: ".ts",
					pluginKey
				});
				const operationData = buildOperationData(operation);
				const previousFile = acc.find((item) => item.file.path === file.path);
				if (previousFile) previousFile.operations.push(operationData);
				else acc.push({
					name,
					file,
					operations: [operationData]
				});
			} else if (group?.tag) {
				const name = groupName;
				const file = pluginManager.getFile({
					name,
					extname: ".ts",
					pluginKey,
					options: { group }
				});
				const operationData = buildOperationData(operation);
				const previousFile = acc.find((item) => item.file.path === file.path);
				if (previousFile) previousFile.operations.push(operationData);
				else acc.push({
					name,
					file,
					operations: [operationData]
				});
			}
			return acc;
		}, []);
		function collectTypeImports(ops) {
			const typeImportsByFile = /* @__PURE__ */ new Map();
			const typeFilesByPath = /* @__PURE__ */ new Map();
			ops.forEach((op) => {
				const { typeSchemas, typeFile } = op;
				if (!typeImportsByFile.has(typeFile.path)) typeImportsByFile.set(typeFile.path, /* @__PURE__ */ new Set());
				const typeImports = typeImportsByFile.get(typeFile.path);
				if (typeSchemas.request?.name) typeImports.add(typeSchemas.request.name);
				if (typeSchemas.response?.name) typeImports.add(typeSchemas.response.name);
				if (typeSchemas.pathParams?.name) typeImports.add(typeSchemas.pathParams.name);
				if (typeSchemas.queryParams?.name) typeImports.add(typeSchemas.queryParams.name);
				if (typeSchemas.headerParams?.name) typeImports.add(typeSchemas.headerParams.name);
				typeSchemas.statusCodes?.forEach((item) => {
					if (item?.name) typeImports.add(item.name);
				});
				typeFilesByPath.set(typeFile.path, typeFile);
			});
			return {
				typeImportsByFile,
				typeFilesByPath
			};
		}
		function collectZodImports(ops) {
			const zodImportsByFile = /* @__PURE__ */ new Map();
			const zodFilesByPath = /* @__PURE__ */ new Map();
			ops.forEach((op) => {
				const { zodSchemas, zodFile } = op;
				if (!zodImportsByFile.has(zodFile.path)) zodImportsByFile.set(zodFile.path, /* @__PURE__ */ new Set());
				const zodImports = zodImportsByFile.get(zodFile.path);
				if (zodSchemas?.response?.name) zodImports.add(zodSchemas.response.name);
				if (zodSchemas?.request?.name) zodImports.add(zodSchemas.request.name);
				zodFilesByPath.set(zodFile.path, zodFile);
			});
			return {
				zodImportsByFile,
				zodFilesByPath
			};
		}
		return controllers.map(({ name, file, operations: ops }) => {
			const { typeImportsByFile, typeFilesByPath } = collectTypeImports(ops);
			const { zodImportsByFile, zodFilesByPath } = options.parser === "zod" ? collectZodImports(ops) : {
				zodImportsByFile: /* @__PURE__ */ new Map(),
				zodFilesByPath: /* @__PURE__ */ new Map()
			};
			const hasFormData = ops.some((op) => op.operation.getContentType() === "multipart/form-data");
			return /* @__PURE__ */ jsxs(File, {
				baseName: file.baseName,
				path: file.path,
				meta: file.meta,
				banner: getBanner({
					oas,
					output: options.output,
					config: pluginManager.config
				}),
				footer: getFooter({
					oas,
					output: options.output
				}),
				children: [
					options.importPath ? /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
						name: "fetch",
						path: options.importPath
					}), /* @__PURE__ */ jsx(File.Import, {
						name: ["RequestConfig", "ResponseErrorConfig"],
						path: options.importPath,
						isTypeOnly: true
					})] }) : /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(File.Import, {
						name: ["fetch"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts")
					}), /* @__PURE__ */ jsx(File.Import, {
						name: ["RequestConfig", "ResponseErrorConfig"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/fetch.ts"),
						isTypeOnly: true
					})] }),
					hasFormData && /* @__PURE__ */ jsx(File.Import, {
						name: ["buildFormData"],
						root: file.path,
						path: path.resolve(config.root, config.output.path, ".kubb/config.ts")
					}),
					Array.from(typeImportsByFile.entries()).map(([filePath, imports]) => {
						const typeFile = typeFilesByPath.get(filePath);
						if (!typeFile) return null;
						const importNames = Array.from(imports).filter(Boolean);
						if (importNames.length === 0) return null;
						return /* @__PURE__ */ jsx(File.Import, {
							name: importNames,
							root: file.path,
							path: typeFile.path,
							isTypeOnly: true
						}, filePath);
					}),
					options.parser === "zod" && Array.from(zodImportsByFile.entries()).map(([filePath, imports]) => {
						const zodFile = zodFilesByPath.get(filePath);
						if (!zodFile) return null;
						const importNames = Array.from(imports).filter(Boolean);
						if (importNames.length === 0) return null;
						return /* @__PURE__ */ jsx(File.Import, {
							name: importNames,
							root: file.path,
							path: zodFile.path
						}, filePath);
					}),
					/* @__PURE__ */ jsx(StaticClassClient, {
						name,
						operations: ops,
						baseURL: options.baseURL,
						dataReturnType: options.dataReturnType,
						pathParamsType: options.pathParamsType,
						paramsCasing: options.paramsCasing,
						paramsType: options.paramsType,
						parser: options.parser
					})
				]
			}, file.path);
		});
	}
});

//#endregion
export { classClientGenerator as a, clientGenerator as i, operationsGenerator as n, groupedClientGenerator as r, staticClassClientGenerator as t };
//# sourceMappingURL=generators-CtXa-3Fh.js.map