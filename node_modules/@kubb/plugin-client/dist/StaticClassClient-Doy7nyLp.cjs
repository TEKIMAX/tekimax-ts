const require_chunk = require('./chunk-C1_xRkKa.cjs');
let _kubb_core_utils = require("@kubb/core/utils");
let _kubb_plugin_oas_utils = require("@kubb/plugin-oas/utils");
let _kubb_react_fabric = require("@kubb/react-fabric");
let _kubb_oas = require("@kubb/oas");
let _kubb_react_fabric_jsx_runtime = require("@kubb/react-fabric/jsx-runtime");

//#region src/components/Url.tsx
function getParams$1({ paramsType, paramsCasing, pathParamsType, typeSchemas }) {
	if (paramsType === "object") {
		const pathParams = (0, _kubb_plugin_oas_utils.getPathParams)(typeSchemas.pathParams, {
			typed: true,
			casing: paramsCasing
		});
		return _kubb_react_fabric.FunctionParams.factory({ data: {
			mode: "object",
			children: { ...pathParams }
		} });
	}
	return _kubb_react_fabric.FunctionParams.factory({ pathParams: typeSchemas.pathParams?.name ? {
		mode: pathParamsType === "object" ? "object" : "inlineSpread",
		children: (0, _kubb_plugin_oas_utils.getPathParams)(typeSchemas.pathParams, {
			typed: true,
			casing: paramsCasing
		}),
		default: (0, _kubb_oas.getDefaultValue)(typeSchemas.pathParams?.schema)
	} : void 0 });
}
require_chunk.__name(getParams$1, "getParams");
function Url({ name, isExportable = true, isIndexable = true, typeSchemas, baseURL, paramsType, paramsCasing, pathParamsType, operation }) {
	const path = new _kubb_core_utils.URLPath(operation.path, { casing: paramsCasing });
	const params = getParams$1({
		paramsType,
		paramsCasing,
		pathParamsType,
		typeSchemas
	});
	return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
		name,
		isExportable,
		isIndexable,
		children: /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.Function, {
			name,
			export: isExportable,
			params: params.toConstructor(),
			children: [
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.Const, {
					name: "res",
					children: `{ method: '${operation.method.toUpperCase()}', url: ${path.toTemplateString({ prefix: baseURL })} as const }`
				}),
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				"return res"
			]
		})
	});
}
Url.getParams = getParams$1;

//#endregion
//#region src/components/Client.tsx
function getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas, isConfigurable }) {
	if (paramsType === "object") {
		const children = {
			...(0, _kubb_plugin_oas_utils.getPathParams)(typeSchemas.pathParams, {
				typed: true,
				casing: paramsCasing
			}),
			data: typeSchemas.request?.name ? {
				type: typeSchemas.request?.name,
				optional: (0, _kubb_oas.isOptional)(typeSchemas.request?.schema)
			} : void 0,
			params: typeSchemas.queryParams?.name ? {
				type: typeSchemas.queryParams?.name,
				optional: (0, _kubb_oas.isOptional)(typeSchemas.queryParams?.schema)
			} : void 0,
			headers: typeSchemas.headerParams?.name ? {
				type: typeSchemas.headerParams?.name,
				optional: (0, _kubb_oas.isOptional)(typeSchemas.headerParams?.schema)
			} : void 0
		};
		const allChildrenAreOptional = Object.values(children).every((child) => !child || child.optional);
		return _kubb_react_fabric.FunctionParams.factory({
			data: {
				mode: "object",
				children,
				default: allChildrenAreOptional ? "{}" : void 0
			},
			config: isConfigurable ? {
				type: typeSchemas.request?.name ? `Partial<RequestConfig<${typeSchemas.request?.name}>> & { client?: typeof fetch }` : "Partial<RequestConfig> & { client?: typeof fetch }",
				default: "{}"
			} : void 0
		});
	}
	return _kubb_react_fabric.FunctionParams.factory({
		pathParams: typeSchemas.pathParams?.name ? {
			mode: pathParamsType === "object" ? "object" : "inlineSpread",
			children: (0, _kubb_plugin_oas_utils.getPathParams)(typeSchemas.pathParams, {
				typed: true,
				casing: paramsCasing
			}),
			default: (0, _kubb_oas.getDefaultValue)(typeSchemas.pathParams?.schema)
		} : void 0,
		data: typeSchemas.request?.name ? {
			type: typeSchemas.request?.name,
			optional: (0, _kubb_oas.isOptional)(typeSchemas.request?.schema)
		} : void 0,
		params: typeSchemas.queryParams?.name ? {
			type: typeSchemas.queryParams?.name,
			optional: (0, _kubb_oas.isOptional)(typeSchemas.queryParams?.schema)
		} : void 0,
		headers: typeSchemas.headerParams?.name ? {
			type: typeSchemas.headerParams?.name,
			optional: (0, _kubb_oas.isOptional)(typeSchemas.headerParams?.schema)
		} : void 0,
		config: isConfigurable ? {
			type: typeSchemas.request?.name ? `Partial<RequestConfig<${typeSchemas.request?.name}>> & { client?: typeof fetch }` : "Partial<RequestConfig> & { client?: typeof fetch }",
			default: "{}"
		} : void 0
	});
}
function Client({ name, isExportable = true, isIndexable = true, returnType, typeSchemas, baseURL, dataReturnType, parser, zodSchemas, paramsType, paramsCasing, pathParamsType, operation, urlName, children, isConfigurable = true }) {
	const path = new _kubb_core_utils.URLPath(operation.path, { casing: paramsCasing });
	const contentType = operation.getContentType();
	const isFormData = contentType === "multipart/form-data";
	const headers = [contentType !== "application/json" && contentType !== "multipart/form-data" ? `'Content-Type': '${contentType}'` : void 0, typeSchemas.headerParams?.name ? "...headers" : void 0].filter(Boolean);
	const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(" | ") || "Error"}>`;
	const generics = [
		typeSchemas.response.name,
		TError,
		typeSchemas.request?.name || "unknown"
	].filter(Boolean);
	const params = getParams({
		paramsType,
		paramsCasing,
		pathParamsType,
		typeSchemas,
		isConfigurable
	});
	const urlParams = Url.getParams({
		paramsType,
		paramsCasing,
		pathParamsType,
		typeSchemas
	});
	const clientParams = _kubb_react_fabric.FunctionParams.factory({ config: {
		mode: "object",
		children: {
			method: { value: JSON.stringify(operation.method.toUpperCase()) },
			url: { value: urlName ? `${urlName}(${urlParams.toCall()}).url.toString()` : path.template },
			baseURL: baseURL && !urlName ? { value: `\`${baseURL}\`` } : void 0,
			params: typeSchemas.queryParams?.name ? {} : void 0,
			data: typeSchemas.request?.name ? { value: isFormData ? "formData as FormData" : "requestData" } : void 0,
			requestConfig: isConfigurable ? { mode: "inlineSpread" } : void 0,
			headers: headers.length ? { value: isConfigurable ? `{ ${headers.join(", ")}, ...requestConfig.headers }` : `{ ${headers.join(", ")} }` } : void 0
		}
	} });
	const childrenElement = children ? children : /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric_jsx_runtime.Fragment, { children: [
		dataReturnType === "full" && parser === "zod" && zodSchemas && `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`,
		dataReturnType === "data" && parser === "zod" && zodSchemas && `return ${zodSchemas.response.name}.parse(res.data)`,
		dataReturnType === "full" && parser === "client" && "return res",
		dataReturnType === "data" && parser === "client" && "return res.data"
	] });
	return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}), /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
		name,
		isExportable,
		isIndexable,
		children: /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.Function, {
			name,
			async: true,
			export: isExportable,
			params: params.toConstructor(),
			JSDoc: { comments: (0, _kubb_plugin_oas_utils.getComments)(operation) },
			returnType,
			children: [
				isConfigurable ? "const { client: request = fetch, ...requestConfig } = config" : "",
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				parser === "zod" && zodSchemas?.request?.name ? `const requestData = ${zodSchemas.request.name}.parse(data)` : typeSchemas?.request?.name && "const requestData = data",
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				isFormData && typeSchemas?.request?.name && "const formData = buildFormData(requestData)",
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				isConfigurable ? `const res = await request<${generics.join(", ")}>(${clientParams.toCall()})` : `const res = await fetch<${generics.join(", ")}>(${clientParams.toCall()})`,
				/* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)("br", {}),
				childrenElement
			]
		})
	})] });
}
Client.getParams = getParams;

//#endregion
//#region src/components/ClassClient.tsx
function buildHeaders$1(contentType, hasHeaderParams) {
	return [contentType !== "application/json" && contentType !== "multipart/form-data" ? `'Content-Type': '${contentType}'` : void 0, hasHeaderParams ? "...headers" : void 0].filter(Boolean);
}
require_chunk.__name(buildHeaders$1, "buildHeaders");
function buildGenerics$1(typeSchemas) {
	const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(" | ") || "Error"}>`;
	return [
		typeSchemas.response.name,
		TError,
		typeSchemas.request?.name || "unknown"
	].filter(Boolean);
}
require_chunk.__name(buildGenerics$1, "buildGenerics");
function buildClientParams$1({ operation, path, baseURL, typeSchemas, isFormData, headers }) {
	return _kubb_react_fabric.FunctionParams.factory({ config: {
		mode: "object",
		children: {
			method: { value: JSON.stringify(operation.method.toUpperCase()) },
			url: { value: path.template },
			baseURL: baseURL ? { value: JSON.stringify(baseURL) } : void 0,
			params: typeSchemas.queryParams?.name ? {} : void 0,
			data: typeSchemas.request?.name ? { value: isFormData ? "formData as FormData" : "requestData" } : void 0,
			requestConfig: { mode: "inlineSpread" },
			headers: headers.length ? { value: `{ ${headers.join(", ")}, ...requestConfig.headers }` } : void 0
		}
	} });
}
require_chunk.__name(buildClientParams$1, "buildClientParams");
function buildRequestDataLine$1({ parser, zodSchemas, typeSchemas }) {
	if (parser === "zod" && zodSchemas?.request?.name) return `const requestData = ${zodSchemas.request.name}.parse(data)`;
	if (typeSchemas?.request?.name) return "const requestData = data";
	return "";
}
require_chunk.__name(buildRequestDataLine$1, "buildRequestDataLine");
function buildFormDataLine$1(isFormData, hasRequest) {
	return isFormData && hasRequest ? "const formData = buildFormData(requestData)" : "";
}
require_chunk.__name(buildFormDataLine$1, "buildFormDataLine");
function buildReturnStatement$1({ dataReturnType, parser, zodSchemas }) {
	if (dataReturnType === "full" && parser === "zod" && zodSchemas) return `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`;
	if (dataReturnType === "data" && parser === "zod" && zodSchemas) return `return ${zodSchemas.response.name}.parse(res.data)`;
	if (dataReturnType === "full" && parser === "client") return "return res";
	return "return res.data";
}
require_chunk.__name(buildReturnStatement$1, "buildReturnStatement");
function generateMethod$1({ operation, name, typeSchemas, zodSchemas, baseURL, dataReturnType, parser, paramsType, paramsCasing, pathParamsType }) {
	const path = new _kubb_core_utils.URLPath(operation.path, { casing: paramsCasing });
	const contentType = operation.getContentType();
	const isFormData = contentType === "multipart/form-data";
	const headers = buildHeaders$1(contentType, !!typeSchemas.headerParams?.name);
	const generics = buildGenerics$1(typeSchemas);
	const params = ClassClient.getParams({
		paramsType,
		paramsCasing,
		pathParamsType,
		typeSchemas,
		isConfigurable: true
	});
	const clientParams = buildClientParams$1({
		operation,
		path,
		baseURL,
		typeSchemas,
		isFormData,
		headers
	});
	const jsdoc = (0, _kubb_core_utils.buildJSDoc)((0, _kubb_plugin_oas_utils.getComments)(operation));
	const requestDataLine = buildRequestDataLine$1({
		parser,
		zodSchemas,
		typeSchemas
	});
	const formDataLine = buildFormDataLine$1(isFormData, !!typeSchemas?.request?.name);
	const returnStatement = buildReturnStatement$1({
		dataReturnType,
		parser,
		zodSchemas
	});
	const methodBody = [
		"const { client: request = this.#client, ...requestConfig } = config",
		"",
		requestDataLine,
		formDataLine,
		`const res = await request<${generics.join(", ")}>(${clientParams.toCall()})`,
		returnStatement
	].filter(Boolean).map((line) => `    ${line}`).join("\n");
	return `${jsdoc}async ${name}(${params.toConstructor()}) {\n${methodBody}\n  }`;
}
require_chunk.__name(generateMethod$1, "generateMethod");
function ClassClient({ name, isExportable = true, isIndexable = true, operations, baseURL, dataReturnType, parser, paramsType, paramsCasing, pathParamsType, children }) {
	const classCode = `export class ${name} {
  #client: typeof fetch

  constructor(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
    this.#client = config.client || fetch
  }

${operations.map(({ operation, name: methodName, typeSchemas, zodSchemas }) => generateMethod$1({
		operation,
		name: methodName,
		typeSchemas,
		zodSchemas,
		baseURL,
		dataReturnType,
		parser,
		paramsType,
		paramsCasing,
		pathParamsType
	})).join("\n\n")}
}`;
	return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File.Source, {
		name,
		isExportable,
		isIndexable,
		children: [classCode, children]
	});
}
ClassClient.getParams = Client.getParams;

//#endregion
//#region src/components/Operations.tsx
function Operations({ name, operations }) {
	const operationsObject = {};
	operations.forEach((operation) => {
		operationsObject[operation.getOperationId()] = {
			path: new _kubb_core_utils.URLPath(operation.path).URL,
			method: operation.method
		};
	});
	return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.File.Source, {
		name,
		isExportable: true,
		isIndexable: true,
		children: /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsx)(_kubb_react_fabric.Const, {
			name,
			export: true,
			children: JSON.stringify(operationsObject, void 0, 2)
		})
	});
}

//#endregion
//#region src/components/StaticClassClient.tsx
function buildHeaders(contentType, hasHeaderParams) {
	return [contentType !== "application/json" && contentType !== "multipart/form-data" ? `'Content-Type': '${contentType}'` : void 0, hasHeaderParams ? "...headers" : void 0].filter(Boolean);
}
function buildGenerics(typeSchemas) {
	const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(" | ") || "Error"}>`;
	return [
		typeSchemas.response.name,
		TError,
		typeSchemas.request?.name || "unknown"
	].filter(Boolean);
}
function buildClientParams({ operation, path, baseURL, typeSchemas, isFormData, headers }) {
	return _kubb_react_fabric.FunctionParams.factory({ config: {
		mode: "object",
		children: {
			method: { value: JSON.stringify(operation.method.toUpperCase()) },
			url: { value: path.template },
			baseURL: baseURL ? { value: JSON.stringify(baseURL) } : void 0,
			params: typeSchemas.queryParams?.name ? {} : void 0,
			data: typeSchemas.request?.name ? { value: isFormData ? "formData as FormData" : "requestData" } : void 0,
			requestConfig: { mode: "inlineSpread" },
			headers: headers.length ? { value: `{ ${headers.join(", ")}, ...requestConfig.headers }` } : void 0
		}
	} });
}
function buildRequestDataLine({ parser, zodSchemas, typeSchemas }) {
	if (parser === "zod" && zodSchemas?.request?.name) return `const requestData = ${zodSchemas.request.name}.parse(data)`;
	if (typeSchemas?.request?.name) return "const requestData = data";
	return "";
}
function buildFormDataLine(isFormData, hasRequest) {
	return isFormData && hasRequest ? "const formData = buildFormData(requestData)" : "";
}
function buildReturnStatement({ dataReturnType, parser, zodSchemas }) {
	if (dataReturnType === "full" && parser === "zod" && zodSchemas) return `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`;
	if (dataReturnType === "data" && parser === "zod" && zodSchemas) return `return ${zodSchemas.response.name}.parse(res.data)`;
	if (dataReturnType === "full" && parser === "client") return "return res";
	return "return res.data";
}
function generateMethod({ operation, name, typeSchemas, zodSchemas, baseURL, dataReturnType, parser, paramsType, paramsCasing, pathParamsType }) {
	const path = new _kubb_core_utils.URLPath(operation.path, { casing: paramsCasing });
	const contentType = operation.getContentType();
	const isFormData = contentType === "multipart/form-data";
	const headers = buildHeaders(contentType, !!typeSchemas.headerParams?.name);
	const generics = buildGenerics(typeSchemas);
	const params = Client.getParams({
		paramsType,
		paramsCasing,
		pathParamsType,
		typeSchemas,
		isConfigurable: true
	});
	const clientParams = buildClientParams({
		operation,
		path,
		baseURL,
		typeSchemas,
		isFormData,
		headers
	});
	const jsdoc = (0, _kubb_core_utils.buildJSDoc)((0, _kubb_plugin_oas_utils.getComments)(operation));
	const requestDataLine = buildRequestDataLine({
		parser,
		zodSchemas,
		typeSchemas
	});
	const formDataLine = buildFormDataLine(isFormData, !!typeSchemas?.request?.name);
	const returnStatement = buildReturnStatement({
		dataReturnType,
		parser,
		zodSchemas
	});
	const methodBody = [
		"const { client: request = this.#client, ...requestConfig } = config",
		"",
		requestDataLine,
		formDataLine,
		`const res = await request<${generics.join(", ")}>(${clientParams.toCall()})`,
		returnStatement
	].filter(Boolean).map((line) => `    ${line}`).join("\n");
	return `${jsdoc}  static async ${name}(${params.toConstructor()}) {\n${methodBody}\n  }`;
}
function StaticClassClient({ name, isExportable = true, isIndexable = true, operations, baseURL, dataReturnType, parser, paramsType, paramsCasing, pathParamsType, children }) {
	const classCode = `export class ${name} {\n  static #client: typeof fetch = fetch\n\n${operations.map(({ operation, name: methodName, typeSchemas, zodSchemas }) => generateMethod({
		operation,
		name: methodName,
		typeSchemas,
		zodSchemas,
		baseURL,
		dataReturnType,
		parser,
		paramsType,
		paramsCasing,
		pathParamsType
	})).join("\n\n")}\n}`;
	return /* @__PURE__ */ (0, _kubb_react_fabric_jsx_runtime.jsxs)(_kubb_react_fabric.File.Source, {
		name,
		isExportable,
		isIndexable,
		children: [classCode, children]
	});
}
StaticClassClient.getParams = Client.getParams;

//#endregion
Object.defineProperty(exports, 'ClassClient', {
  enumerable: true,
  get: function () {
    return ClassClient;
  }
});
Object.defineProperty(exports, 'Client', {
  enumerable: true,
  get: function () {
    return Client;
  }
});
Object.defineProperty(exports, 'Operations', {
  enumerable: true,
  get: function () {
    return Operations;
  }
});
Object.defineProperty(exports, 'StaticClassClient', {
  enumerable: true,
  get: function () {
    return StaticClassClient;
  }
});
Object.defineProperty(exports, 'Url', {
  enumerable: true,
  get: function () {
    return Url;
  }
});
//# sourceMappingURL=StaticClassClient-Doy7nyLp.cjs.map