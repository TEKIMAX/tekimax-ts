{"version":3,"file":"StaticClassClient-Doy7nyLp.cjs","names":["getParams","FunctionParams","URLPath","File","Function","Const","FunctionParams","URLPath","File","Function","buildHeaders","buildGenerics","buildClientParams","FunctionParams","buildRequestDataLine","buildFormDataLine","buildReturnStatement","generateMethod","URLPath","File","URLPath","File","Const","FunctionParams","URLPath","File"],"sources":["../src/components/Url.tsx","../src/components/Client.tsx","../src/components/ClassClient.tsx","../src/components/Operations.tsx","../src/components/StaticClassClient.tsx"],"sourcesContent":["import { URLPath } from '@kubb/core/utils'\n\nimport { getDefaultValue, type Operation } from '@kubb/oas'\nimport type { OperationSchemas } from '@kubb/plugin-oas'\nimport { getPathParams } from '@kubb/plugin-oas/utils'\nimport { Const, File, Function, FunctionParams } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport type { PluginClient } from '../types.ts'\n\ntype Props = {\n  /**\n   * Name of the function\n   */\n  name: string\n  isExportable?: boolean\n  isIndexable?: boolean\n\n  baseURL: string | undefined\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['pathParamsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  typeSchemas: OperationSchemas\n  operation: Operation\n}\n\ntype GetParamsProps = {\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['paramsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  typeSchemas: OperationSchemas\n}\n\nfunction getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas }: GetParamsProps) {\n  if (paramsType === 'object') {\n    const pathParams = getPathParams(typeSchemas.pathParams, { typed: true, casing: paramsCasing })\n\n    return FunctionParams.factory({\n      data: {\n        mode: 'object',\n        children: {\n          ...pathParams,\n        },\n      },\n    })\n  }\n\n  return FunctionParams.factory({\n    pathParams: typeSchemas.pathParams?.name\n      ? {\n          mode: pathParamsType === 'object' ? 'object' : 'inlineSpread',\n          children: getPathParams(typeSchemas.pathParams, { typed: true, casing: paramsCasing }),\n          default: getDefaultValue(typeSchemas.pathParams?.schema),\n        }\n      : undefined,\n  })\n}\n\nexport function Url({\n  name,\n  isExportable = true,\n  isIndexable = true,\n  typeSchemas,\n  baseURL,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n  operation,\n}: Props): FabricReactNode {\n  const path = new URLPath(operation.path, { casing: paramsCasing })\n  const params = getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas })\n\n  return (\n    <File.Source name={name} isExportable={isExportable} isIndexable={isIndexable}>\n      <Function name={name} export={isExportable} params={params.toConstructor()}>\n        <Const name={'res'}>{`{ method: '${operation.method.toUpperCase()}', url: ${path.toTemplateString({ prefix: baseURL })} as const }`}</Const>\n        <br />\n        return res\n      </Function>\n    </File.Source>\n  )\n}\n\nUrl.getParams = getParams\n","import { URLPath } from '@kubb/core/utils'\n\nimport { getDefaultValue, isOptional, type Operation } from '@kubb/oas'\nimport type { OperationSchemas } from '@kubb/plugin-oas'\nimport { getComments, getPathParams } from '@kubb/plugin-oas/utils'\nimport { File, Function, FunctionParams } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport type { PluginClient } from '../types.ts'\nimport { Url } from './Url.tsx'\n\ntype Props = {\n  /**\n   * Name of the function\n   */\n  name: string\n  urlName?: string\n  isExportable?: boolean\n  isIndexable?: boolean\n  isConfigurable?: boolean\n  returnType?: string\n\n  baseURL: string | undefined\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['pathParamsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  typeSchemas: OperationSchemas\n  zodSchemas: OperationSchemas | undefined\n  operation: Operation\n  children?: FabricReactNode\n}\n\ntype GetParamsProps = {\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['paramsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  typeSchemas: OperationSchemas\n  isConfigurable: boolean\n}\n\nfunction getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas, isConfigurable }: GetParamsProps) {\n  if (paramsType === 'object') {\n    const pathParams = getPathParams(typeSchemas.pathParams, { typed: true, casing: paramsCasing })\n\n    const children = {\n      ...pathParams,\n      data: typeSchemas.request?.name\n        ? {\n            type: typeSchemas.request?.name,\n            optional: isOptional(typeSchemas.request?.schema),\n          }\n        : undefined,\n      params: typeSchemas.queryParams?.name\n        ? {\n            type: typeSchemas.queryParams?.name,\n            optional: isOptional(typeSchemas.queryParams?.schema),\n          }\n        : undefined,\n      headers: typeSchemas.headerParams?.name\n        ? {\n            type: typeSchemas.headerParams?.name,\n            optional: isOptional(typeSchemas.headerParams?.schema),\n          }\n        : undefined,\n    }\n\n    // Check if all children are optional or undefined\n    const allChildrenAreOptional = Object.values(children).every((child) => !child || child.optional)\n\n    return FunctionParams.factory({\n      data: {\n        mode: 'object',\n        children,\n        default: allChildrenAreOptional ? '{}' : undefined,\n      },\n      config: isConfigurable\n        ? {\n            type: typeSchemas.request?.name\n              ? `Partial<RequestConfig<${typeSchemas.request?.name}>> & { client?: typeof fetch }`\n              : 'Partial<RequestConfig> & { client?: typeof fetch }',\n            default: '{}',\n          }\n        : undefined,\n    })\n  }\n\n  return FunctionParams.factory({\n    pathParams: typeSchemas.pathParams?.name\n      ? {\n          mode: pathParamsType === 'object' ? 'object' : 'inlineSpread',\n          children: getPathParams(typeSchemas.pathParams, { typed: true, casing: paramsCasing }),\n          default: getDefaultValue(typeSchemas.pathParams?.schema),\n        }\n      : undefined,\n    data: typeSchemas.request?.name\n      ? {\n          type: typeSchemas.request?.name,\n          optional: isOptional(typeSchemas.request?.schema),\n        }\n      : undefined,\n    params: typeSchemas.queryParams?.name\n      ? {\n          type: typeSchemas.queryParams?.name,\n          optional: isOptional(typeSchemas.queryParams?.schema),\n        }\n      : undefined,\n    headers: typeSchemas.headerParams?.name\n      ? {\n          type: typeSchemas.headerParams?.name,\n          optional: isOptional(typeSchemas.headerParams?.schema),\n        }\n      : undefined,\n    config: isConfigurable\n      ? {\n          type: typeSchemas.request?.name\n            ? `Partial<RequestConfig<${typeSchemas.request?.name}>> & { client?: typeof fetch }`\n            : 'Partial<RequestConfig> & { client?: typeof fetch }',\n          default: '{}',\n        }\n      : undefined,\n  })\n}\n\nexport function Client({\n  name,\n  isExportable = true,\n  isIndexable = true,\n  returnType,\n  typeSchemas,\n  baseURL,\n  dataReturnType,\n  parser,\n  zodSchemas,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n  operation,\n  urlName,\n  children,\n  isConfigurable = true,\n}: Props): FabricReactNode {\n  const path = new URLPath(operation.path, { casing: paramsCasing })\n  const contentType = operation.getContentType()\n  const isFormData = contentType === 'multipart/form-data'\n  const headers = [\n    contentType !== 'application/json' && contentType !== 'multipart/form-data' ? `'Content-Type': '${contentType}'` : undefined,\n    typeSchemas.headerParams?.name ? '...headers' : undefined,\n  ].filter(Boolean)\n\n  const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(' | ') || 'Error'}>`\n\n  const generics = [typeSchemas.response.name, TError, typeSchemas.request?.name || 'unknown'].filter(Boolean)\n  const params = getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas, isConfigurable })\n  const urlParams = Url.getParams({\n    paramsType,\n    paramsCasing,\n    pathParamsType,\n    typeSchemas,\n  })\n  const clientParams = FunctionParams.factory({\n    config: {\n      mode: 'object',\n      children: {\n        method: {\n          value: JSON.stringify(operation.method.toUpperCase()),\n        },\n        url: {\n          value: urlName ? `${urlName}(${urlParams.toCall()}).url.toString()` : path.template,\n        },\n        baseURL:\n          baseURL && !urlName\n            ? {\n                value: `\\`${baseURL}\\``,\n              }\n            : undefined,\n        params: typeSchemas.queryParams?.name ? {} : undefined,\n        data: typeSchemas.request?.name\n          ? {\n              value: isFormData ? 'formData as FormData' : 'requestData',\n            }\n          : undefined,\n        requestConfig: isConfigurable\n          ? {\n              mode: 'inlineSpread',\n            }\n          : undefined,\n        headers: headers.length\n          ? {\n              value: isConfigurable ? `{ ${headers.join(', ')}, ...requestConfig.headers }` : `{ ${headers.join(', ')} }`,\n            }\n          : undefined,\n      },\n    },\n  })\n\n  const childrenElement = children ? (\n    children\n  ) : (\n    <>\n      {dataReturnType === 'full' && parser === 'zod' && zodSchemas && `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`}\n      {dataReturnType === 'data' && parser === 'zod' && zodSchemas && `return ${zodSchemas.response.name}.parse(res.data)`}\n      {dataReturnType === 'full' && parser === 'client' && 'return res'}\n      {dataReturnType === 'data' && parser === 'client' && 'return res.data'}\n    </>\n  )\n\n  return (\n    <>\n      <br />\n\n      <File.Source name={name} isExportable={isExportable} isIndexable={isIndexable}>\n        <Function\n          name={name}\n          async\n          export={isExportable}\n          params={params.toConstructor()}\n          JSDoc={{\n            comments: getComments(operation),\n          }}\n          returnType={returnType}\n        >\n          {isConfigurable ? 'const { client: request = fetch, ...requestConfig } = config' : ''}\n          <br />\n          <br />\n          {parser === 'zod' && zodSchemas?.request?.name\n            ? `const requestData = ${zodSchemas.request.name}.parse(data)`\n            : typeSchemas?.request?.name && 'const requestData = data'}\n          <br />\n          {isFormData && typeSchemas?.request?.name && 'const formData = buildFormData(requestData)'}\n          <br />\n          {isConfigurable\n            ? `const res = await request<${generics.join(', ')}>(${clientParams.toCall()})`\n            : `const res = await fetch<${generics.join(', ')}>(${clientParams.toCall()})`}\n          <br />\n          {childrenElement}\n        </Function>\n      </File.Source>\n    </>\n  )\n}\n\nClient.getParams = getParams\n","import { buildJSDoc, URLPath } from '@kubb/core/utils'\nimport type { Operation } from '@kubb/oas'\nimport type { OperationSchemas } from '@kubb/plugin-oas'\nimport { getComments } from '@kubb/plugin-oas/utils'\nimport { File, FunctionParams } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport type { PluginClient } from '../types.ts'\n\nimport { Client } from './Client.tsx'\n\ntype Props = {\n  /**\n   * Name of the class\n   */\n  name: string\n  isExportable?: boolean\n  isIndexable?: boolean\n  operations: Array<{\n    operation: Operation\n    name: string\n    typeSchemas: OperationSchemas\n    zodSchemas: OperationSchemas | undefined\n  }>\n  baseURL: string | undefined\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['pathParamsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  children?: FabricReactNode\n}\n\ntype GenerateMethodProps = {\n  operation: Operation\n  name: string\n  typeSchemas: OperationSchemas\n  zodSchemas: OperationSchemas | undefined\n  baseURL: string | undefined\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  paramsType: PluginClient['resolvedOptions']['paramsType']\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n}\n\nfunction buildHeaders(contentType: string, hasHeaderParams: boolean): Array<string> {\n  return [\n    contentType !== 'application/json' && contentType !== 'multipart/form-data' ? `'Content-Type': '${contentType}'` : undefined,\n    hasHeaderParams ? '...headers' : undefined,\n  ].filter(Boolean) as Array<string>\n}\n\nfunction buildGenerics(typeSchemas: OperationSchemas): Array<string> {\n  const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(' | ') || 'Error'}>`\n  return [typeSchemas.response.name, TError, typeSchemas.request?.name || 'unknown'].filter(Boolean)\n}\n\nfunction buildClientParams({\n  operation,\n  path,\n  baseURL,\n  typeSchemas,\n  isFormData,\n  headers,\n}: {\n  operation: Operation\n  path: URLPath\n  baseURL: string | undefined\n  typeSchemas: OperationSchemas\n  isFormData: boolean\n  headers: Array<string>\n}) {\n  return FunctionParams.factory({\n    config: {\n      mode: 'object',\n      children: {\n        method: {\n          value: JSON.stringify(operation.method.toUpperCase()),\n        },\n        url: {\n          value: path.template,\n        },\n        baseURL: baseURL\n          ? {\n              value: JSON.stringify(baseURL),\n            }\n          : undefined,\n        params: typeSchemas.queryParams?.name ? {} : undefined,\n        data: typeSchemas.request?.name\n          ? {\n              value: isFormData ? 'formData as FormData' : 'requestData',\n            }\n          : undefined,\n        requestConfig: {\n          mode: 'inlineSpread',\n        },\n        headers: headers.length\n          ? {\n              value: `{ ${headers.join(', ')}, ...requestConfig.headers }`,\n            }\n          : undefined,\n      },\n    },\n  })\n}\n\nfunction buildRequestDataLine({\n  parser,\n  zodSchemas,\n  typeSchemas,\n}: {\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  zodSchemas: OperationSchemas | undefined\n  typeSchemas: OperationSchemas\n}): string {\n  if (parser === 'zod' && zodSchemas?.request?.name) {\n    return `const requestData = ${zodSchemas.request.name}.parse(data)`\n  }\n  if (typeSchemas?.request?.name) {\n    return 'const requestData = data'\n  }\n  return ''\n}\n\nfunction buildFormDataLine(isFormData: boolean, hasRequest: boolean): string {\n  return isFormData && hasRequest ? 'const formData = buildFormData(requestData)' : ''\n}\n\nfunction buildReturnStatement({\n  dataReturnType,\n  parser,\n  zodSchemas,\n}: {\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  zodSchemas: OperationSchemas | undefined\n}): string {\n  if (dataReturnType === 'full' && parser === 'zod' && zodSchemas) {\n    return `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`\n  }\n  if (dataReturnType === 'data' && parser === 'zod' && zodSchemas) {\n    return `return ${zodSchemas.response.name}.parse(res.data)`\n  }\n  if (dataReturnType === 'full' && parser === 'client') {\n    return 'return res'\n  }\n  return 'return res.data'\n}\n\nfunction generateMethod({\n  operation,\n  name,\n  typeSchemas,\n  zodSchemas,\n  baseURL,\n  dataReturnType,\n  parser,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n}: GenerateMethodProps): string {\n  const path = new URLPath(operation.path, { casing: paramsCasing })\n  const contentType = operation.getContentType()\n  const isFormData = contentType === 'multipart/form-data'\n  const headers = buildHeaders(contentType, !!typeSchemas.headerParams?.name)\n  const generics = buildGenerics(typeSchemas)\n  const params = ClassClient.getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas, isConfigurable: true })\n  const clientParams = buildClientParams({ operation, path, baseURL, typeSchemas, isFormData, headers })\n  const jsdoc = buildJSDoc(getComments(operation))\n\n  const requestDataLine = buildRequestDataLine({ parser, zodSchemas, typeSchemas })\n  const formDataLine = buildFormDataLine(isFormData, !!typeSchemas?.request?.name)\n  const returnStatement = buildReturnStatement({ dataReturnType, parser, zodSchemas })\n\n  const methodBody = [\n    'const { client: request = this.#client, ...requestConfig } = config',\n    '',\n    requestDataLine,\n    formDataLine,\n    `const res = await request<${generics.join(', ')}>(${clientParams.toCall()})`,\n    returnStatement,\n  ]\n    .filter(Boolean)\n    .map((line) => `    ${line}`)\n    .join('\\n')\n\n  return `${jsdoc}async ${name}(${params.toConstructor()}) {\\n${methodBody}\\n  }`\n}\n\nexport function ClassClient({\n  name,\n  isExportable = true,\n  isIndexable = true,\n  operations,\n  baseURL,\n  dataReturnType,\n  parser,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n  children,\n}: Props): FabricReactNode {\n  const methods = operations.map(({ operation, name: methodName, typeSchemas, zodSchemas }) =>\n    generateMethod({\n      operation,\n      name: methodName,\n      typeSchemas,\n      zodSchemas,\n      baseURL,\n      dataReturnType,\n      parser,\n      paramsType,\n      paramsCasing,\n      pathParamsType,\n    }),\n  )\n\n  const classCode = `export class ${name} {\n  #client: typeof fetch\n\n  constructor(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {\n    this.#client = config.client || fetch\n  }\n\n${methods.join('\\n\\n')}\n}`\n\n  return (\n    <File.Source name={name} isExportable={isExportable} isIndexable={isIndexable}>\n      {classCode}\n      {children}\n    </File.Source>\n  )\n}\nClassClient.getParams = Client.getParams\n","import { URLPath } from '@kubb/core/utils'\nimport type { HttpMethod, Operation } from '@kubb/oas'\nimport { Const, File } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\n\ntype OperationsProps = {\n  name: string\n  operations: Array<Operation>\n}\n\nexport function Operations({ name, operations }: OperationsProps): FabricReactNode {\n  const operationsObject: Record<string, { path: string; method: HttpMethod }> = {}\n\n  operations.forEach((operation) => {\n    operationsObject[operation.getOperationId()] = {\n      path: new URLPath(operation.path).URL,\n      method: operation.method,\n    }\n  })\n\n  return (\n    <File.Source name={name} isExportable isIndexable>\n      <Const name={name} export>\n        {JSON.stringify(operationsObject, undefined, 2)}\n      </Const>\n    </File.Source>\n  )\n}\n","import { buildJSDoc, URLPath } from '@kubb/core/utils'\nimport type { Operation } from '@kubb/oas'\nimport type { OperationSchemas } from '@kubb/plugin-oas'\nimport { getComments } from '@kubb/plugin-oas/utils'\nimport { File, FunctionParams } from '@kubb/react-fabric'\nimport type { FabricReactNode } from '@kubb/react-fabric/types'\nimport type { PluginClient } from '../types.ts'\nimport { Client } from './Client.tsx'\n\ntype Props = {\n  name: string\n  isExportable?: boolean\n  isIndexable?: boolean\n  operations: Array<{\n    operation: Operation\n    name: string\n    typeSchemas: OperationSchemas\n    zodSchemas: OperationSchemas | undefined\n  }>\n  baseURL: string | undefined\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  paramsType: PluginClient['resolvedOptions']['pathParamsType']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  children?: FabricReactNode\n}\n\ntype GenerateMethodProps = {\n  operation: Operation\n  name: string\n  typeSchemas: OperationSchemas\n  zodSchemas: OperationSchemas | undefined\n  baseURL: string | undefined\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  paramsType: PluginClient['resolvedOptions']['paramsType']\n  paramsCasing: PluginClient['resolvedOptions']['paramsCasing']\n  pathParamsType: PluginClient['resolvedOptions']['pathParamsType']\n}\n\nfunction buildHeaders(contentType: string, hasHeaderParams: boolean): Array<string> {\n  return [\n    contentType !== 'application/json' && contentType !== 'multipart/form-data' ? `'Content-Type': '${contentType}'` : undefined,\n    hasHeaderParams ? '...headers' : undefined,\n  ].filter(Boolean) as Array<string>\n}\n\nfunction buildGenerics(typeSchemas: OperationSchemas): Array<string> {\n  const TError = `ResponseErrorConfig<${typeSchemas.errors?.map((item) => item.name).join(' | ') || 'Error'}>`\n  return [typeSchemas.response.name, TError, typeSchemas.request?.name || 'unknown'].filter(Boolean)\n}\n\nfunction buildClientParams({\n  operation,\n  path,\n  baseURL,\n  typeSchemas,\n  isFormData,\n  headers,\n}: {\n  operation: Operation\n  path: URLPath\n  baseURL: string | undefined\n  typeSchemas: OperationSchemas\n  isFormData: boolean\n  headers: Array<string>\n}) {\n  return FunctionParams.factory({\n    config: {\n      mode: 'object',\n      children: {\n        method: {\n          value: JSON.stringify(operation.method.toUpperCase()),\n        },\n        url: {\n          value: path.template,\n        },\n        baseURL: baseURL\n          ? {\n              value: JSON.stringify(baseURL),\n            }\n          : undefined,\n        params: typeSchemas.queryParams?.name ? {} : undefined,\n        data: typeSchemas.request?.name\n          ? {\n              value: isFormData ? 'formData as FormData' : 'requestData',\n            }\n          : undefined,\n        requestConfig: {\n          mode: 'inlineSpread',\n        },\n        headers: headers.length\n          ? {\n              value: `{ ${headers.join(', ')}, ...requestConfig.headers }`,\n            }\n          : undefined,\n      },\n    },\n  })\n}\n\nfunction buildRequestDataLine({\n  parser,\n  zodSchemas,\n  typeSchemas,\n}: {\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  zodSchemas: OperationSchemas | undefined\n  typeSchemas: OperationSchemas\n}): string {\n  if (parser === 'zod' && zodSchemas?.request?.name) {\n    return `const requestData = ${zodSchemas.request.name}.parse(data)`\n  }\n  if (typeSchemas?.request?.name) {\n    return 'const requestData = data'\n  }\n  return ''\n}\n\nfunction buildFormDataLine(isFormData: boolean, hasRequest: boolean): string {\n  return isFormData && hasRequest ? 'const formData = buildFormData(requestData)' : ''\n}\n\nfunction buildReturnStatement({\n  dataReturnType,\n  parser,\n  zodSchemas,\n}: {\n  dataReturnType: PluginClient['resolvedOptions']['dataReturnType']\n  parser: PluginClient['resolvedOptions']['parser'] | undefined\n  zodSchemas: OperationSchemas | undefined\n}): string {\n  if (dataReturnType === 'full' && parser === 'zod' && zodSchemas) {\n    return `return {...res, data: ${zodSchemas.response.name}.parse(res.data)}`\n  }\n  if (dataReturnType === 'data' && parser === 'zod' && zodSchemas) {\n    return `return ${zodSchemas.response.name}.parse(res.data)`\n  }\n  if (dataReturnType === 'full' && parser === 'client') {\n    return 'return res'\n  }\n  return 'return res.data'\n}\n\nfunction generateMethod({\n  operation,\n  name,\n  typeSchemas,\n  zodSchemas,\n  baseURL,\n  dataReturnType,\n  parser,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n}: GenerateMethodProps): string {\n  const path = new URLPath(operation.path, { casing: paramsCasing })\n  const contentType = operation.getContentType()\n  const isFormData = contentType === 'multipart/form-data'\n  const headers = buildHeaders(contentType, !!typeSchemas.headerParams?.name)\n  const generics = buildGenerics(typeSchemas)\n  const params = Client.getParams({ paramsType, paramsCasing, pathParamsType, typeSchemas, isConfigurable: true })\n  const clientParams = buildClientParams({ operation, path, baseURL, typeSchemas, isFormData, headers })\n  const jsdoc = buildJSDoc(getComments(operation))\n\n  const requestDataLine = buildRequestDataLine({ parser, zodSchemas, typeSchemas })\n  const formDataLine = buildFormDataLine(isFormData, !!typeSchemas?.request?.name)\n  const returnStatement = buildReturnStatement({ dataReturnType, parser, zodSchemas })\n\n  const methodBody = [\n    'const { client: request = this.#client, ...requestConfig } = config',\n    '',\n    requestDataLine,\n    formDataLine,\n    `const res = await request<${generics.join(', ')}>(${clientParams.toCall()})`,\n    returnStatement,\n  ]\n    .filter(Boolean)\n    .map((line) => `    ${line}`)\n    .join('\\n')\n\n  // Indent static method by 2 spaces, body by 4 spaces (matching snapshot)\n  return `${jsdoc}  static async ${name}(${params.toConstructor()}) {\\n${methodBody}\\n  }`\n}\n\nexport function StaticClassClient({\n  name,\n  isExportable = true,\n  isIndexable = true,\n  operations,\n  baseURL,\n  dataReturnType,\n  parser,\n  paramsType,\n  paramsCasing,\n  pathParamsType,\n  children,\n}: Props): FabricReactNode {\n  const methods = operations.map(({ operation, name: methodName, typeSchemas, zodSchemas }) =>\n    generateMethod({\n      operation,\n      name: methodName,\n      typeSchemas,\n      zodSchemas,\n      baseURL,\n      dataReturnType,\n      parser,\n      paramsType,\n      paramsCasing,\n      pathParamsType,\n    }),\n  )\n\n  const classCode = `export class ${name} {\\n  static #client: typeof fetch = fetch\\n\\n${methods.join('\\n\\n')}\\n}`\n\n  return (\n    <File.Source name={name} isExportable={isExportable} isIndexable={isIndexable}>\n      {classCode}\n      {children}\n    </File.Source>\n  )\n}\nStaticClassClient.getParams = Client.getParams\n"],"mappings":"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"}