import { t as __name } from "./chunk-iVr_oF3V.js";
import { Fabric } from "@kubb/react-fabric";
import * as oas_normalize_lib_types0 from "oas-normalize/lib/types";
import BaseOas from "oas";
import { Operation } from "oas/operation";
import { DiscriminatorObject, HttpMethods, OASDocument, SchemaObject } from "oas/types";
import { KubbFile } from "@kubb/fabric-core/types";
import { FabricReactNode } from "@kubb/react-fabric/types";

//#region ../oas/src/types.d.ts
type contentType = 'application/json' | (string & {});
type SchemaObject$1 = SchemaObject & {
  'x-nullable'?: boolean;
  $ref?: string;
};
type HttpMethod = HttpMethods;
type Document = OASDocument;
type Operation$1 = Operation;
type DiscriminatorObject$1 = DiscriminatorObject;
//#endregion
//#region ../oas/src/Oas.d.ts
type OasOptions = {
  contentType?: contentType;
  discriminator?: 'strict' | 'inherit';
  /**
   * Resolve name collisions when schemas from different components share the same name (case-insensitive).
   * @default false
   */
  collisionDetection?: boolean;
};
declare class Oas extends BaseOas {
  #private;
  document: Document;
  constructor(document: Document);
  setOptions(options: OasOptions): void;
  get options(): OasOptions;
  get<T = unknown>($ref: string): T | null;
  getKey($ref: string): string | undefined;
  set($ref: string, value: unknown): false | undefined;
  getDiscriminator(schema: SchemaObject$1 | null): DiscriminatorObject$1 | null;
  dereferenceWithRef<T = unknown>(schema?: T): T;
  getResponseSchema(operation: Operation$1, statusCode: string | number): SchemaObject$1;
  getRequestSchema(operation: Operation$1): SchemaObject$1 | undefined;
  getParametersSchema(operation: Operation$1, inKey: 'path' | 'query' | 'header'): SchemaObject$1 | null;
  validate(): Promise<oas_normalize_lib_types0.ValidationResult>;
  flattenSchema(schema: SchemaObject$1 | null): SchemaObject$1 | null;
  /**
   * Get schemas from OpenAPI components (schemas, responses, requestBodies).
   * Returns schemas in dependency order along with name mapping for collision resolution.
   */
  getSchemas(options?: {
    contentType?: contentType;
    includes?: Array<'schemas' | 'responses' | 'requestBodies'>;
    collisionDetection?: boolean;
  }): {
    schemas: Record<string, SchemaObject$1>;
    nameMapping: Map<string, string>;
  };
}
//#endregion
//#region ../core/src/BaseGenerator.d.ts
/**
 * Abstract class that contains the building blocks for plugins to create their own Generator
 * @link idea based on https://github.com/colinhacks/zod/blob/master/src/types.ts#L137
 */
declare abstract class BaseGenerator<TOptions = unknown, TContext = unknown> {
  #private;
  constructor(options?: TOptions, context?: TContext);
  get options(): TOptions;
  get context(): TContext;
  set options(options: TOptions);
  abstract build(...params: unknown[]): unknown;
}
//#endregion
//#region ../core/src/Kubb.d.ts
type DebugEvent = {
  date: Date;
  logs: string[];
  fileName?: string;
};
type ProgressStartMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  hookName: H;
  plugins: Array<Plugin>;
};
type ProgressStopMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  hookName: H;
};
type ExecutingMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  strategy: Strategy;
  hookName: H;
  plugin: Plugin;
  parameters?: unknown[] | undefined;
  output?: unknown;
};
type ExecutedMeta<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {
  duration: number;
  strategy: Strategy;
  hookName: H;
  plugin: Plugin;
  parameters?: unknown[] | undefined;
  output?: unknown;
};
/**
 * Events emitted during the Kubb code generation lifecycle.
 * These events can be listened to for logging, progress tracking, and custom integrations.
 *
 * @example
 * ```typescript
 * import type { AsyncEventEmitter } from '@kubb/core'
 * import type { KubbEvents } from '@kubb/core'
 *
 * const events: AsyncEventEmitter<KubbEvents> = new AsyncEventEmitter()
 *
 * events.on('lifecycle:start', () => {
 *   console.log('Starting Kubb generation')
 * })
 *
 * events.on('plugin:end', (plugin, { duration }) => {
 *   console.log(`Plugin ${plugin.name} completed in ${duration}ms`)
 * })
 * ```
 */
interface KubbEvents {
  /**
   * Emitted at the beginning of the Kubb lifecycle, before any code generation starts.
   */
  'lifecycle:start': [version: string];
  /**
   * Emitted at the end of the Kubb lifecycle, after all code generation is complete.
   */
  'lifecycle:end': [];
  /**
   * Emitted when configuration loading starts.
   */
  'config:start': [];
  /**
   * Emitted when configuration loading is complete.
   */
  'config:end': [configs: Array<Config>];
  /**
   * Emitted when code generation phase starts.
   */
  'generation:start': [config: Config];
  /**
   * Emitted when code generation phase completes.
   */
  'generation:end': [Config: Config];
  /**
   * Emitted with a summary of the generation results.
   * Contains summary lines, title, and success status.
   */
  'generation:summary': [Config: Config, {
    failedPlugins: Set<{
      plugin: Plugin;
      error: Error;
    }>;
    status: 'success' | 'failed';
    hrStart: [number, number];
    filesCreated: number;
    pluginTimings?: Map<string, number>;
  }];
  /**
   * Emitted when code formatting starts (e.g., running Biome or Prettier).
   */
  'format:start': [];
  /**
   * Emitted when code formatting completes.
   */
  'format:end': [];
  /**
   * Emitted when linting starts.
   */
  'lint:start': [];
  /**
   * Emitted when linting completes.
   */
  'lint:end': [];
  /**
   * Emitted when plugin hooks execution starts.
   */
  'hooks:start': [];
  /**
   * Emitted when plugin hooks execution completes.
   */
  'hooks:end': [];
  /**
   * Emitted when a single hook execution starts. (e.g., format or lint).
   * The callback should be invoked when the command completes.
   */
  'hook:start': [{
    id?: string;
    command: string;
    args?: readonly string[];
  }];
  /**
   * Emitted when a single hook execution completes.
   */
  'hook:end': [{
    id?: string;
    command: string;
    args?: readonly string[];
    success: boolean;
    error: Error | null;
  }];
  /**
   * Emitted when a new version of Kubb is available.
   */
  'version:new': [currentVersion: string, latestVersion: string];
  /**
   * Informational message event.
   */
  info: [message: string, info?: string];
  /**
   * Error event. Emitted when an error occurs during code generation.
   */
  error: [error: Error, meta?: Record<string, unknown>];
  /**
   * Success message event.
   */
  success: [message: string, info?: string];
  /**
   * Warning message event.
   */
  warn: [message: string, info?: string];
  /**
   * Debug event for detailed logging.
   * Contains timestamp, log messages, and optional filename.
   */
  debug: [meta: DebugEvent];
  /**
   * Emitted when file processing starts.
   * Contains the list of files to be processed.
   */
  'files:processing:start': [files: Array<KubbFile.ResolvedFile>];
  /**
   * Emitted for each file being processed, providing progress updates.
   * Contains processed count, total count, percentage, and file details.
   */
  'file:processing:update': [{
    /** Number of files processed so far */
    processed: number;
    /** Total number of files to process */
    total: number;
    /** Processing percentage (0-100) */
    percentage: number;
    /** Optional source identifier */
    source?: string;
    /** The file being processed */
    file: KubbFile.ResolvedFile;
    /**
     * Kubb configuration (not present in Fabric).
     * Provides access to the current config during file processing.
     */
    config: Config;
  }];
  /**
   * Emitted when file processing completes.
   * Contains the list of processed files.
   */
  'files:processing:end': [files: KubbFile.ResolvedFile[]];
  /**
   * Emitted when a plugin starts executing.
   */
  'plugin:start': [plugin: Plugin];
  /**
   * Emitted when a plugin completes execution.
   * Duration in ms
   */
  'plugin:end': [plugin: Plugin, meta: {
    duration: number;
    success: boolean;
    error?: Error;
  }];
  /**
   * Emitted when plugin hook progress tracking starts.
   * Contains the hook name and list of plugins to execute.
   */
  'plugins:hook:progress:start': [meta: ProgressStartMeta];
  /**
   * Emitted when plugin hook progress tracking ends.
   * Contains the hook name that completed.
   */
  'plugins:hook:progress:end': [meta: ProgressStopMeta];
  /**
   * Emitted when a plugin hook starts processing.
   * Contains strategy, hook name, plugin, parameters, and output.
   */
  'plugins:hook:processing:start': [meta: ExecutingMeta];
  /**
   * Emitted when a plugin hook completes processing.
   * Contains duration, strategy, hook name, plugin, parameters, and output.
   */
  'plugins:hook:processing:end': [meta: ExecutedMeta];
}
//#endregion
//#region ../core/src/utils/AsyncEventEmitter.d.ts
declare class AsyncEventEmitter<TEvents extends Record<string, any>> {
  #private;
  constructor(maxListener?: number);
  emit<TEventName extends keyof TEvents & string>(eventName: TEventName, ...eventArgs: TEvents[TEventName]): Promise<void>;
  on<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  onOnce<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArgs: TEvents[TEventName]) => void): void;
  off<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  removeAll(): void;
}
//#endregion
//#region ../core/src/utils/types.d.ts
type PossiblePromise<T> = Promise<T> | T;
//#endregion
//#region ../core/src/types.d.ts
declare global {
  namespace Kubb {
    interface PluginContext {}
  }
}
/**
 * Config used in `kubb.config.ts`
 *
 * @example
 * import { defineConfig } from '@kubb/core'
 * export default defineConfig({
 * ...
 * })
 */

type InputPath = {
  /**
   * Specify your Swagger/OpenAPI file, either as an absolute path or a path relative to the root.
   */
  path: string;
};
type InputData = {
  /**
   * A `string` or `object` that contains your Swagger/OpenAPI data.
   */
  data: string | unknown;
};
type Input = InputPath | InputData | Array<InputPath>;
type BarrelType = 'all' | 'named' | 'propagate';
/**
 * @private
 */
type Config<TInput = Input> = {
  /**
   * The name to display in the CLI output.
   */
  name?: string;
  /**
   * The project root directory, which can be either an absolute path or a path relative to the location of your `kubb.config.ts` file.
   * @default process.cwd()
   */
  root: string;
  /**
   * You can use either `input.path` or `input.data`, depending on your specific needs.
   */
  input: TInput;
  output: {
    /**
     * The path where all generated files receives exported.
     * This can be an absolute path or a path relative to the specified root option.
     */
    path: string;
    /**
     * Clean the output directory before each build.
     */
    clean?: boolean;
    /**
     * Save files to the file system.
     * @default true
     */
    write?: boolean;
    /**
     * Specifies the formatting tool to be used.
     * - 'auto' automatically detects and uses biome or prettier (in that order of preference).
     * - 'prettier' uses Prettier for code formatting.
     * - 'biome' uses Biome for code formatting.
     * - 'oxfmt' uses Oxfmt for code formatting.
     * - false disables code formatting.
     * @default 'prettier'
     */
    format?: 'auto' | 'prettier' | 'biome' | 'oxfmt' | false;
    /**
     * Specifies the linter that should be used to analyze the code.
     * - 'auto' automatically detects and uses biome, oxlint, or eslint (in that order of preference).
     * - 'eslint' uses ESLint for linting.
     * - 'biome' uses Biome for linting.
     * - 'oxlint' uses Oxlint for linting.
     * - false disables linting.
     * @default 'auto'
     */
    lint?: 'auto' | 'eslint' | 'biome' | 'oxlint' | false;
    /**
     * Overrides the extension for generated imports and exports. By default, each plugin adds an extension.
     * @default { '.ts': '.ts'}
     */
    extension?: Record<KubbFile.Extname, KubbFile.Extname | ''>;
    /**
     * Configures how `index.ts` files are created, including disabling barrel file generation. Each plugin has its own `barrelType` option; this setting controls the root barrel file (e.g., `src/gen/index.ts`).
     * @default 'named'
     */
    barrelType?: Exclude<BarrelType, 'propagate'> | false;
    /**
     * Adds a default banner to the start of every generated file indicating it was generated by Kubb.
     * - 'simple' adds banner with link to Kubb.
     * - 'full' adds source, title, description, and OpenAPI version.
     * - false disables banner generation.
     * @default 'simple'
     */
    defaultBanner?: 'simple' | 'full' | false;
    /**
     * Whether to override existing external files if they already exist.
     * When setting the option in the global configuration, all plugins inherit the same behavior by default.
     * However, all plugins also have an `output.override` option, which can be used to override the behavior for a specific plugin.
     * @default false
     */
    override?: boolean;
  };
  /**
   * An array of Kubb plugins that used in the generation.
   * Each plugin may include additional configurable options(defined in the plugin itself).
   * If a plugin depends on another plugin, an error is returned if the required dependency is missing. See pre for more details.
   */
  plugins?: Array<Plugin>;
  /**
   * Hooks triggered when a specific action occurs in Kubb.
   */
  hooks?: {
    /**
     * Hook that triggers at the end of all executions.
     * Useful for running Prettier or ESLint to format/lint your code.
     */
    done?: string | Array<string>;
  };
};
type PluginFactoryOptions<
/**
 * Name to be used for the plugin, this will also be used for they key.
 */
TName extends string = string,
/**
 * Options of the plugin.
 */
TOptions extends object = object,
/**
 * Options of the plugin that can be used later on, see `options` inside your plugin config.
 */
TResolvedOptions extends object = TOptions,
/**
 * Context that you want to expose to other plugins.
 */
TContext = any,
/**
 * When calling `resolvePath` you can specify better types.
 */
TResolvePathOptions extends object = object> = {
  name: TName;
  /**
   * Same behavior like what has been done with `QueryKey` in `@tanstack/react-query`
   */
  key: PluginKey<TName | string>;
  options: TOptions;
  resolvedOptions: TResolvedOptions;
  context: TContext;
  resolvePathOptions: TResolvePathOptions;
};
type PluginKey<TName> = [name: TName, identifier?: string | number];
type UserPlugin<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  /**
   * Unique name used for the plugin
   * The name of the plugin follows the format scope:foo-bar or foo-bar, adding scope: can avoid naming conflicts with other plugins.
   * @example @kubb/typescript
   */
  name: TOptions['name'];
  /**
   * Options set for a specific plugin(see kubb.config.js), passthrough of options.
   */
  options: TOptions['resolvedOptions'];
  /**
   * Specifies the preceding plugins for the current plugin. You can pass an array of preceding plugin names, and the current plugin is executed after these plugins.
   * Can be used to validate dependent plugins.
   */
  pre?: Array<string>;
  /**
   * Specifies the succeeding plugins for the current plugin. You can pass an array of succeeding plugin names, and the current plugin is executed before these plugins.
   */
  post?: Array<string>;
  inject?: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => TOptions['context'];
};
type UserPluginWithLifeCycle<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = UserPlugin<TOptions> & PluginLifecycle<TOptions>;
type Plugin<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  /**
   * Unique name used for the plugin
   * @example @kubb/typescript
   */
  name: TOptions['name'];
  /**
   * Internal key used when a developer uses more than one of the same plugin
   * @private
   */
  key: TOptions['key'];
  /**
   * Specifies the preceding plugins for the current plugin. You can pass an array of preceding plugin names, and the current plugin is executed after these plugins.
   * Can be used to validate dependent plugins.
   */
  pre?: Array<string>;
  /**
   * Specifies the succeeding plugins for the current plugin. You can pass an array of succeeding plugin names, and the current plugin is executed before these plugins.
   */
  post?: Array<string>;
  /**
   * Options set for a specific plugin(see kubb.config.js), passthrough of options.
   */
  options: TOptions['resolvedOptions'];
  install: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => PossiblePromise<void>;
  /**
   * Define a context that can be used by other plugins, see `PluginManager' where we convert from `UserPlugin` to `Plugin`(used when calling `definePlugin`).
   */
  inject: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => TOptions['context'];
};
type PluginWithLifeCycle<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = Plugin<TOptions> & PluginLifecycle<TOptions>;
type PluginLifecycle<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  /**
   * Start of the lifecycle of a plugin.
   * @type hookParallel
   */
  install?: (this: PluginContext<TOptions>, context: PluginContext<TOptions>) => PossiblePromise<void>;
  /**
   * Resolve to a Path based on a baseName(example: `./Pet.ts`) and directory(example: `./models`).
   * Options can als be included.
   * @type hookFirst
   * @example ('./Pet.ts', './src/gen/') => '/src/gen/Pet.ts'
   */
  resolvePath?: (this: PluginContext<TOptions>, baseName: KubbFile.BaseName, mode?: KubbFile.Mode, options?: TOptions['resolvePathOptions']) => KubbFile.Path;
  /**
   * Resolve to a name based on a string.
   * Useful when converting to PascalCase or camelCase.
   * @type hookFirst
   * @example ('pet') => 'Pet'
   */
  resolveName?: (this: PluginContext<TOptions>, name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string;
};
type PluginLifecycleHooks = keyof PluginLifecycle;
type PluginParameter<H extends PluginLifecycleHooks> = Parameters<Required<PluginLifecycle>[H]>;
type ResolvePathParams<TOptions = object> = {
  pluginKey?: Plugin['key'];
  baseName: KubbFile.BaseName;
  mode?: KubbFile.Mode;
  /**
   * Options to be passed to 'resolvePath' 3th parameter
   */
  options?: TOptions;
};
type ResolveNameParams = {
  name: string;
  pluginKey?: Plugin['key'];
  /**
   * Specifies the type of entity being named.
   * - 'file' customizes the name of the created file (uses camelCase).
   * - 'function' customizes the exported function names (uses camelCase).
   * - 'type' customizes TypeScript types (uses PascalCase).
   * - 'const' customizes variable names (uses camelCase).
   * @default undefined
   */
  type?: 'file' | 'function' | 'type' | 'const';
};
type PluginContext<TOptions extends PluginFactoryOptions = PluginFactoryOptions> = {
  fabric: Fabric;
  config: Config;
  pluginManager: PluginManager;
  /**
   * Only add when the file does not exist yet
   */
  addFile: (...file: Array<KubbFile.File>) => Promise<void>;
  /**
   * merging multiple sources into the same output file
   */
  upsertFile: (...file: Array<KubbFile.File>) => Promise<void>;
  events: AsyncEventEmitter<KubbEvents>;
  mode: KubbFile.Mode;
  /**
   * Current plugin
   */
  plugin: Plugin<TOptions>;
} & Kubb.PluginContext;
/**
 * Specify the export location for the files and define the behavior of the output
 */
type Output<TOptions> = {
  /**
   * Path to the output folder or file that will contain the generated code
   */
  path: string;
  /**
   * Define what needs to be exported, here you can also disable the export of barrel files
   * @default 'named'
   */
  barrelType?: BarrelType | false;
  /**
   * Add a banner text in the beginning of every file
   */
  banner?: string | ((options: TOptions) => string);
  /**
   * Add a footer text in the beginning of every file
   */
  footer?: string | ((options: TOptions) => string);
  /**
   * Whether to override existing external files if they already exist.
   * @default false
   */
  override?: boolean;
};
type GroupContext = {
  group: string;
};
type Group = {
  /**
   * Defines the type where to group the files.
   * - 'tag' groups files by OpenAPI tags.
   * - 'path' groups files by OpenAPI paths.
   * @default undefined
   */
  type: 'tag' | 'path';
  /**
   * Return the name of a group based on the group name, this used for the file and name generation
   */
  name?: (context: GroupContext) => string;
};
//#endregion
//#region ../core/src/PluginManager.d.ts
type RequiredPluginLifecycle = Required<PluginLifecycle>;
type Strategy = 'hookFirst' | 'hookForPlugin' | 'hookParallel' | 'hookSeq';
type ParseResult<H extends PluginLifecycleHooks> = RequiredPluginLifecycle[H];
type SafeParseResult<H extends PluginLifecycleHooks, Result = ReturnType<ParseResult<H>>> = {
  result: Result;
  plugin: Plugin;
};
type Options$1 = {
  fabric: Fabric;
  events: AsyncEventEmitter<KubbEvents>;
  /**
   * @default Number.POSITIVE_INFINITY
   */
  concurrency?: number;
};
type GetFileProps<TOptions = object> = {
  name: string;
  mode?: KubbFile.Mode;
  extname: KubbFile.Extname;
  pluginKey: Plugin['key'];
  options?: TOptions;
};
declare class PluginManager {
  #private;
  readonly config: Config;
  readonly options: Options$1;
  constructor(config: Config, options: Options$1);
  get events(): AsyncEventEmitter<KubbEvents>;
  getContext<TOptions extends PluginFactoryOptions>(plugin: Plugin<TOptions>): PluginContext<TOptions> & Record<string, any>;
  get plugins(): Array<Plugin>;
  getFile<TOptions = object>({
    name,
    mode,
    extname,
    pluginKey,
    options
  }: GetFileProps<TOptions>): KubbFile.File<{
    pluginKey: Plugin['key'];
  }>;
  resolvePath: <TOptions = object>(params: ResolvePathParams<TOptions>) => KubbFile.Path;
  resolveName: (params: ResolveNameParams) => string;
  /**
   * Run a specific hookName for plugin x.
   */
  hookForPlugin<H extends PluginLifecycleHooks>({
    pluginKey,
    hookName,
    parameters
  }: {
    pluginKey: Plugin['key'];
    hookName: H;
    parameters: PluginParameter<H>;
  }): Promise<Array<ReturnType<ParseResult<H>> | null>>;
  /**
   * Run a specific hookName for plugin x.
   */
  hookForPluginSync<H extends PluginLifecycleHooks>({
    pluginKey,
    hookName,
    parameters
  }: {
    pluginKey: Plugin['key'];
    hookName: H;
    parameters: PluginParameter<H>;
  }): Array<ReturnType<ParseResult<H>>> | null;
  /**
   * Returns the first non-null result.
   */
  hookFirst<H extends PluginLifecycleHooks>({
    hookName,
    parameters,
    skipped
  }: {
    hookName: H;
    parameters: PluginParameter<H>;
    skipped?: ReadonlySet<Plugin> | null;
  }): Promise<SafeParseResult<H>>;
  /**
   * Returns the first non-null result.
   */
  hookFirstSync<H extends PluginLifecycleHooks>({
    hookName,
    parameters,
    skipped
  }: {
    hookName: H;
    parameters: PluginParameter<H>;
    skipped?: ReadonlySet<Plugin> | null;
  }): SafeParseResult<H>;
  /**
   * Runs all plugins in parallel based on `this.plugin` order and `pre`/`post` settings.
   */
  hookParallel<H extends PluginLifecycleHooks, TOutput = void>({
    hookName,
    parameters
  }: {
    hookName: H;
    parameters?: Parameters<RequiredPluginLifecycle[H]> | undefined;
  }): Promise<Awaited<TOutput>[]>;
  /**
   * Chains plugins
   */
  hookSeq<H extends PluginLifecycleHooks>({
    hookName,
    parameters
  }: {
    hookName: H;
    parameters?: PluginParameter<H>;
  }): Promise<void>;
  getPluginByKey(pluginKey: Plugin['key']): Plugin | undefined;
  getPluginsByKey(hookName: keyof PluginWithLifeCycle, pluginKey: Plugin['key']): Plugin[];
}
//#endregion
//#region ../core/src/utils/getBarrelFiles.d.ts
type FileMetaBase = {
  pluginKey?: Plugin['key'];
};
//#endregion
//#region ../plugin-oas/src/types.d.ts
type GetOasOptions = {
  validate?: boolean;
};
type Context$2 = {
  getOas(options?: GetOasOptions): Promise<Oas>;
  getBaseURL(): Promise<string | undefined>;
};
declare global {
  namespace Kubb {
    interface PluginContext extends Context$2 {}
  }
}
type ResolvePathOptions = {
  pluginKey?: Plugin['key'];
  group?: {
    tag?: string;
    path?: string;
  };
  type?: ResolveNameParams['type'];
};
/**
 * `propertyName` is the ref name + resolved with the nameResolver
 *  @example import { Pet } from './Pet'
 *
 * `originalName` is the original name used(in PascalCase), only used to remove duplicates
 *
 * `pluginKey` can be used to override the current plugin being used, handy when you want to import a type/schema out of another plugin
 * @example import a type(plugin-ts) for a mock file(swagger-faker)
 */
type Ref = {
  propertyName: string;
  originalName: string;
  path: KubbFile.Path;
  pluginKey?: Plugin['key'];
};
type Refs = Record<string, Ref>;
type OperationSchema = {
  /**
   * Converted name, contains already `PathParams`, `QueryParams`, ...
   */
  name: string;
  schema: SchemaObject$1;
  operation?: Operation$1;
  /**
   * OperationName in PascalCase, only being used in OperationGenerator
   */
  operationName: string;
  description?: string;
  statusCode?: number;
  keys?: string[];
  keysToOmit?: string[];
  withData?: boolean;
};
type OperationSchemas = {
  pathParams?: OperationSchema & {
    keysToOmit?: never;
  };
  queryParams?: OperationSchema & {
    keysToOmit?: never;
  };
  headerParams?: OperationSchema & {
    keysToOmit?: never;
  };
  request?: OperationSchema;
  response: OperationSchema;
  responses: Array<OperationSchema>;
  statusCodes?: Array<OperationSchema>;
  errors?: Array<OperationSchema>;
};
type ByTag = {
  type: 'tag';
  pattern: string | RegExp;
};
type ByOperationId = {
  type: 'operationId';
  pattern: string | RegExp;
};
type ByPath = {
  type: 'path';
  pattern: string | RegExp;
};
type ByMethod = {
  type: 'method';
  pattern: HttpMethod | RegExp;
};
type BySchemaName = {
  type: 'schemaName';
  pattern: string | RegExp;
};
type ByContentType = {
  type: 'contentType';
  pattern: string | RegExp;
};
type Exclude$1 = ByTag | ByOperationId | ByPath | ByMethod | ByContentType;
type Include = ByTag | ByOperationId | ByPath | ByMethod | ByContentType;
type Override<TOptions> = (ByTag | ByOperationId | ByPath | ByMethod | BySchemaName | ByContentType) & {
  options: Partial<TOptions>;
};
//#endregion
//#region ../plugin-oas/src/OperationGenerator.d.ts
type Context$1<TOptions, TPluginOptions extends PluginFactoryOptions> = {
  fabric: Fabric;
  oas: Oas;
  exclude: Array<Exclude$1> | undefined;
  include: Array<Include> | undefined;
  override: Array<Override<TOptions>> | undefined;
  contentType: contentType | undefined;
  pluginManager: PluginManager;
  events?: AsyncEventEmitter<KubbEvents>;
  /**
   * Current plugin
   */
  plugin: Plugin<TPluginOptions>;
  mode: KubbFile.Mode;
  UNSTABLE_NAMING?: true;
};
declare class OperationGenerator<TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions, TFileMeta extends FileMetaBase = FileMetaBase> extends BaseGenerator<TPluginOptions['resolvedOptions'], Context$1<TPluginOptions['resolvedOptions'], TPluginOptions>> {
  #private;
  getOptions(operation: Operation$1, method: HttpMethod): Partial<TPluginOptions['resolvedOptions']>;
  getSchemas(operation: Operation$1, {
    resolveName
  }?: {
    resolveName?: (name: string) => string;
  }): OperationSchemas;
  getOperations(): Promise<Array<{
    path: string;
    method: HttpMethod;
    operation: Operation$1;
  }>>;
  build(...generators: Array<Generator<TPluginOptions>>): Promise<Array<KubbFile.File<TFileMeta>>>;
}
//#endregion
//#region ../plugin-oas/src/SchemaMapper.d.ts
type SchemaKeywordMapper = {
  object: {
    keyword: 'object';
    args: {
      properties: {
        [x: string]: Schema[];
      };
      additionalProperties: Schema[];
      patternProperties?: Record<string, Schema[]>;
      strict?: boolean;
    };
  };
  url: {
    keyword: 'url';
  };
  readOnly: {
    keyword: 'readOnly';
  };
  writeOnly: {
    keyword: 'writeOnly';
  };
  uuid: {
    keyword: 'uuid';
  };
  email: {
    keyword: 'email';
  };
  firstName: {
    keyword: 'firstName';
  };
  lastName: {
    keyword: 'lastName';
  };
  phone: {
    keyword: 'phone';
  };
  password: {
    keyword: 'password';
  };
  date: {
    keyword: 'date';
    args: {
      type?: 'date' | 'string';
    };
  };
  time: {
    keyword: 'time';
    args: {
      type?: 'date' | 'string';
    };
  };
  datetime: {
    keyword: 'datetime';
    args: {
      offset?: boolean;
      local?: boolean;
    };
  };
  tuple: {
    keyword: 'tuple';
    args: {
      items: Schema[];
      min?: number;
      max?: number;
      rest?: Schema;
    };
  };
  array: {
    keyword: 'array';
    args: {
      items: Schema[];
      min?: number;
      max?: number;
      unique?: boolean;
    };
  };
  enum: {
    keyword: 'enum';
    args: {
      name: string;
      typeName: string;
      asConst: boolean;
      items: Array<{
        name: string | number;
        format: 'string' | 'number' | 'boolean';
        value?: string | number | boolean;
      }>;
    };
  };
  and: {
    keyword: 'and';
    args: Schema[];
  };
  const: {
    keyword: 'const';
    args: {
      name: string | number;
      format: 'string' | 'number' | 'boolean';
      value?: string | number | boolean;
    };
  };
  union: {
    keyword: 'union';
    args: Schema[];
  };
  ref: {
    keyword: 'ref';
    args: {
      name: string;
      $ref: string;
      /**
       * Full qualified path.
       */
      path: KubbFile.Path;
      /**
       * When true `File.Import` is used.
       * When false a reference is used inside the current file.
       */
      isImportable: boolean;
    };
  };
  matches: {
    keyword: 'matches';
    args?: string;
  };
  boolean: {
    keyword: 'boolean';
  };
  default: {
    keyword: 'default';
    args: string | number | boolean;
  };
  string: {
    keyword: 'string';
  };
  integer: {
    keyword: 'integer';
  };
  number: {
    keyword: 'number';
  };
  max: {
    keyword: 'max';
    args: number;
  };
  min: {
    keyword: 'min';
    args: number;
  };
  exclusiveMaximum: {
    keyword: 'exclusiveMaximum';
    args: number;
  };
  exclusiveMinimum: {
    keyword: 'exclusiveMinimum';
    args: number;
  };
  describe: {
    keyword: 'describe';
    args: string;
  };
  example: {
    keyword: 'example';
    args: string;
  };
  deprecated: {
    keyword: 'deprecated';
  };
  optional: {
    keyword: 'optional';
  };
  undefined: {
    keyword: 'undefined';
  };
  nullish: {
    keyword: 'nullish';
  };
  nullable: {
    keyword: 'nullable';
  };
  null: {
    keyword: 'null';
  };
  any: {
    keyword: 'any';
  };
  unknown: {
    keyword: 'unknown';
  };
  void: {
    keyword: 'void';
  };
  blob: {
    keyword: 'blob';
  };
  schema: {
    keyword: 'schema';
    args: {
      type: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object';
      format?: string;
    };
  };
  name: {
    keyword: 'name';
    args: string;
  };
  catchall: {
    keyword: 'catchall';
  };
  interface: {
    keyword: 'interface';
  };
};
type Schema = {
  keyword: string;
} | SchemaKeywordMapper[keyof SchemaKeywordMapper];
//#endregion
//#region ../plugin-oas/src/SchemaGenerator.d.ts
type Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {
  fabric: Fabric;
  oas: Oas;
  pluginManager: PluginManager;
  events?: AsyncEventEmitter<KubbEvents>;
  /**
   * Current plugin
   */
  plugin: Plugin<TPluginOptions>;
  mode: KubbFile.Mode;
  include?: Array<'schemas' | 'responses' | 'requestBodies'>;
  override: Array<Override<TOptions>> | undefined;
  contentType?: contentType;
  output?: string;
};
type SchemaGeneratorOptions = {
  dateType: false | 'string' | 'stringOffset' | 'stringLocal' | 'date';
  unknownType: 'any' | 'unknown' | 'void';
  emptySchemaType: 'any' | 'unknown' | 'void';
  enumType?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal' | 'inlineLiteral';
  enumSuffix?: string;
  /**
   * @deprecated Will be removed in v5. Use `collisionDetection: true` instead to prevent enum name collisions.
   * When `collisionDetection` is enabled, the rootName-based approach eliminates the need for numeric suffixes.
   * @internal
   */
  usedEnumNames?: Record<string, number>;
  mapper?: Record<string, string>;
  typed?: boolean;
  transformers: {
    /**
     * Customize the names based on the type that is provided by the plugin.
     */
    name?: (name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string;
    /**
     * Receive schema and name(propertyName) and return FakerMeta array
     * TODO TODO add docs
     * @beta
     */
    schema?: (schemaProps: SchemaProps$1, defaultSchemas: Schema[]) => Array<Schema> | undefined;
  };
};
type SchemaProps$1 = {
  schema: SchemaObject$1 | null;
  name: string | null;
  parentName: string | null;
  rootName?: string | null;
};
declare class SchemaGenerator<TOptions extends SchemaGeneratorOptions = SchemaGeneratorOptions, TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions, TFileMeta extends FileMetaBase = FileMetaBase> extends BaseGenerator<TOptions, Context<TOptions, TPluginOptions>> {
  #private;
  refs: Refs;
  /**
   * Creates a type node from a given schema.
   * Delegates to getBaseTypeFromSchema internally and
   * optionally adds a union with null.
   */
  parse(props: SchemaProps$1): Schema[];
  static deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): Array<SchemaKeywordMapper[T]>;
  static find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined;
  static combineObjects(tree: Schema[] | undefined): Schema[];
  build(...generators: Array<Generator<TPluginOptions>>): Promise<Array<KubbFile.File<TFileMeta>>>;
}
//#endregion
//#region ../plugin-oas/src/generators/createReactGenerator.d.ts
type ReactGenerator<TOptions extends PluginFactoryOptions> = {
  name: string;
  type: 'react';
  Operations: (props: OperationsProps<TOptions>) => FabricReactNode;
  Operation: (props: OperationProps<TOptions>) => FabricReactNode;
  Schema: (props: SchemaProps<TOptions>) => FabricReactNode;
};
//#endregion
//#region ../plugin-oas/src/generators/types.d.ts
type OperationsProps<TOptions extends PluginFactoryOptions> = {
  config: Config;
  generator: Omit<OperationGenerator<TOptions>, 'build'>;
  plugin: Plugin<TOptions>;
  operations: Array<Operation$1>;
};
type OperationProps<TOptions extends PluginFactoryOptions> = {
  config: Config;
  generator: Omit<OperationGenerator<TOptions>, 'build'>;
  plugin: Plugin<TOptions>;
  operation: Operation$1;
};
type SchemaProps<TOptions extends PluginFactoryOptions> = {
  config: Config;
  generator: Omit<SchemaGenerator<SchemaGeneratorOptions, TOptions>, 'build'>;
  plugin: Plugin<TOptions>;
  schema: {
    name: string;
    tree: Array<Schema>;
    value: SchemaObject$1;
  };
};
type Generator<TOptions extends PluginFactoryOptions> = CoreGenerator<TOptions> | ReactGenerator<TOptions>;
//#endregion
//#region ../plugin-oas/src/generators/createGenerator.d.ts
type CoreGenerator<TOptions extends PluginFactoryOptions> = {
  name: string;
  type: 'core';
  operations: (props: OperationsProps<TOptions>) => Promise<KubbFile.File[]>;
  operation: (props: OperationProps<TOptions>) => Promise<KubbFile.File[]>;
  schema: (props: SchemaProps<TOptions>) => Promise<KubbFile.File[]>;
};
//#endregion
//#region src/types.d.ts
type Options = {
  /**
   * Specify the export location for the files and define the behavior of the output
   * @default { path: 'clients', barrelType: 'named' }
   */
  output?: Output<Oas>;
  /**
   * Define which contentType should be used.
   * By default, the first JSON valid mediaType is used
   */
  contentType?: contentType;
  /**
   * Group the clients based on the provided name.
   */
  group?: Group;
  /**
   * Array containing exclude parameters to exclude/skip tags/operations/methods/paths.
   */
  exclude?: Array<Exclude$1>;
  /**
   * Array containing include parameters to include tags/operations/methods/paths.
   */
  include?: Array<Include>;
  /**
   * Array containing override parameters to override `options` based on tags/operations/methods/paths.
   */
  override?: Array<Override<ResolvedOptions>>;
  /**
   * Create `operations.ts` file with all operations grouped by methods.
   * @default false
   */
  operations?: boolean;
  /**
   * Export urls that are used by operation x.
   * - 'export' makes them part of your barrel file.
   * - false does not make them exportable.
   * @default false
   * @example getGetPetByIdUrl
   */
  urlType?: 'export' | false;
  /**
   * Client import path for API calls.
   * Used as `import client from '${client.importPath}'`.
   * Accepts relative and absolute paths; path changes are not performed.
   */
  importPath?: string;
  /**
   * Allows you to set a custom base url for all generated calls.
   */
  baseURL?: string;
  /**
   * ReturnType that is used when calling the client.
   * - 'data' returns ResponseConfig[data].
   * - 'full' returns ResponseConfig.
   * @default 'data'
   */
  dataReturnType?: 'data' | 'full';
  /**
   * How to style your params, by default no casing is applied
   * - 'camelcase' uses camelcase for the params names
   */
  paramsCasing?: 'camelcase';
  /**
   * How to pass your params.
   * - 'object' returns the params and pathParams as an object.
   * - 'inline' returns the params as comma separated params.
   * @default 'inline'
   */
  paramsType?: 'object' | 'inline';
  /**
   * How to pass your pathParams.
   * - 'object' returns the pathParams as an object.
   * - 'inline' returns the pathParams as comma separated params.
   * @default 'inline'
   */
  pathParamsType?: 'object' | 'inline';
  /**
   * Which parser can be used before returning the data.
   * - 'client' returns the data as-is from the client.
   * - 'zod' uses @kubb/plugin-zod to parse the data.
   * @default 'client'
   */
  parser?: 'client' | 'zod';
  /**
   * Which client should be used to do the HTTP calls.
   * - 'axios' uses axios client for HTTP requests.
   * - 'fetch' uses native fetch API for HTTP requests.
   * @default 'axios'
   */
  client?: 'axios' | 'fetch';
  /**
   * How to generate the client code.
   * - 'function' generates standalone functions for each operation.
   * - 'class' generates a class with methods for each operation.
   * - 'staticClass' generates a class with static methods for each operation.
   * @default 'function'
   */
  clientType?: 'function' | 'class' | 'staticClass';
  /**
   * Bundle the selected client into the generated `.kubb` directory.
   * When disabled the generated clients will import the shared runtime from `@kubb/plugin-client/clients/*`.
   * @default false
   * In version 5 of Kubb this is by default true
   */
  bundle?: boolean;
  transformers?: {
    /**
     * Customize the names based on the type that is provided by the plugin.
     */
    name?: (name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string;
  };
  /**
   * Define some generators next to the client generators
   */
  generators?: Array<Generator<PluginClient>>;
};
type ResolvedOptions = {
  output: Output<Oas>;
  group?: Options['group'];
  baseURL: string | undefined;
  client: Options['client'];
  clientType: NonNullable<Options['clientType']>;
  bundle: NonNullable<Options['bundle']>;
  parser: NonNullable<Options['parser']>;
  urlType: NonNullable<Options['urlType']>;
  importPath: Options['importPath'];
  dataReturnType: NonNullable<Options['dataReturnType']>;
  pathParamsType: NonNullable<Options['pathParamsType']>;
  paramsType: NonNullable<Options['paramsType']>;
  paramsCasing: Options['paramsCasing'];
};
type PluginClient = PluginFactoryOptions<'plugin-client', Options, ResolvedOptions, never, ResolvePathOptions>;
//#endregion
export { UserPluginWithLifeCycle as a, OperationSchemas as i, PluginClient as n, Operation$1 as o, ReactGenerator as r, Options as t };
//# sourceMappingURL=types-B6KTAQpK.d.ts.map