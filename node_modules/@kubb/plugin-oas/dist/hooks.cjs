const require_chunk = require('./chunk-C1_xRkKa.cjs');
const require_SchemaGenerator = require('./SchemaGenerator-D2ZpjZgn.cjs');
const require_SchemaMapper = require('./SchemaMapper-CzH82C7C.cjs');
let _kubb_react_fabric = require("@kubb/react-fabric");
let _kubb_core_hooks = require("@kubb/core/hooks");

//#region src/hooks/useOas.ts
function useOas() {
	const { meta } = (0, _kubb_react_fabric.useApp)();
	return meta.oas;
}

//#endregion
//#region src/hooks/useOperationManager.ts
/**
* `useOperationManager` returns helper functions to get the operation file and operation name.
*/
function useOperationManager(generator) {
	const plugin = (0, _kubb_core_hooks.usePlugin)();
	const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
	const getName = (operation, { prefix = "", suffix = "", pluginKey = plugin.key, type }) => {
		return pluginManager.resolveName({
			name: `${prefix} ${operation.getOperationId()} ${suffix}`,
			pluginKey,
			type
		});
	};
	const getGroup = (operation) => {
		return {
			tag: operation.getTags().at(0)?.name,
			path: operation.path
		};
	};
	const getSchemas = (operation, params) => {
		if (!generator) throw new Error(`'generator' is not defined`);
		return generator.getSchemas(operation, { resolveName: (name) => pluginManager.resolveName({
			name,
			pluginKey: params?.pluginKey,
			type: params?.type
		}) });
	};
	const getFile = (operation, { prefix, suffix, pluginKey = plugin.key, extname = ".ts" } = {}) => {
		const name = getName(operation, {
			type: "file",
			pluginKey,
			prefix,
			suffix
		});
		const group = getGroup(operation);
		const file = pluginManager.getFile({
			name,
			extname,
			pluginKey,
			options: {
				type: "file",
				pluginKey,
				group
			}
		});
		return {
			...file,
			meta: {
				...file.meta,
				name,
				pluginKey,
				group
			}
		};
	};
	const groupSchemasByName = (operation, { pluginKey = plugin.key, type }) => {
		if (!generator) throw new Error(`'generator' is not defined`);
		const schemas = generator.getSchemas(operation);
		const errors = (schemas.errors || []).reduce((prev, acc) => {
			if (!acc.statusCode) return prev;
			prev[acc.statusCode] = pluginManager.resolveName({
				name: acc.name,
				pluginKey,
				type
			});
			return prev;
		}, {});
		const responses = (schemas.responses || []).reduce((prev, acc) => {
			if (!acc.statusCode) return prev;
			prev[acc.statusCode] = pluginManager.resolveName({
				name: acc.name,
				pluginKey,
				type
			});
			return prev;
		}, {});
		return {
			request: schemas.request?.name ? pluginManager.resolveName({
				name: schemas.request.name,
				pluginKey,
				type
			}) : void 0,
			parameters: {
				path: schemas.pathParams?.name ? pluginManager.resolveName({
					name: schemas.pathParams.name,
					pluginKey,
					type
				}) : void 0,
				query: schemas.queryParams?.name ? pluginManager.resolveName({
					name: schemas.queryParams.name,
					pluginKey,
					type
				}) : void 0,
				header: schemas.headerParams?.name ? pluginManager.resolveName({
					name: schemas.headerParams.name,
					pluginKey,
					type
				}) : void 0
			},
			responses: {
				...responses,
				["default"]: pluginManager.resolveName({
					name: schemas.response.name,
					pluginKey,
					type
				}),
				...errors
			},
			errors
		};
	};
	return {
		getName,
		getFile,
		getSchemas,
		groupSchemasByName,
		getGroup
	};
}

//#endregion
//#region src/hooks/useSchemaManager.ts
/**
* `useSchemaManager` returns helper functions to get the schema file and schema name.
*/
function useSchemaManager() {
	const plugin = (0, _kubb_core_hooks.usePlugin)();
	const pluginManager = (0, _kubb_core_hooks.usePluginManager)();
	const getName = (name, { pluginKey = plugin.key, type }) => {
		return pluginManager.resolveName({
			name,
			pluginKey,
			type
		});
	};
	const getFile = (name, { mode = "split", pluginKey = plugin.key, extname = ".ts", group } = {}) => {
		const resolvedName = mode === "single" ? "" : getName(name, {
			type: "file",
			pluginKey
		});
		const file = pluginManager.getFile({
			name: resolvedName,
			extname,
			pluginKey,
			options: {
				type: "file",
				pluginKey,
				group
			}
		});
		return {
			...file,
			meta: {
				...file.meta,
				name: resolvedName,
				pluginKey
			}
		};
	};
	const getImports = (tree) => {
		return require_SchemaGenerator.SchemaGenerator.deepSearch(tree, require_SchemaMapper.schemaKeywords.ref)?.map((item) => {
			if (!item.args.path || !item.args.isImportable) return;
			return {
				name: [item.args.name],
				path: item.args.path
			};
		}).filter(Boolean);
	};
	return {
		getName,
		getFile,
		getImports
	};
}

//#endregion
exports.useOas = useOas;
exports.useOperationManager = useOperationManager;
exports.useSchemaManager = useSchemaManager;
//# sourceMappingURL=hooks.cjs.map