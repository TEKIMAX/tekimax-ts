{"version":3,"file":"index.js","names":["path","#isExcluded","#isIncluded","validate","oas","options","_createGenerator","_createReactGenerator"],"sources":["../src/createParser.ts","../src/OperationGenerator.ts","../src/plugin.ts","../src/index.ts"],"sourcesContent":["import { SchemaGenerator } from './SchemaGenerator.ts'\nimport type { Schema, SchemaKeywordMapper, SchemaMapper, SchemaTree } from './SchemaMapper.ts'\nimport { schemaKeywords } from './SchemaMapper.ts'\n\n/**\n * Helper type to create a SchemaTree with a specific current schema type\n */\ntype SchemaTreeWithKeyword<K extends keyof SchemaKeywordMapper> = Omit<SchemaTree, 'current'> & {\n  current: SchemaKeywordMapper[K]\n}\n\n/**\n * Handler context with parse method available via `this`\n */\nexport type HandlerContext<TOutput, TOptions> = {\n  parse: (tree: SchemaTree, options: TOptions) => TOutput | null | undefined\n}\n\n/**\n * Handler function type for custom keyword processing\n * Handlers can access the parse function via `this.parse`\n * The tree.current is typed based on the keyword K\n */\nexport type KeywordHandler<TOutput, TOptions, K extends keyof SchemaKeywordMapper = keyof SchemaKeywordMapper> = (\n  this: HandlerContext<TOutput, TOptions>,\n  tree: SchemaTreeWithKeyword<K>,\n  options: TOptions,\n) => TOutput | null | undefined\n\n/**\n * Configuration for createParser\n */\nexport type CreateParserConfig<TOutput, TOptions> = {\n  /**\n   * The keyword mapper that maps schema keywords to output generators\n   */\n  mapper: SchemaMapper<TOutput>\n\n  /**\n   * Custom handlers for specific schema keywords\n   * These provide the implementation for complex types that need special processing\n   *\n   * Use function syntax (not arrow functions) to enable use of `this` keyword:\n   * ```typescript\n   * handlers: {\n   *   enum(tree, options, parse) {\n   *     // Implementation\n   *   }\n   * }\n   * ```\n   *\n   * Common keywords that typically need handlers:\n   * - union: Combine multiple schemas into a union\n   * - and: Combine multiple schemas into an intersection\n   * - array: Handle array types with items\n   * - object: Handle object types with properties\n   * - enum: Handle enum types\n   * - tuple: Handle tuple types\n   * - const: Handle literal/const types\n   * - ref: Handle references to other schemas\n   * - string/number/integer: Handle primitives with constraints (min/max)\n   * - matches: Handle regex patterns\n   * - default/describe/optional/nullable: Handle modifiers\n   */\n  handlers: Partial<{\n    [K in keyof SchemaKeywordMapper]: KeywordHandler<TOutput, TOptions, K>\n  }>\n}\n\n/**\n * Creates a parser function that converts schema trees to output using the provided mapper and handlers\n *\n * This function provides a framework for building parsers by:\n * 1. Checking for custom handlers for each keyword\n * 2. Falling back to the mapper for simple keywords\n * 3. Providing utilities for common operations (finding siblings, etc.)\n *\n * The generated parser is recursive and can handle nested schemas.\n *\n * **Type Safety**: Each handler receives a `tree` parameter where `tree.current` is automatically\n * typed as the specific schema keyword type (e.g., `SchemaKeywordMapper['ref']` for the `ref` handler).\n * This means you can access `tree.current.args` with full type safety without needing `isKeyword` checks,\n * though such checks can still be used as runtime guards if desired.\n *\n * @template TOutput - The output type (e.g., string for Zod/Faker, ts.TypeNode for TypeScript)\n * @template TOptions - The parser options type\n * @param config - Configuration object containing mapper and handlers\n * @returns A parse function that converts SchemaTree to TOutput\n *\n * @example\n * ```ts\n * // Create a simple string-based parser\n * const parse = createParser({\n *   mapper: zodKeywordMapper,\n *   handlers: {\n *     // tree.current is typed as SchemaKeywordMapper['union']\n *     union(tree, options) {\n *       const items = tree.current.args // args is correctly typed as Schema[]\n *         .map(it => this.parse({ ...tree, current: it }, options))\n *         .filter(Boolean)\n *       return `z.union([${items.join(', ')}])`\n *     },\n *     // tree.current is typed as SchemaKeywordMapper['string']\n *     string(tree, options) {\n *       const minSchema = findSchemaKeyword(tree.siblings, 'min')\n *       const maxSchema = findSchemaKeyword(tree.siblings, 'max')\n *       return zodKeywordMapper.string(false, minSchema?.args, maxSchema?.args)\n *     },\n *     // tree.current is typed as SchemaKeywordMapper['ref']\n *     ref(tree, options) {\n *       // No need for isKeyword check - tree.current.args is already properly typed\n *       return `Ref: ${tree.current.args.name}`\n *     }\n *   }\n * })\n * ```\n */\nexport function createParser<TOutput, TOptions extends Record<string, any>>(\n  config: CreateParserConfig<TOutput, TOptions>,\n): (tree: SchemaTree, options: TOptions) => TOutput | null | undefined {\n  const { mapper, handlers } = config\n\n  function parse(tree: SchemaTree, options: TOptions): TOutput | null | undefined {\n    const { current } = tree\n\n    // Check if there's a custom handler for this keyword\n    const handler = handlers[current.keyword as keyof SchemaKeywordMapper]\n    if (handler) {\n      // Create context object with parse method accessible via `this`\n      const context: HandlerContext<TOutput, TOptions> = { parse }\n      // We need to cast tree here because TypeScript can't statically verify\n      // that the handler type matches the current keyword at runtime\n      return handler.call(context, tree as any, options)\n    }\n\n    // Fall back to simple mapper lookup\n    const value = mapper[current.keyword as keyof typeof mapper]\n\n    if (!value) {\n      return undefined\n    }\n\n    // For simple keywords without args, call the mapper directly\n    if (current.keyword in mapper) {\n      return value()\n    }\n\n    return undefined\n  }\n\n  return parse\n}\n\n/**\n * Helper to find a schema keyword in siblings\n * Useful in handlers when you need to find related schemas (e.g., min/max for string)\n *\n * @example\n * ```ts\n * const minSchema = findSchemaKeyword(tree.siblings, 'min')\n * const maxSchema = findSchemaKeyword(tree.siblings, 'max')\n * return zodKeywordMapper.string(false, minSchema?.args, maxSchema?.args)\n * ```\n */\nexport function findSchemaKeyword<K extends keyof SchemaKeywordMapper>(siblings: Schema[], keyword: K): SchemaKeywordMapper[K] | undefined {\n  return SchemaGenerator.find(siblings, schemaKeywords[keyword]) as SchemaKeywordMapper[K] | undefined\n}\n","import type { KubbEvents, Plugin, PluginFactoryOptions, PluginManager } from '@kubb/core'\nimport { BaseGenerator, type FileMetaBase } from '@kubb/core'\nimport transformers from '@kubb/core/transformers'\nimport type { AsyncEventEmitter } from '@kubb/core/utils'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport type { contentType, HttpMethod, Oas, OasTypes, Operation, SchemaObject } from '@kubb/oas'\nimport type { Fabric } from '@kubb/react-fabric'\nimport pLimit from 'p-limit'\nimport type { Generator } from './generators/types.ts'\nimport type { Exclude, Include, OperationSchemas, Override } from './types.ts'\nimport { buildOperation, buildOperations } from './utils.tsx'\n\nexport type OperationMethodResult<TFileMeta extends FileMetaBase> = Promise<KubbFile.File<TFileMeta> | Array<KubbFile.File<TFileMeta>> | null>\n\ntype Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {\n  fabric: Fabric\n  oas: Oas\n  exclude: Array<Exclude> | undefined\n  include: Array<Include> | undefined\n  override: Array<Override<TOptions>> | undefined\n  contentType: contentType | undefined\n  pluginManager: PluginManager\n  events?: AsyncEventEmitter<KubbEvents>\n  /**\n   * Current plugin\n   */\n  plugin: Plugin<TPluginOptions>\n  mode: KubbFile.Mode\n  UNSTABLE_NAMING?: true\n}\n\nexport class OperationGenerator<\n  TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions,\n  TFileMeta extends FileMetaBase = FileMetaBase,\n> extends BaseGenerator<TPluginOptions['resolvedOptions'], Context<TPluginOptions['resolvedOptions'], TPluginOptions>> {\n  getOptions(operation: Operation, method: HttpMethod): Partial<TPluginOptions['resolvedOptions']> {\n    const { override = [] } = this.context\n    const operationId = operation.getOperationId({ friendlyCase: true })\n    const contentType = operation.getContentType()\n\n    return (\n      override.find(({ pattern, type }) => {\n        switch (type) {\n          case 'tag':\n            return operation.getTags().some((tag) => tag.name.match(pattern))\n          case 'operationId':\n            return !!operationId.match(pattern)\n          case 'path':\n            return !!operation.path.match(pattern)\n          case 'method':\n            return !!method.match(pattern)\n          case 'contentType':\n            return !!contentType.match(pattern)\n          default:\n            return false\n        }\n      })?.options || {}\n    )\n  }\n\n  #isExcluded(operation: Operation, method: HttpMethod): boolean {\n    const { exclude = [] } = this.context\n    const operationId = operation.getOperationId({ friendlyCase: true })\n    const contentType = operation.getContentType()\n\n    return exclude.some(({ pattern, type }) => {\n      switch (type) {\n        case 'tag':\n          return operation.getTags().some((tag) => tag.name.match(pattern))\n        case 'operationId':\n          return !!operationId.match(pattern)\n        case 'path':\n          return !!operation.path.match(pattern)\n        case 'method':\n          return !!method.match(pattern)\n        case 'contentType':\n          return !!contentType.match(pattern)\n        default:\n          return false\n      }\n    })\n  }\n\n  #isIncluded(operation: Operation, method: HttpMethod): boolean {\n    const { include = [] } = this.context\n    const operationId = operation.getOperationId({ friendlyCase: true })\n    const contentType = operation.getContentType()\n\n    return include.some(({ pattern, type }) => {\n      switch (type) {\n        case 'tag':\n          return operation.getTags().some((tag) => tag.name.match(pattern))\n        case 'operationId':\n          return !!operationId.match(pattern)\n        case 'path':\n          return !!operation.path.match(pattern)\n        case 'method':\n          return !!method.match(pattern)\n        case 'contentType':\n          return !!contentType.match(pattern)\n        default:\n          return false\n      }\n    })\n  }\n\n  getSchemas(\n    operation: Operation,\n    {\n      resolveName = (name) => name,\n    }: {\n      resolveName?: (name: string) => string\n    } = {},\n  ): OperationSchemas {\n    const operationId = operation.getOperationId({ friendlyCase: true })\n    const operationName = transformers.pascalCase(operationId)\n\n    const resolveKeys = (schema?: SchemaObject) => (schema?.properties ? Object.keys(schema.properties) : undefined)\n\n    const pathParamsSchema = this.context.oas.getParametersSchema(operation, 'path')\n    const queryParamsSchema = this.context.oas.getParametersSchema(operation, 'query')\n    const headerParamsSchema = this.context.oas.getParametersSchema(operation, 'header')\n    const requestSchema = this.context.oas.getRequestSchema(operation)\n    const statusCodes = operation.getResponseStatusCodes().map((statusCode) => {\n      const name = statusCode === 'default' ? 'error' : statusCode\n      const schema = this.context.oas.getResponseSchema(operation, statusCode)\n      const keys = resolveKeys(schema)\n\n      return {\n        name: this.context.UNSTABLE_NAMING\n          ? resolveName(transformers.pascalCase(`${operationId} status ${name}`))\n          : resolveName(transformers.pascalCase(`${operationId} ${name}`)),\n        description: (operation.getResponseByStatusCode(statusCode) as OasTypes.ResponseObject)?.description,\n        schema,\n        operation,\n        operationName,\n        statusCode: name === 'error' ? undefined : Number(statusCode),\n        keys,\n        keysToOmit: keys?.filter((key) => (schema?.properties?.[key] as OasTypes.SchemaObject)?.writeOnly),\n      }\n    })\n\n    const successful = statusCodes.filter((item) => item.statusCode?.toString().startsWith('2'))\n    const errors = statusCodes.filter((item) => item.statusCode?.toString().startsWith('4') || item.statusCode?.toString().startsWith('5'))\n\n    return {\n      pathParams: pathParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operationId} PathParams`)),\n            operation,\n            operationName,\n            schema: pathParamsSchema,\n            keys: resolveKeys(pathParamsSchema),\n          }\n        : undefined,\n      queryParams: queryParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operationId} QueryParams`)),\n            operation,\n            operationName,\n            schema: queryParamsSchema,\n            keys: resolveKeys(queryParamsSchema) || [],\n          }\n        : undefined,\n      headerParams: headerParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operationId} HeaderParams`)),\n            operation,\n            operationName,\n            schema: headerParamsSchema,\n            keys: resolveKeys(headerParamsSchema),\n          }\n        : undefined,\n      request: requestSchema\n        ? {\n            name: this.context.UNSTABLE_NAMING\n              ? resolveName(transformers.pascalCase(`${operationId} RequestData`))\n              : resolveName(transformers.pascalCase(`${operationId} ${operation.method === 'get' ? 'queryRequest' : 'mutationRequest'}`)),\n            description: (operation.schema.requestBody as OasTypes.RequestBodyObject)?.description,\n            operation,\n            operationName,\n            schema: requestSchema,\n            keys: resolveKeys(requestSchema),\n            keysToOmit: resolveKeys(requestSchema)?.filter((key) => (requestSchema.properties?.[key] as OasTypes.SchemaObject)?.readOnly),\n          }\n        : undefined,\n      response: {\n        name: this.context.UNSTABLE_NAMING\n          ? resolveName(transformers.pascalCase(`${operationId} ResponseData`))\n          : resolveName(transformers.pascalCase(`${operationId} ${operation.method === 'get' ? 'queryResponse' : 'mutationResponse'}`)),\n        operation,\n        operationName,\n        schema: {\n          oneOf: successful.map((item) => ({ ...item.schema, $ref: item.name })) || undefined,\n        } as SchemaObject,\n      },\n      responses: successful,\n      errors,\n      statusCodes,\n    }\n  }\n\n  async getOperations(): Promise<Array<{ path: string; method: HttpMethod; operation: Operation }>> {\n    const { oas } = this.context\n\n    const paths = oas.getPaths()\n\n    return Object.entries(paths).flatMap(([path, methods]) =>\n      Object.entries(methods)\n        .map((values) => {\n          const [method, operation] = values as [HttpMethod, Operation]\n          if (this.#isExcluded(operation, method)) {\n            return null\n          }\n\n          if (this.context.include && !this.#isIncluded(operation, method)) {\n            return null\n          }\n\n          return operation ? { path, method: method as HttpMethod, operation } : null\n        })\n        .filter(Boolean),\n    )\n  }\n\n  async build(...generators: Array<Generator<TPluginOptions>>): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const operations = await this.getOperations()\n\n    // Increased parallelism for better performance\n    // - generatorLimit increased from 1 to 3 to allow parallel generator processing\n    // - operationLimit increased from 10 to 30 to process more operations concurrently\n    const generatorLimit = pLimit(3)\n    const operationLimit = pLimit(30)\n\n    this.context.events?.emit('debug', {\n      date: new Date(),\n      logs: [`Building ${operations.length} operations`, `  • Generators: ${generators.length}`],\n    })\n\n    const writeTasks = generators.map((generator) =>\n      generatorLimit(async () => {\n        const operationTasks = operations.map(({ operation, method }) =>\n          operationLimit(async () => {\n            const options = this.getOptions(operation, method)\n\n            if (generator.type === 'react') {\n              await buildOperation(operation, {\n                config: this.context.pluginManager.config,\n                fabric: this.context.fabric,\n                Component: generator.Operation,\n                generator: this,\n                plugin: {\n                  ...this.context.plugin,\n                  options: {\n                    ...this.options,\n                    ...options,\n                  },\n                },\n              })\n\n              return []\n            }\n\n            const result = await generator.operation?.({\n              generator: this,\n              config: this.context.pluginManager.config,\n              operation,\n              plugin: {\n                ...this.context.plugin,\n                options: {\n                  ...this.options,\n                  ...options,\n                },\n              },\n            })\n\n            return result ?? []\n          }),\n        )\n\n        const operationResults = await Promise.all(operationTasks)\n        const opResultsFlat = operationResults.flat()\n\n        if (generator.type === 'react') {\n          await buildOperations(\n            operations.map((op) => op.operation),\n            {\n              fabric: this.context.fabric,\n              config: this.context.pluginManager.config,\n              Component: generator.Operations,\n              generator: this,\n              plugin: this.context.plugin,\n            },\n          )\n\n          return []\n        }\n\n        const operationsResult = await generator.operations?.({\n          generator: this,\n          config: this.context.pluginManager.config,\n          operations: operations.map((op) => op.operation),\n          plugin: this.context.plugin,\n        })\n\n        return [...opResultsFlat, ...(operationsResult ?? [])] as unknown as KubbFile.File<TFileMeta>\n      }),\n    )\n\n    const nestedResults = await Promise.all(writeTasks)\n\n    return nestedResults.flat()\n  }\n}\n","import path from 'node:path'\nimport { type Config, definePlugin, type Group, getMode, type KubbEvents } from '@kubb/core'\nimport { camelCase } from '@kubb/core/transformers'\nimport type { AsyncEventEmitter } from '@kubb/core/utils'\nimport type { Oas } from '@kubb/oas'\nimport { parseFromConfig } from '@kubb/oas'\nimport { jsonGenerator } from './generators'\nimport { OperationGenerator } from './OperationGenerator.ts'\nimport { SchemaGenerator } from './SchemaGenerator.ts'\nimport type { PluginOas } from './types.ts'\n\nexport const pluginOasName = 'plugin-oas' satisfies PluginOas['name']\n\nexport const pluginOas = definePlugin<PluginOas>((options) => {\n  const {\n    output = {\n      path: 'schemas',\n    },\n    group,\n    validate = true,\n    generators = [jsonGenerator],\n    serverIndex,\n    contentType,\n    oasClass,\n    discriminator = 'strict',\n    collisionDetection = false,\n  } = options\n\n  const getOas = async ({ validate, config, events }: { validate: boolean; config: Config; events: AsyncEventEmitter<KubbEvents> }): Promise<Oas> => {\n    // needs to be in a different variable or the catch here will not work(return of a promise instead)\n    const oas = await parseFromConfig(config, oasClass)\n\n    oas.setOptions({\n      contentType,\n      discriminator,\n      collisionDetection,\n    })\n\n    try {\n      if (validate) {\n        await oas.validate()\n      }\n    } catch (er) {\n      const caughtError = er as Error\n      const errorTimestamp = new Date()\n      const error = new Error('OAS Validation failed', {\n        cause: caughtError,\n      })\n\n      events.emit('info', caughtError.message)\n      events.emit('debug', {\n        date: errorTimestamp,\n        logs: [`✗ ${error.message}`, caughtError.message],\n      })\n    }\n\n    return oas\n  }\n\n  return {\n    name: pluginOasName,\n    options: {\n      output,\n      validate,\n      discriminator,\n      ...options,\n    },\n    inject() {\n      const config = this.config\n      const events = this.events\n\n      let oas: Oas\n\n      return {\n        async getOas({ validate = false } = {}) {\n          if (!oas) {\n            oas = await getOas({ config, events, validate })\n          }\n\n          return oas\n        },\n        async getBaseURL() {\n          const oas = await getOas({ config, events, validate: false })\n          if (serverIndex !== undefined) {\n            return oas.api.servers?.at(serverIndex)?.url\n          }\n\n          return undefined\n        },\n      }\n    },\n    resolvePath(baseName, pathMode, options) {\n      const root = path.resolve(this.config.root, this.config.output.path)\n      const mode = pathMode ?? getMode(path.resolve(root, output.path))\n\n      if (mode === 'single') {\n        /**\n         * when output is a file then we will always append to the same file(output file), see fileManager.addOrAppend\n         * Other plugins then need to call addOrAppend instead of just add from the fileManager class\n         */\n        return path.resolve(root, output.path)\n      }\n\n      if (group && (options?.group?.path || options?.group?.tag)) {\n        const groupName: Group['name'] = group?.name\n          ? group.name\n          : (ctx) => {\n              if (group?.type === 'path') {\n                return `${ctx.group.split('/')[1]}`\n              }\n              return `${camelCase(ctx.group)}Controller`\n            }\n\n        return path.resolve(\n          root,\n          output.path,\n          groupName({\n            group: group.type === 'path' ? options.group.path! : options.group.tag!,\n          }),\n          baseName,\n        )\n      }\n\n      return path.resolve(root, output.path, baseName)\n    },\n    async install() {\n      const oas = await this.getOas({ validate })\n\n      if (!output) {\n        return\n      }\n\n      await oas.dereference()\n\n      const schemaGenerator = new SchemaGenerator(\n        {\n          unknownType: 'unknown',\n          emptySchemaType: 'unknown',\n          dateType: 'date',\n          transformers: {},\n          ...this.plugin.options,\n        },\n        {\n          fabric: this.fabric,\n          oas,\n          pluginManager: this.pluginManager,\n          events: this.events,\n          plugin: this.plugin,\n          contentType,\n          include: undefined,\n          override: undefined,\n          mode: 'split',\n          output: output.path,\n        },\n      )\n\n      const schemaFiles = await schemaGenerator.build(...generators)\n      await this.upsertFile(...schemaFiles)\n\n      const operationGenerator = new OperationGenerator(this.plugin.options, {\n        fabric: this.fabric,\n        oas,\n        pluginManager: this.pluginManager,\n        events: this.events,\n        plugin: this.plugin,\n        contentType,\n        exclude: undefined,\n        include: undefined,\n        override: undefined,\n        mode: 'split',\n      })\n\n      const operationFiles = await operationGenerator.build(...generators)\n\n      await this.upsertFile(...operationFiles)\n    },\n  }\n})\n","import type { PluginFactoryOptions } from '@kubb/core'\nimport { createGenerator as _createGenerator } from './generators/createGenerator.ts'\nimport { createReactGenerator as _createReactGenerator } from './generators/createReactGenerator.ts'\nimport type { Generator as _Generator } from './generators/types.ts'\n\nexport type { CreateParserConfig, KeywordHandler } from './createParser.ts'\nexport { createParser, findSchemaKeyword } from './createParser.ts'\nexport type { OperationMethodResult } from './OperationGenerator.ts'\nexport { OperationGenerator } from './OperationGenerator.ts'\nexport { pluginOas, pluginOasName } from './plugin.ts'\nexport type {\n  GetSchemaGeneratorOptions,\n  SchemaGeneratorBuildOptions,\n  SchemaGeneratorOptions,\n  SchemaMethodResult,\n} from './SchemaGenerator.ts'\nexport { SchemaGenerator } from './SchemaGenerator.ts'\nexport type {\n  Schema,\n  SchemaKeyword,\n  SchemaKeywordBase,\n  SchemaKeywordMapper,\n  SchemaMapper,\n  SchemaTree,\n} from './SchemaMapper.ts'\nexport { isKeyword, schemaKeywords } from './SchemaMapper.ts'\nexport type * from './types.ts'\nexport { buildOperation, buildOperations, buildSchema } from './utils.tsx'\n\n/**\n * @deprecated use `import { createGenerator } from '@kubb/plugin-oas/generators'`\n */\nexport const createGenerator = _createGenerator\n\n/**\n * @deprecated use `import { createReactGenerator } from '@kubb/plugin-oas/generators'`\n */\nexport const createReactGenerator = _createReactGenerator\n\n/**\n * @deprecated use `import { Generator } from '@kubb/plugin-oas/generators'`\n */\nexport type Generator<TOptions extends PluginFactoryOptions> = _Generator<TOptions>\n"],"mappings":"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"}