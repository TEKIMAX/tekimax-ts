{"version":3,"file":"SchemaGenerator-CK_Mv0RW.js","names":["#head","#tail","#size","#nameMappingInitialized","#schemaNameMapping","#getOptions","#parseCache","#parseSchemaObject","#getUnknownType","#ensureNameMapping","#getRefAlias","#getParsedSchemaObject","#getEmptyType","#addDiscriminatorToSchema","#wouldCreateCircularReference","normalizedSchema","name","min","max","#parseProperties","schemas","#doBuild"],"sources":["../../../node_modules/.pnpm/yocto-queue@1.2.2/node_modules/yocto-queue/index.js","../../../node_modules/.pnpm/p-limit@7.2.0/node_modules/p-limit/index.js","../src/utils.tsx","../src/SchemaGenerator.ts"],"sourcesContent":["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\n\t\t// Clean up tail reference when queue becomes empty\n\t\tif (!this.#head) {\n\t\t\tthis.#tail = undefined;\n\t\t}\n\n\t\treturn current.value;\n\t}\n\n\tpeek() {\n\t\tif (!this.#head) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#head.value;\n\n\t\t// TODO: Node.js 18.\n\t\t// return this.#head?.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\t* drain() {\n\t\twhile (this.#head) {\n\t\t\tyield this.dequeue();\n\t\t}\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\t// Process the next queued function if we're under the concurrency limit\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tactiveCount++;\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\t// Execute the function and capture the result promise\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\t// Resolve immediately with the promise (don't wait for completion)\n\t\tresolve(result);\n\n\t\t// Wait for the function to complete (success or failure)\n\t\t// We catch errors here to prevent unhandled rejections,\n\t\t// but the original promise rejection is preserved for the caller\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\t// Decrement active count and process next queued function\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue the internal resolve function instead of the run function\n\t\t// to preserve the asynchronous execution context.\n\t\tnew Promise(internalResolve => { // eslint-disable-line promise/param-names\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_)); // eslint-disable-line promise/prefer-await-to-then\n\n\t\t// Start processing immediately if we haven't reached the concurrency limit\n\t\tif (activeCount < concurrency) {\n\t\t\tresumeNext();\n\t\t}\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t\tmap: {\n\t\t\tasync value(iterable, function_) {\n\t\t\t\tconst promises = Array.from(iterable, (value, index) => this(function_, value, index));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nexport function limitFunction(function_, options) {\n\tconst {concurrency} = options;\n\tconst limit = pLimit(concurrency);\n\n\treturn (...arguments_) => limit(() => function_(...arguments_));\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n","import type { Config, Plugin, PluginFactoryOptions } from '@kubb/core'\nimport type { Operation, SchemaObject } from '@kubb/oas'\nimport { App, createReactFabric, type Fabric } from '@kubb/react-fabric'\nimport type { ReactGenerator } from './generators/createReactGenerator.ts'\nimport type { OperationGenerator } from './OperationGenerator.ts'\nimport type { SchemaGenerator, SchemaGeneratorOptions } from './SchemaGenerator.ts'\nimport type { Schema } from './SchemaMapper.ts'\n\ntype BuildOperationsOptions<TOptions extends PluginFactoryOptions> = {\n  config: Config\n  fabric: Fabric\n  Component: ReactGenerator<any>['Operations']\n  generator: Omit<OperationGenerator<TOptions>, 'build'>\n  plugin: Plugin<TOptions>\n}\n\nexport async function buildOperations<TOptions extends PluginFactoryOptions>(\n  operations: Array<Operation>,\n  { config, fabric, plugin, generator, Component }: BuildOperationsOptions<TOptions>,\n): Promise<void> {\n  if (!Component) {\n    return undefined\n  }\n\n  const { pluginManager, oas, mode } = generator.context\n\n  const fabricChild = createReactFabric()\n  await fabricChild.render(\n    <App meta={{ pluginManager, plugin, mode, oas }}>\n      <Component config={config} operations={operations} generator={generator} plugin={plugin} />\n    </App>,\n  )\n\n  await fabric.context.fileManager.upsert(...fabricChild.files)\n}\n\ntype BuildOperationOptions<TOptions extends PluginFactoryOptions> = {\n  config: Config\n  fabric: Fabric\n  Component: ReactGenerator<any>['Operation']\n  generator: Omit<OperationGenerator<TOptions>, 'build'>\n  plugin: Plugin<TOptions>\n}\n\nexport async function buildOperation<TOptions extends PluginFactoryOptions>(\n  operation: Operation,\n  { config, fabric, plugin, generator, Component }: BuildOperationOptions<TOptions>,\n): Promise<void> {\n  if (!Component) {\n    return undefined\n  }\n\n  const { pluginManager, oas, mode } = generator.context\n\n  const fabricChild = createReactFabric()\n  await fabricChild.render(\n    <App meta={{ pluginManager, plugin, mode, oas }}>\n      <Component config={config} operation={operation} plugin={plugin} generator={generator} />\n    </App>,\n  )\n\n  await fabric.context.fileManager.upsert(...fabricChild.files)\n}\n\ntype BuildSchemaOptions<TOptions extends PluginFactoryOptions> = {\n  config: Config\n  fabric: Fabric\n  Component: ReactGenerator<any>['Schema']\n  generator: Omit<SchemaGenerator<SchemaGeneratorOptions, TOptions>, 'build'>\n  plugin: Plugin<TOptions>\n}\n\nexport async function buildSchema<TOptions extends PluginFactoryOptions>(\n  schema: {\n    name: string\n    tree: Array<Schema>\n    value: SchemaObject\n  },\n  { config, fabric, plugin, Component, generator }: BuildSchemaOptions<TOptions>,\n): Promise<void> {\n  if (!Component) {\n    return undefined\n  }\n\n  const { pluginManager, oas, mode } = generator.context\n\n  const fabricChild = createReactFabric()\n  await fabricChild.render(\n    <App meta={{ pluginManager, plugin, mode, oas }}>\n      <Component config={config} schema={schema} plugin={plugin} generator={generator} />\n    </App>,\n  )\n\n  await fabric.context.fileManager.upsert(...fabricChild.files)\n}\n","import type { KubbEvents, Plugin, PluginFactoryOptions, PluginManager, ResolveNameParams } from '@kubb/core'\nimport { BaseGenerator, type FileMetaBase } from '@kubb/core'\nimport transformers, { pascalCase } from '@kubb/core/transformers'\nimport { type AsyncEventEmitter, getUniqueName } from '@kubb/core/utils'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport type { contentType, Oas, OasTypes, OpenAPIV3, SchemaObject } from '@kubb/oas'\nimport { isDiscriminator, isNullable, isReference } from '@kubb/oas'\nimport type { Fabric } from '@kubb/react-fabric'\nimport pLimit from 'p-limit'\nimport { isDeepEqual, isNumber, uniqueWith } from 'remeda'\nimport type { Generator } from './generators/types.ts'\nimport { isKeyword, type Schema, type SchemaKeywordMapper, schemaKeywords } from './SchemaMapper.ts'\nimport type { OperationSchema, Override, Refs } from './types.ts'\nimport { getSchemaFactory } from './utils/getSchemaFactory.ts'\nimport { buildSchema } from './utils.tsx'\n\nexport type GetSchemaGeneratorOptions<T extends SchemaGenerator<any, any, any>> = T extends SchemaGenerator<infer Options, any, any> ? Options : never\n\nexport type SchemaMethodResult<TFileMeta extends FileMetaBase> = Promise<KubbFile.File<TFileMeta> | Array<KubbFile.File<TFileMeta>> | null>\n\ntype Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {\n  fabric: Fabric\n  oas: Oas\n  pluginManager: PluginManager\n  events?: AsyncEventEmitter<KubbEvents>\n  /**\n   * Current plugin\n   */\n  plugin: Plugin<TPluginOptions>\n  mode: KubbFile.Mode\n  include?: Array<'schemas' | 'responses' | 'requestBodies'>\n  override: Array<Override<TOptions>> | undefined\n  contentType?: contentType\n  output?: string\n}\n\nexport type SchemaGeneratorOptions = {\n  dateType: false | 'string' | 'stringOffset' | 'stringLocal' | 'date'\n  unknownType: 'any' | 'unknown' | 'void'\n  emptySchemaType: 'any' | 'unknown' | 'void'\n  enumType?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal' | 'inlineLiteral'\n  enumSuffix?: string\n  /**\n   * @deprecated Will be removed in v5. Use `collisionDetection: true` instead to prevent enum name collisions.\n   * When `collisionDetection` is enabled, the rootName-based approach eliminates the need for numeric suffixes.\n   * @internal\n   */\n  usedEnumNames?: Record<string, number>\n  mapper?: Record<string, string>\n  typed?: boolean\n  transformers: {\n    /**\n     * Customize the names based on the type that is provided by the plugin.\n     */\n    name?: (name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string\n    /**\n     * Receive schema and name(propertyName) and return FakerMeta array\n     * TODO TODO add docs\n     * @beta\n     */\n    schema?: (schemaProps: SchemaProps, defaultSchemas: Schema[]) => Array<Schema> | undefined\n  }\n}\n\nexport type SchemaGeneratorBuildOptions = Omit<OperationSchema, 'name' | 'schema'>\n\ntype SchemaProps = {\n  schema: SchemaObject | null\n  name: string | null\n  parentName: string | null\n  rootName?: string | null\n}\n\nexport class SchemaGenerator<\n  TOptions extends SchemaGeneratorOptions = SchemaGeneratorOptions,\n  TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions,\n  TFileMeta extends FileMetaBase = FileMetaBase,\n> extends BaseGenerator<TOptions, Context<TOptions, TPluginOptions>> {\n  // Collect the types of all referenced schemas, so we can export them later\n  refs: Refs = {}\n\n  // Map from original component paths to resolved schema names (after collision resolution)\n  // e.g., { '#/components/schemas/Order': 'OrderSchema', '#/components/responses/Product': 'ProductResponse' }\n  #schemaNameMapping: Map<string, string> = new Map()\n\n  // Flag to track if nameMapping has been initialized\n  #nameMappingInitialized = false\n\n  // Cache for parsed schemas to avoid redundant parsing\n  // Using WeakMap for automatic garbage collection when schemas are no longer referenced\n  #parseCache: Map<string, Schema[]> = new Map()\n\n  /**\n   * Ensure the name mapping is initialized (lazy initialization)\n   */\n  #ensureNameMapping() {\n    if (this.#nameMappingInitialized) {\n      return\n    }\n\n    const { oas, contentType, include } = this.context\n    const { nameMapping } = oas.getSchemas({ contentType, includes: include })\n    this.#schemaNameMapping = nameMapping\n    this.#nameMappingInitialized = true\n  }\n\n  /**\n   * Creates a type node from a given schema.\n   * Delegates to getBaseTypeFromSchema internally and\n   * optionally adds a union with null.\n   */\n  parse(props: SchemaProps): Schema[] {\n    const options = this.#getOptions(props.name)\n\n    // Only cache when schema is a simple object (not null/undefined)\n    // and doesn't have transformers that could affect the result\n    const shouldCache = props.schema && typeof props.schema === 'object' && !options.transformers?.schema\n    let cacheKey = ''\n\n    if (shouldCache) {\n      // Create cache key using stable JSON stringify for correctness\n      // Cache hit rate is still high for identical schemas across operations\n      try {\n        cacheKey = JSON.stringify({\n          schema: props.schema,\n          name: props.name,\n          parentName: props.parentName,\n          rootName: props.rootName,\n        })\n\n        const cached = this.#parseCache.get(cacheKey)\n        if (cached) {\n          return cached\n        }\n      } catch {\n        // If JSON.stringify fails (circular refs), skip caching\n        shouldCache && (shouldCache as any as boolean)\n      }\n    }\n\n    const defaultSchemas = this.#parseSchemaObject(props)\n    const schemas = options.transformers?.schema?.(props, defaultSchemas) || defaultSchemas || []\n\n    const result = uniqueWith(schemas, isDeepEqual)\n\n    // Cache the result only if we created a valid cache key\n    if (shouldCache && cacheKey) {\n      this.#parseCache.set(cacheKey, result)\n    }\n\n    return result\n  }\n\n  static deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): Array<SchemaKeywordMapper[T]> {\n    const foundItems: SchemaKeywordMapper[T][] = []\n\n    tree?.forEach((schema) => {\n      if (schema.keyword === keyword) {\n        foundItems.push(schema as SchemaKeywordMapper[T])\n      }\n\n      if (isKeyword(schema, schemaKeywords.object)) {\n        Object.values(schema.args?.properties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>(entrySchema, keyword))\n        })\n\n        Object.values(schema.args?.additionalProperties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n\n        if (schema.args?.patternProperties) {\n          Object.values(schema.args.patternProperties).forEach((entrySchemas) => {\n            entrySchemas.forEach((entrySchema) => {\n              foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n            })\n          })\n        }\n      }\n\n      if (isKeyword(schema, schemaKeywords.array)) {\n        schema.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.and)) {\n        schema.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.tuple)) {\n        schema.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.union)) {\n        schema.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n    })\n\n    return foundItems\n  }\n\n  static find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    let foundItem: SchemaKeywordMapper[T] | undefined\n\n    tree?.forEach((schema) => {\n      if (!foundItem && schema.keyword === keyword) {\n        foundItem = schema as SchemaKeywordMapper[T]\n      }\n\n      if (isKeyword(schema, schemaKeywords.array)) {\n        schema.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.and)) {\n        schema.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.tuple)) {\n        schema.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (isKeyword(schema, schemaKeywords.union)) {\n        schema.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n    })\n\n    return foundItem\n  }\n\n  static combineObjects(tree: Schema[] | undefined): Schema[] {\n    if (!tree) {\n      return []\n    }\n\n    return tree.map((schema) => {\n      if (!isKeyword(schema, schemaKeywords.and)) {\n        return schema\n      }\n\n      let mergedProperties: Record<string, Schema[]> | null = null\n      let mergedAdditionalProps: Schema[] = []\n\n      const newArgs: Schema[] = []\n\n      for (const subSchema of schema.args) {\n        if (isKeyword(subSchema, schemaKeywords.object)) {\n          const { properties = {}, additionalProperties = [] } = subSchema.args ?? {}\n\n          if (!mergedProperties) {\n            mergedProperties = {}\n          }\n\n          for (const [key, value] of Object.entries(properties)) {\n            mergedProperties[key] = value\n          }\n\n          if (additionalProperties.length > 0) {\n            mergedAdditionalProps = additionalProperties\n          }\n        } else {\n          newArgs.push(subSchema)\n        }\n      }\n\n      if (mergedProperties) {\n        newArgs.push({\n          keyword: schemaKeywords.object,\n          args: {\n            properties: mergedProperties,\n            additionalProperties: mergedAdditionalProps,\n          },\n        })\n      }\n\n      return {\n        keyword: schemaKeywords.and,\n        args: newArgs,\n      }\n    })\n  }\n\n  #getOptions(name: string | null): Partial<TOptions> {\n    const { override = [] } = this.context\n\n    return {\n      ...this.options,\n      ...(override.find(({ pattern, type }) => {\n        if (name && type === 'schemaName') {\n          return !!name.match(pattern)\n        }\n\n        return false\n      })?.options || {}),\n    }\n  }\n\n  #getUnknownType(name: string | null): string {\n    const options = this.#getOptions(name)\n\n    if (options.unknownType === 'any') {\n      return schemaKeywords.any\n    }\n    if (options.unknownType === 'void') {\n      return schemaKeywords.void\n    }\n\n    return schemaKeywords.unknown\n  }\n\n  #getEmptyType(name: string | null): string {\n    const options = this.#getOptions(name)\n\n    if (options.emptySchemaType === 'any') {\n      return schemaKeywords.any\n    }\n    if (options.emptySchemaType === 'void') {\n      return schemaKeywords.void\n    }\n\n    return schemaKeywords.unknown\n  }\n\n  /**\n   * Recursively creates a type literal with the given props.\n   */\n  #parseProperties(name: string | null, schemaObject: SchemaObject, rootName?: string | null): Schema[] {\n    const properties = schemaObject?.properties || {}\n    const additionalProperties = schemaObject?.additionalProperties\n    const required = schemaObject?.required\n    const patternProperties = schemaObject && 'patternProperties' in schemaObject ? schemaObject.patternProperties : undefined\n\n    const propertiesSchemas = Object.keys(properties)\n      .map((propertyName) => {\n        const validationFunctions: Schema[] = []\n        const propertySchema = properties[propertyName] as SchemaObject\n\n        const isRequired = Array.isArray(required) ? required?.includes(propertyName) : !!required\n        const nullable = isNullable(propertySchema)\n\n        validationFunctions.push(...this.parse({ schema: propertySchema, name: propertyName, parentName: name, rootName: rootName || name }))\n\n        validationFunctions.push({\n          keyword: schemaKeywords.name,\n          args: propertyName,\n        })\n\n        if (!isRequired && nullable) {\n          validationFunctions.push({ keyword: schemaKeywords.nullish })\n        } else if (!isRequired) {\n          validationFunctions.push({ keyword: schemaKeywords.optional })\n        }\n\n        return {\n          [propertyName]: validationFunctions,\n        }\n      })\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {})\n    let additionalPropertiesSchemas: Schema[] = []\n\n    if (additionalProperties) {\n      additionalPropertiesSchemas =\n        additionalProperties === true || !Object.keys(additionalProperties).length\n          ? [{ keyword: this.#getUnknownType(name) }]\n          : this.parse({ schema: additionalProperties as SchemaObject, name: null, parentName: name, rootName: rootName || name })\n    }\n\n    let patternPropertiesSchemas: Record<string, Schema[]> = {}\n\n    if (patternProperties && typeof patternProperties === 'object') {\n      patternPropertiesSchemas = Object.entries(patternProperties).reduce((acc, [pattern, patternSchema]) => {\n        const schemas =\n          patternSchema === true || !Object.keys(patternSchema as object).length\n            ? [{ keyword: this.#getUnknownType(name) }]\n            : this.parse({ schema: patternSchema, name: null, parentName: name, rootName: rootName || name })\n\n        return {\n          ...acc,\n          [pattern]: schemas,\n        }\n      }, {})\n    }\n\n    const args: {\n      properties: typeof propertiesSchemas\n      additionalProperties: typeof additionalPropertiesSchemas\n      patternProperties?: typeof patternPropertiesSchemas\n    } = {\n      properties: propertiesSchemas,\n      additionalProperties: additionalPropertiesSchemas,\n    }\n\n    if (Object.keys(patternPropertiesSchemas).length > 0) {\n      args['patternProperties'] = patternPropertiesSchemas\n    }\n\n    return [\n      {\n        keyword: schemaKeywords.object,\n        args,\n      },\n    ]\n  }\n\n  /**\n   * Create a type alias for the schema referenced by the given ReferenceObject\n   */\n  #getRefAlias(schemaObject: OpenAPIV3.ReferenceObject, name: string | null): Schema[] {\n    const { $ref } = schemaObject\n    const ref = this.refs[$ref]\n\n    if (ref) {\n      const dereferencedSchema = this.context.oas.dereferenceWithRef(schemaObject)\n      // pass name to getRefAlias and use that to find in discriminator.mapping value\n\n      if (dereferencedSchema && isDiscriminator(dereferencedSchema)) {\n        const [key] = Object.entries(dereferencedSchema.discriminator.mapping || {}).find(([_key, value]) => value.replace(/.+\\//, '') === name) || []\n\n        if (key) {\n          return [\n            {\n              keyword: schemaKeywords.and,\n              args: [\n                {\n                  keyword: schemaKeywords.ref,\n                  args: { name: ref.propertyName, $ref, path: ref.path, isImportable: !!this.context.oas.get($ref) },\n                },\n                {\n                  keyword: schemaKeywords.object,\n                  args: {\n                    properties: {\n                      [dereferencedSchema.discriminator.propertyName]: [\n                        {\n                          keyword: schemaKeywords.const,\n                          args: {\n                            name: key,\n                            format: 'string',\n                            value: key,\n                          },\n                        },\n                      ],\n                    },\n                  },\n                },\n              ],\n            },\n          ] as Schema[]\n        }\n      }\n\n      return [\n        {\n          keyword: schemaKeywords.ref,\n          args: { name: ref.propertyName, $ref, path: ref.path, isImportable: !!this.context.oas.get($ref) },\n        },\n      ]\n    }\n\n    // Ensure name mapping is initialized before resolving names\n    this.#ensureNameMapping()\n\n    const originalName = $ref.replace(/.+\\//, '')\n    // Use the full $ref path to look up the collision-resolved name\n    const resolvedName = this.#schemaNameMapping.get($ref) || originalName\n\n    const propertyName = this.context.pluginManager.resolveName({\n      name: resolvedName,\n      pluginKey: this.context.plugin.key,\n      type: 'function',\n    })\n\n    const fileName = this.context.pluginManager.resolveName({\n      name: resolvedName,\n      pluginKey: this.context.plugin.key,\n      type: 'file',\n    })\n    const file = this.context.pluginManager.getFile({\n      name: fileName,\n      pluginKey: this.context.plugin.key,\n      extname: '.ts',\n    })\n\n    this.refs[$ref] = {\n      propertyName,\n      originalName: resolvedName,\n      path: file.path,\n    }\n\n    return this.#getRefAlias(schemaObject, name)\n  }\n\n  #getParsedSchemaObject(schema: SchemaObject | null) {\n    return getSchemaFactory(this.context.oas)(schema)\n  }\n\n  #addDiscriminatorToSchema<TSchema extends Schema>({\n    schema,\n    schemaObject,\n    discriminator,\n  }: {\n    schemaObject: SchemaObject\n    schema: TSchema\n    discriminator: OpenAPIV3.DiscriminatorObject\n  }): TSchema {\n    if (!isKeyword(schema, schemaKeywords.union)) {\n      return schema\n    }\n\n    // If the discriminator property is an extension property (starts with x-),\n    // its metadata and not an actual schema property, so we can't add constraints for it.\n    // In this case, return the union as-is without adding discriminator constraints.\n    if (discriminator.propertyName.startsWith('x-')) {\n      return schema\n    }\n\n    const objectPropertySchema = SchemaGenerator.find(this.parse({ schema: schemaObject, name: null, parentName: null, rootName: null }), schemaKeywords.object)\n\n    return {\n      ...schema,\n      args: Object.entries(discriminator.mapping || {})\n        .map(([key, value]) => {\n          let arg: Schema | undefined\n\n          // Check if this is a synthetic ref for inline schemas (e.g., #kubb-inline-0)\n          if (value.startsWith('#kubb-inline-')) {\n            const index = Number.parseInt(value.replace('#kubb-inline-', ''), 10)\n            // Validate index is within bounds\n            if (!Number.isNaN(index) && index >= 0 && index < schema.args.length) {\n              arg = schema.args[index]\n            }\n          } else {\n            // Regular ref - find by $ref value\n            arg = schema.args.find((item) => isKeyword(item, schemaKeywords.ref) && item.args.$ref === value)\n          }\n\n          // Skip discriminator mappings that don't have a corresponding schema in the oneOf/anyOf\n          if (!arg) {\n            return undefined\n          }\n          return {\n            keyword: schemaKeywords.and,\n            args: [\n              arg,\n              {\n                keyword: schemaKeywords.object,\n                args: {\n                  properties: {\n                    ...(objectPropertySchema?.args?.properties || {}),\n                    [discriminator.propertyName]: [\n                      {\n                        keyword: schemaKeywords.const,\n                        args: {\n                          name: key,\n                          format: 'string',\n                          value: key,\n                        },\n                      },\n                      //enum and literal will conflict\n                      ...(objectPropertySchema?.args?.properties[discriminator.propertyName] || []),\n                    ].filter((item) => !isKeyword(item, schemaKeywords.enum)),\n                  },\n                },\n              },\n            ],\n          }\n        })\n        .filter(Boolean) as SchemaKeywordMapper['union']['args'],\n    }\n  }\n\n  /**\n   * Checks if an allOf item reference would create a circular reference.\n   * This happens when a child schema extends a discriminator parent via allOf,\n   * and the parent has a oneOf/anyOf that references or maps to the child.\n   *\n   * Without oneOf/anyOf, the discriminator is just for documentation/validation\n   * purposes and doesn't create a TypeScript union type that would be circular.\n   */\n  #wouldCreateCircularReference(item: unknown, childSchemaName: string | null): boolean {\n    if (!isReference(item) || !childSchemaName) {\n      return false\n    }\n\n    const dereferencedSchema = this.context.oas.dereferenceWithRef(item)\n\n    if (dereferencedSchema && isDiscriminator(dereferencedSchema)) {\n      // Only check for circular references if parent has oneOf/anyOf\n      // Without oneOf/anyOf, the discriminator doesn't create a union type\n      const parentOneOf = dereferencedSchema.oneOf || dereferencedSchema.anyOf\n      if (!parentOneOf) {\n        return false\n      }\n\n      const childRef = `#/components/schemas/${childSchemaName}`\n\n      const inOneOf = parentOneOf.some((oneOfItem) => {\n        return isReference(oneOfItem) && oneOfItem.$ref === childRef\n      })\n      if (inOneOf) {\n        return true\n      }\n\n      const mapping = dereferencedSchema.discriminator.mapping || {}\n      const inMapping = Object.values(mapping).some((value) => value === childRef)\n\n      if (inMapping) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * This is the very core of the OpenAPI to TS conversion - it takes a\n   * schema and returns the appropriate type.\n   */\n  #parseSchemaObject({ schema: _schemaObject, name, parentName, rootName }: SchemaProps): Schema[] {\n    const normalizedSchema = this.context.oas.flattenSchema(_schemaObject)\n\n    const { schemaObject, version } = this.#getParsedSchemaObject(normalizedSchema)\n\n    const options = this.#getOptions(name)\n    const emptyType = this.#getEmptyType(name)\n\n    if (!schemaObject) {\n      return [{ keyword: emptyType }]\n    }\n\n    const baseItems: Schema[] = [\n      {\n        keyword: schemaKeywords.schema,\n        args: {\n          type: schemaObject.type as any,\n          format: schemaObject.format,\n        },\n      },\n    ]\n    const min = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? undefined\n    const max = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? undefined\n\n    const exclusiveMinimum = schemaObject.exclusiveMinimum\n    const exclusiveMaximum = schemaObject.exclusiveMaximum\n\n    const nullable = isNullable(schemaObject)\n    const defaultNullAndNullable = schemaObject.default === null && nullable\n\n    if (schemaObject.default !== undefined && !defaultNullAndNullable && !Array.isArray(schemaObject.default)) {\n      if (typeof schemaObject.default === 'string') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: transformers.stringify(schemaObject.default),\n        })\n      } else if (typeof schemaObject.default === 'boolean') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schemaObject.default ?? false,\n        })\n      } else {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schemaObject.default,\n        })\n      }\n    }\n\n    if (schemaObject.deprecated) {\n      baseItems.push({\n        keyword: schemaKeywords.deprecated,\n      })\n    }\n\n    if (schemaObject.description) {\n      baseItems.push({\n        keyword: schemaKeywords.describe,\n        args: schemaObject.description,\n      })\n    }\n\n    if (max !== undefined) {\n      if (exclusiveMaximum) {\n        baseItems.unshift({ keyword: schemaKeywords.exclusiveMaximum, args: max })\n      } else {\n        baseItems.unshift({ keyword: schemaKeywords.max, args: max })\n      }\n    }\n\n    if (min !== undefined) {\n      if (exclusiveMinimum) {\n        baseItems.unshift({ keyword: schemaKeywords.exclusiveMinimum, args: min })\n      } else {\n        baseItems.unshift({ keyword: schemaKeywords.min, args: min })\n      }\n    }\n\n    if (typeof exclusiveMaximum === 'number') {\n      //OPENAPI v3.1.0: https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n      baseItems.unshift({ keyword: schemaKeywords.exclusiveMaximum, args: exclusiveMaximum })\n    }\n    if (typeof exclusiveMinimum === 'number') {\n      //OPENAPI v3.1.0: https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n      baseItems.unshift({ keyword: schemaKeywords.exclusiveMinimum, args: exclusiveMinimum })\n    }\n    if (nullable) {\n      baseItems.push({ keyword: schemaKeywords.nullable })\n    }\n\n    if (schemaObject.type && Array.isArray(schemaObject.type)) {\n      // OPENAPI v3.1.0: https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n      const items = schemaObject.type.filter((value) => value !== 'null') as Array<OpenAPIV3.NonArraySchemaObjectType>\n\n      if (items.length > 1) {\n        const parsedItems = [\n          {\n            keyword: schemaKeywords.union,\n            args: items\n              .map(\n                (item) =>\n                  this.parse({\n                    schema: { ...schemaObject, type: item },\n                    name,\n                    parentName,\n                    rootName,\n                  })[0],\n              )\n              .filter(Boolean)\n              .map((item) => (isKeyword(item, schemaKeywords.object) ? { ...item, args: { ...item.args, strict: true } } : item)),\n          },\n        ]\n\n        return [...parsedItems, ...baseItems].filter(Boolean)\n      }\n    }\n\n    if (schemaObject.readOnly) {\n      baseItems.push({ keyword: schemaKeywords.readOnly })\n    }\n\n    if (schemaObject.writeOnly) {\n      baseItems.push({ keyword: schemaKeywords.writeOnly })\n    }\n\n    if (isReference(schemaObject)) {\n      return [\n        ...this.#getRefAlias(schemaObject, name),\n        schemaObject.description && {\n          keyword: schemaKeywords.describe,\n          args: schemaObject.description,\n        },\n        schemaObject.pattern &&\n          schemaObject.type === 'string' && {\n            keyword: schemaKeywords.matches,\n            args: schemaObject.pattern,\n          },\n        nullable && { keyword: schemaKeywords.nullable },\n        schemaObject.readOnly && { keyword: schemaKeywords.readOnly },\n        schemaObject.writeOnly && { keyword: schemaKeywords.writeOnly },\n        {\n          keyword: schemaKeywords.schema,\n          args: {\n            type: schemaObject.type as any,\n            format: schemaObject.format,\n          },\n        },\n      ].filter(Boolean)\n    }\n\n    if (schemaObject.oneOf || schemaObject.anyOf) {\n      // union\n      const schemaWithoutOneOf = { ...schemaObject, oneOf: undefined, anyOf: undefined }\n      const discriminator = this.context.oas.getDiscriminator(schemaObject)\n\n      const union: SchemaKeywordMapper['union'] = {\n        keyword: schemaKeywords.union,\n        args: (schemaObject.oneOf || schemaObject.anyOf)!\n          .map((item) => {\n            // first item, this is ref\n            return item && this.parse({ schema: item as SchemaObject, name, parentName, rootName })[0]\n          })\n          .filter(Boolean),\n      }\n\n      if (discriminator) {\n        // In 'inherit' mode, the discriminator property is already added to child schemas by Oas.getDiscriminator()\n        // so we should NOT add it at the union level\n        if (this.context && this.context.oas.options.discriminator !== 'inherit') {\n          return [this.#addDiscriminatorToSchema({ schemaObject: schemaWithoutOneOf, schema: union, discriminator }), ...baseItems]\n        }\n      }\n\n      if (schemaWithoutOneOf.properties) {\n        const propertySchemas = this.parse({ schema: schemaWithoutOneOf, name, parentName, rootName })\n\n        union.args = [\n          ...union.args.map((arg) => {\n            return {\n              keyword: schemaKeywords.and,\n              args: [arg, ...propertySchemas],\n            }\n          }),\n        ]\n\n        return [union, ...baseItems]\n      }\n\n      return [union, ...baseItems]\n    }\n\n    if (schemaObject.allOf) {\n      // intersection/add\n      const schemaWithoutAllOf = { ...schemaObject, allOf: undefined }\n\n      const and: Schema = {\n        keyword: schemaKeywords.and,\n        args: schemaObject.allOf\n          .flatMap((item) => {\n            // Skip items that would create circular references\n            if (this.#wouldCreateCircularReference(item, name)) {\n              return []\n            }\n\n            return item ? this.parse({ schema: item, name, parentName, rootName }) : []\n          })\n          .filter(Boolean),\n      }\n\n      if (schemaWithoutAllOf.required?.length) {\n        const allOfItems = schemaObject.allOf\n        const resolvedSchemas: SchemaObject[] = []\n\n        for (const item of allOfItems) {\n          const resolved = isReference(item) ? (this.context.oas.get(item.$ref) as SchemaObject) : item\n\n          if (resolved) {\n            resolvedSchemas.push(resolved)\n          }\n        }\n\n        const existingKeys = schemaWithoutAllOf.properties ? new Set(Object.keys(schemaWithoutAllOf.properties)) : null\n\n        const parsedItems: SchemaObject[] = []\n\n        for (const key of schemaWithoutAllOf.required) {\n          if (existingKeys?.has(key)) {\n            continue\n          }\n\n          for (const schema of resolvedSchemas) {\n            if (schema.properties?.[key]) {\n              parsedItems.push({\n                properties: {\n                  [key]: schema.properties[key],\n                },\n                required: [key],\n              } as SchemaObject)\n              break\n            }\n          }\n        }\n\n        for (const item of parsedItems) {\n          const parsed = this.parse({ schema: item, name, parentName, rootName })\n\n          if (Array.isArray(parsed)) {\n            and.args = and.args ? and.args.concat(parsed) : parsed\n          }\n        }\n      }\n\n      if (schemaWithoutAllOf.properties) {\n        and.args = [...(and.args || []), ...this.parse({ schema: schemaWithoutAllOf, name, parentName, rootName })]\n      }\n\n      return SchemaGenerator.combineObjects([and, ...baseItems])\n    }\n\n    if (schemaObject.enum) {\n      // Handle malformed schema where enum exists at array level instead of in items\n      // This normalizes: { type: 'array', enum: [...], items: {...} }\n      // Into: { type: 'array', items: { type: 'string', enum: [...] } }\n      if (schemaObject.type === 'array') {\n        const isItemsObject = typeof schemaObject.items === 'object' && !Array.isArray(schemaObject.items)\n        const normalizedItems = {\n          ...(isItemsObject ? schemaObject.items : {}),\n          enum: schemaObject.enum,\n        } as SchemaObject\n\n        const { enum: _, ...schemaWithoutEnum } = schemaObject\n        const normalizedSchema = {\n          ...schemaWithoutEnum,\n          items: normalizedItems,\n        } as SchemaObject\n\n        return this.parse({ schema: normalizedSchema, name, parentName, rootName })\n      }\n\n      // Removed verbose enum parsing debug log - too noisy for hundreds of enums\n\n      // Include rootName in enum naming to avoid collisions for nested enums with same path\n      // Only add rootName if it differs from parentName to avoid duplication\n      // This is controlled by the collisionDetection flag to maintain backward compatibility\n      const useCollisionDetection = this.context.oas.options.collisionDetection ?? false\n      const enumNameParts =\n        useCollisionDetection && rootName && rootName !== parentName ? [rootName, parentName, name, options.enumSuffix] : [parentName, name, options.enumSuffix]\n\n      // @deprecated usedEnumNames will be removed in v5 - collisionDetection with rootName-based naming eliminates the need for numeric suffixes\n      const enumName = useCollisionDetection\n        ? pascalCase(enumNameParts.join(' '))\n        : getUniqueName(pascalCase(enumNameParts.join(' ')), this.options.usedEnumNames || {})\n      const typeName = this.context.pluginManager.resolveName({\n        name: enumName,\n        pluginKey: this.context.plugin.key,\n        type: 'type',\n      })\n\n      const nullableEnum = schemaObject.enum.includes(null)\n      if (nullableEnum) {\n        baseItems.push({ keyword: schemaKeywords.nullable })\n      }\n      const filteredValues = schemaObject.enum.filter((value) => value !== null)\n\n      // x-enumNames has priority\n      const extensionEnums = ['x-enumNames', 'x-enum-varnames']\n        .filter((extensionKey) => extensionKey in schemaObject)\n        .map((extensionKey) => {\n          return [\n            {\n              keyword: schemaKeywords.enum,\n              args: {\n                name,\n                typeName,\n                asConst: false,\n                items: [...new Set(schemaObject[extensionKey as keyof typeof schemaObject] as string[])].map((name: string | number, index) => ({\n                  name: transformers.stringify(name),\n                  value: schemaObject.enum?.[index] as string | number,\n                  format: isNumber(schemaObject.enum?.[index]) ? 'number' : 'string',\n                })),\n              },\n            },\n            ...baseItems.filter(\n              (item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches,\n            ),\n          ]\n        })\n\n      if (schemaObject.type === 'number' || schemaObject.type === 'integer') {\n        // we cannot use z.enum when enum type is number/integer\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'number',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'number',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (schemaObject.type === 'boolean') {\n        // we cannot use z.enum when enum type is boolean\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'boolean',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'boolean',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (extensionEnums.length > 0 && extensionEnums[0]) {\n        return extensionEnums[0]\n      }\n\n      return [\n        {\n          keyword: schemaKeywords.enum,\n          args: {\n            name: enumName,\n            typeName,\n            asConst: false,\n            items: [...new Set(filteredValues)].map((value: string) => ({\n              name: transformers.stringify(value),\n              value,\n              format: isNumber(value) ? 'number' : 'string',\n            })),\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n      ]\n    }\n\n    if ('prefixItems' in schemaObject) {\n      const prefixItems = schemaObject.prefixItems as SchemaObject[]\n      const items = 'items' in schemaObject ? (schemaObject.items as SchemaObject[]) : []\n      const min = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? undefined\n      const max = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? undefined\n\n      return [\n        {\n          keyword: schemaKeywords.tuple,\n          args: {\n            min,\n            max,\n            items: prefixItems\n              .map((item) => {\n                return this.parse({ schema: item, name, parentName, rootName })[0]\n              })\n              .filter(Boolean),\n            rest: this.parse({\n              schema: items,\n              name,\n              parentName,\n              rootName,\n            })[0],\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (version === '3.1' && 'const' in schemaObject) {\n      // const keyword takes precedence over the actual type.\n\n      if (schemaObject['const'] === null) {\n        return [{ keyword: schemaKeywords.null }]\n      }\n      if (schemaObject['const'] === undefined) {\n        return [{ keyword: schemaKeywords.undefined }]\n      }\n\n      let format = typeof schemaObject['const']\n      if (format !== 'number' && format !== 'boolean') {\n        format = 'string'\n      }\n\n      return [\n        {\n          keyword: schemaKeywords.const,\n          args: {\n            name: schemaObject['const'],\n            format,\n            value: schemaObject['const'],\n          },\n        },\n        ...baseItems,\n      ]\n    }\n\n    /**\n     * > Structural validation alone may be insufficient to allow an application to correctly utilize certain values. The \"format\"\n     * > annotation keyword is defined to allow schema authors to convey semantic information for a fixed subset of values which are\n     * > accurately described by authoritative resources, be they RFCs or other external specifications.\n     *\n     * In other words: format is more specific than type alone, hence it should override the type value, if possible.\n     *\n     * see also https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-00#rfc.section.7\n     */\n    if (schemaObject.format) {\n      if (schemaObject.type === 'integer' && (schemaObject.format === 'int32' || schemaObject.format === 'int64')) {\n        baseItems.unshift({ keyword: schemaKeywords.integer })\n        return baseItems\n      }\n\n      if (schemaObject.type === 'number' && (schemaObject.format === 'float' || schemaObject.format === 'double')) {\n        baseItems.unshift({ keyword: schemaKeywords.number })\n        return baseItems\n      }\n\n      switch (schemaObject.format) {\n        case 'binary':\n          baseItems.push({ keyword: schemaKeywords.blob })\n          return baseItems\n        case 'date-time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            if (options.dateType === 'stringOffset') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: true } })\n              return baseItems\n            }\n\n            if (options.dateType === 'stringLocal') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { local: true } })\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: false } })\n\n            return baseItems\n          }\n          break\n        case 'date':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'uuid':\n          baseItems.unshift({ keyword: schemaKeywords.uuid })\n          return baseItems\n        case 'email':\n        case 'idn-email':\n          baseItems.unshift({ keyword: schemaKeywords.email })\n          return baseItems\n        case 'uri':\n        case 'ipv4':\n        case 'ipv6':\n        case 'uri-reference':\n        case 'hostname':\n        case 'idn-hostname':\n          baseItems.unshift({ keyword: schemaKeywords.url })\n          return baseItems\n        // case 'duration':\n        // case 'json-pointer':\n        // case 'relative-json-pointer':\n        default:\n          // formats not yet implemented: ignore.\n          break\n      }\n    }\n\n    if (schemaObject.pattern && schemaObject.type === 'string') {\n      baseItems.unshift({\n        keyword: schemaKeywords.matches,\n        args: schemaObject.pattern,\n      })\n\n      return baseItems\n    }\n\n    // type based logic\n    if ('items' in schemaObject || schemaObject.type === ('array' as 'string')) {\n      const min = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? undefined\n      const max = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? undefined\n      const items = this.parse({ schema: 'items' in schemaObject ? (schemaObject.items as SchemaObject) : [], name, parentName, rootName })\n      const unique = !!schemaObject.uniqueItems\n\n      return [\n        {\n          keyword: schemaKeywords.array,\n          args: {\n            items,\n            min,\n            max,\n            unique,\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (schemaObject.properties || schemaObject.additionalProperties || 'patternProperties' in schemaObject) {\n      if (isDiscriminator(schemaObject)) {\n        // override schema to set type to be based on discriminator mapping, use of enum to convert type string to type 'mapping1' | 'mapping2'\n        const schemaObjectOverridden = Object.keys(schemaObject.properties || {}).reduce((acc, propertyName) => {\n          if (acc.properties?.[propertyName] && propertyName === schemaObject.discriminator.propertyName) {\n            return {\n              ...acc,\n              properties: {\n                ...acc.properties,\n                [propertyName]: {\n                  ...((acc.properties[propertyName] as any) || {}),\n                  enum: schemaObject.discriminator.mapping ? Object.keys(schemaObject.discriminator.mapping) : undefined,\n                },\n              },\n            }\n          }\n\n          return acc\n        }, schemaObject || {}) as SchemaObject\n\n        return [...this.#parseProperties(name, schemaObjectOverridden, rootName), ...baseItems]\n      }\n\n      return [...this.#parseProperties(name, schemaObject, rootName), ...baseItems]\n    }\n\n    if (schemaObject.type) {\n      const type = (\n        Array.isArray(schemaObject.type) ? schemaObject.type.filter((item) => item !== 'null')[0] : schemaObject.type\n      ) as OpenAPIV3.NonArraySchemaObjectType\n\n      if (!['boolean', 'object', 'number', 'string', 'integer', 'null'].includes(type)) {\n        this.context.events?.emit('warn', `Schema type '${schemaObject.type}' is not valid for schema ${parentName}.${name}`)\n        // Removed duplicate debug log - warning already provides the information needed\n      }\n\n      // 'string' | 'number' | 'integer' | 'boolean'\n      return [{ keyword: type }, ...baseItems]\n    }\n\n    // Infer type from constraints when no explicit type is provided\n    let inferredType: OpenAPIV3.NonArraySchemaObjectType | undefined\n    if (schemaObject.minLength !== undefined || schemaObject.maxLength !== undefined || schemaObject.pattern !== undefined) {\n      inferredType = 'string'\n    } else if (schemaObject.minimum !== undefined || schemaObject.maximum !== undefined) {\n      inferredType = 'number'\n    }\n    // Note: minItems/maxItems don't infer type 'array' because arrays are handled\n    // specially with schemaKeywords.array and require an items property\n\n    if (inferredType) {\n      return [{ keyword: inferredType }, ...baseItems]\n    }\n\n    return [{ keyword: emptyType }, ...baseItems]\n  }\n\n  async build(...generators: Array<Generator<TPluginOptions>>): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const { oas, contentType, include } = this.context\n\n    // Initialize the name mapping if not already done\n    if (!this.#nameMappingInitialized) {\n      const { schemas, nameMapping } = oas.getSchemas({ contentType, includes: include })\n      this.#schemaNameMapping = nameMapping\n      this.#nameMappingInitialized = true\n      const schemaEntries = Object.entries(schemas)\n\n      this.context.events?.emit('debug', {\n        date: new Date(),\n        logs: [`Building ${schemaEntries.length} schemas`, `   Content Type: ${contentType || 'application/json'}`, `   Generators: ${generators.length}`],\n      })\n\n      // Continue with build using the schemas\n      return this.#doBuild(schemas, generators)\n    }\n    // If already initialized, just get the schemas (without mapping)\n    const { schemas } = oas.getSchemas({ contentType, includes: include })\n    return this.#doBuild(schemas, generators)\n  }\n\n  async #doBuild(schemas: Record<string, OasTypes.SchemaObject>, generators: Array<Generator<TPluginOptions>>): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const schemaEntries = Object.entries(schemas)\n\n    // Increased parallelism for better performance\n    // - generatorLimit increased from 1 to 3 to allow parallel generator processing\n    // - schemaLimit increased from 10 to 30 to process more schemas concurrently\n    const generatorLimit = pLimit(3)\n    const schemaLimit = pLimit(30)\n\n    const writeTasks = generators.map((generator) =>\n      generatorLimit(async () => {\n        const schemaTasks = schemaEntries.map(([name, schemaObject]) =>\n          schemaLimit(async () => {\n            const options = this.#getOptions(name)\n            const tree = this.parse({ schema: schemaObject, name, parentName: null, rootName: name })\n\n            if (generator.type === 'react') {\n              await buildSchema(\n                {\n                  name,\n                  value: schemaObject,\n                  tree,\n                },\n                {\n                  config: this.context.pluginManager.config,\n                  fabric: this.context.fabric,\n                  Component: generator.Schema,\n                  generator: this,\n                  plugin: {\n                    ...this.context.plugin,\n                    options: {\n                      ...this.options,\n                      ...options,\n                    },\n                  },\n                },\n              )\n\n              return []\n            }\n\n            const result = await generator.schema?.({\n              config: this.context.pluginManager.config,\n              generator: this,\n              schema: {\n                name,\n                value: schemaObject,\n                tree,\n              },\n              plugin: {\n                ...this.context.plugin,\n                options: {\n                  ...this.options,\n                  ...options,\n                },\n              },\n            })\n\n            return result ?? []\n          }),\n        )\n\n        const schemaResults = await Promise.all(schemaTasks)\n        return schemaResults.flat() as unknown as KubbFile.File<TFileMeta>\n      }),\n    )\n\n    const nestedResults = await Promise.all(writeTasks)\n\n    return nestedResults.flat()\n  }\n}\n"],"x_google_ignoreList":[0,1],"mappings":"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"}