import { t as __name } from "./chunk-iVr_oF3V.js";
import { n as schemaKeywords, t as isKeyword } from "./SchemaMapper-D-GETHNf.js";
import { t as getSchemaFactory } from "./getSchemaFactory-DsoVRgxV.js";
import { BaseGenerator } from "@kubb/core";
import transformers, { pascalCase } from "@kubb/core/transformers";
import { getUniqueName } from "@kubb/core/utils";
import { isDiscriminator, isNullable, isReference } from "@kubb/oas";
import { isDeepEqual, isNumber, uniqueWith } from "remeda";
import { App, createReactFabric } from "@kubb/react-fabric";
import { jsx } from "@kubb/react-fabric/jsx-runtime";

//#region ../../node_modules/.pnpm/yocto-queue@1.2.2/node_modules/yocto-queue/index.js
var Node = class {
	value;
	next;
	constructor(value) {
		this.value = value;
	}
};
var Queue = class {
	#head;
	#tail;
	#size;
	constructor() {
		this.clear();
	}
	enqueue(value) {
		const node = new Node(value);
		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}
		this.#size++;
	}
	dequeue() {
		const current = this.#head;
		if (!current) return;
		this.#head = this.#head.next;
		this.#size--;
		if (!this.#head) this.#tail = void 0;
		return current.value;
	}
	peek() {
		if (!this.#head) return;
		return this.#head.value;
	}
	clear() {
		this.#head = void 0;
		this.#tail = void 0;
		this.#size = 0;
	}
	get size() {
		return this.#size;
	}
	*[Symbol.iterator]() {
		let current = this.#head;
		while (current) {
			yield current.value;
			current = current.next;
		}
	}
	*drain() {
		while (this.#head) yield this.dequeue();
	}
};

//#endregion
//#region ../../node_modules/.pnpm/p-limit@7.2.0/node_modules/p-limit/index.js
function pLimit(concurrency) {
	validateConcurrency(concurrency);
	const queue = new Queue();
	let activeCount = 0;
	const resumeNext = () => {
		if (activeCount < concurrency && queue.size > 0) {
			activeCount++;
			queue.dequeue()();
		}
	};
	const next = () => {
		activeCount--;
		resumeNext();
	};
	const run = async (function_, resolve, arguments_) => {
		const result = (async () => function_(...arguments_))();
		resolve(result);
		try {
			await result;
		} catch {}
		next();
	};
	const enqueue = (function_, resolve, arguments_) => {
		new Promise((internalResolve) => {
			queue.enqueue(internalResolve);
		}).then(run.bind(void 0, function_, resolve, arguments_));
		if (activeCount < concurrency) resumeNext();
	};
	const generator = (function_, ...arguments_) => new Promise((resolve) => {
		enqueue(function_, resolve, arguments_);
	});
	Object.defineProperties(generator, {
		activeCount: { get: () => activeCount },
		pendingCount: { get: () => queue.size },
		clearQueue: { value() {
			queue.clear();
		} },
		concurrency: {
			get: () => concurrency,
			set(newConcurrency) {
				validateConcurrency(newConcurrency);
				concurrency = newConcurrency;
				queueMicrotask(() => {
					while (activeCount < concurrency && queue.size > 0) resumeNext();
				});
			}
		},
		map: { async value(iterable, function_) {
			const promises = Array.from(iterable, (value, index) => this(function_, value, index));
			return Promise.all(promises);
		} }
	});
	return generator;
}
function validateConcurrency(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) throw new TypeError("Expected `concurrency` to be a number from 1 and up");
}

//#endregion
//#region src/utils.tsx
async function buildOperations(operations, { config, fabric, plugin, generator, Component }) {
	if (!Component) return;
	const { pluginManager, oas, mode } = generator.context;
	const fabricChild = createReactFabric();
	await fabricChild.render(/* @__PURE__ */ jsx(App, {
		meta: {
			pluginManager,
			plugin,
			mode,
			oas
		},
		children: /* @__PURE__ */ jsx(Component, {
			config,
			operations,
			generator,
			plugin
		})
	}));
	await fabric.context.fileManager.upsert(...fabricChild.files);
}
async function buildOperation(operation, { config, fabric, plugin, generator, Component }) {
	if (!Component) return;
	const { pluginManager, oas, mode } = generator.context;
	const fabricChild = createReactFabric();
	await fabricChild.render(/* @__PURE__ */ jsx(App, {
		meta: {
			pluginManager,
			plugin,
			mode,
			oas
		},
		children: /* @__PURE__ */ jsx(Component, {
			config,
			operation,
			plugin,
			generator
		})
	}));
	await fabric.context.fileManager.upsert(...fabricChild.files);
}
async function buildSchema(schema, { config, fabric, plugin, Component, generator }) {
	if (!Component) return;
	const { pluginManager, oas, mode } = generator.context;
	const fabricChild = createReactFabric();
	await fabricChild.render(/* @__PURE__ */ jsx(App, {
		meta: {
			pluginManager,
			plugin,
			mode,
			oas
		},
		children: /* @__PURE__ */ jsx(Component, {
			config,
			schema,
			plugin,
			generator
		})
	}));
	await fabric.context.fileManager.upsert(...fabricChild.files);
}

//#endregion
//#region src/SchemaGenerator.ts
var SchemaGenerator = class SchemaGenerator extends BaseGenerator {
	refs = {};
	#schemaNameMapping = /* @__PURE__ */ new Map();
	#nameMappingInitialized = false;
	#parseCache = /* @__PURE__ */ new Map();
	/**
	* Ensure the name mapping is initialized (lazy initialization)
	*/
	#ensureNameMapping() {
		if (this.#nameMappingInitialized) return;
		const { oas, contentType, include } = this.context;
		const { nameMapping } = oas.getSchemas({
			contentType,
			includes: include
		});
		this.#schemaNameMapping = nameMapping;
		this.#nameMappingInitialized = true;
	}
	/**
	* Creates a type node from a given schema.
	* Delegates to getBaseTypeFromSchema internally and
	* optionally adds a union with null.
	*/
	parse(props) {
		const options = this.#getOptions(props.name);
		const shouldCache = props.schema && typeof props.schema === "object" && !options.transformers?.schema;
		let cacheKey = "";
		if (shouldCache) try {
			cacheKey = JSON.stringify({
				schema: props.schema,
				name: props.name,
				parentName: props.parentName,
				rootName: props.rootName
			});
			const cached = this.#parseCache.get(cacheKey);
			if (cached) return cached;
		} catch {}
		const defaultSchemas = this.#parseSchemaObject(props);
		const result = uniqueWith(options.transformers?.schema?.(props, defaultSchemas) || defaultSchemas || [], isDeepEqual);
		if (shouldCache && cacheKey) this.#parseCache.set(cacheKey, result);
		return result;
	}
	static deepSearch(tree, keyword) {
		const foundItems = [];
		tree?.forEach((schema) => {
			if (schema.keyword === keyword) foundItems.push(schema);
			if (isKeyword(schema, schemaKeywords.object)) {
				Object.values(schema.args?.properties || {}).forEach((entrySchema) => {
					foundItems.push(...SchemaGenerator.deepSearch(entrySchema, keyword));
				});
				Object.values(schema.args?.additionalProperties || {}).forEach((entrySchema) => {
					foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
				});
				if (schema.args?.patternProperties) Object.values(schema.args.patternProperties).forEach((entrySchemas) => {
					entrySchemas.forEach((entrySchema) => {
						foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
					});
				});
			}
			if (isKeyword(schema, schemaKeywords.array)) schema.args.items.forEach((entrySchema) => {
				foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
			});
			if (isKeyword(schema, schemaKeywords.and)) schema.args.forEach((entrySchema) => {
				foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
			});
			if (isKeyword(schema, schemaKeywords.tuple)) schema.args.items.forEach((entrySchema) => {
				foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
			});
			if (isKeyword(schema, schemaKeywords.union)) schema.args.forEach((entrySchema) => {
				foundItems.push(...SchemaGenerator.deepSearch([entrySchema], keyword));
			});
		});
		return foundItems;
	}
	static find(tree, keyword) {
		let foundItem;
		tree?.forEach((schema) => {
			if (!foundItem && schema.keyword === keyword) foundItem = schema;
			if (isKeyword(schema, schemaKeywords.array)) schema.args.items.forEach((entrySchema) => {
				if (!foundItem) foundItem = SchemaGenerator.find([entrySchema], keyword);
			});
			if (isKeyword(schema, schemaKeywords.and)) schema.args.forEach((entrySchema) => {
				if (!foundItem) foundItem = SchemaGenerator.find([entrySchema], keyword);
			});
			if (isKeyword(schema, schemaKeywords.tuple)) schema.args.items.forEach((entrySchema) => {
				if (!foundItem) foundItem = SchemaGenerator.find([entrySchema], keyword);
			});
			if (isKeyword(schema, schemaKeywords.union)) schema.args.forEach((entrySchema) => {
				if (!foundItem) foundItem = SchemaGenerator.find([entrySchema], keyword);
			});
		});
		return foundItem;
	}
	static combineObjects(tree) {
		if (!tree) return [];
		return tree.map((schema) => {
			if (!isKeyword(schema, schemaKeywords.and)) return schema;
			let mergedProperties = null;
			let mergedAdditionalProps = [];
			const newArgs = [];
			for (const subSchema of schema.args) if (isKeyword(subSchema, schemaKeywords.object)) {
				const { properties = {}, additionalProperties = [] } = subSchema.args ?? {};
				if (!mergedProperties) mergedProperties = {};
				for (const [key, value] of Object.entries(properties)) mergedProperties[key] = value;
				if (additionalProperties.length > 0) mergedAdditionalProps = additionalProperties;
			} else newArgs.push(subSchema);
			if (mergedProperties) newArgs.push({
				keyword: schemaKeywords.object,
				args: {
					properties: mergedProperties,
					additionalProperties: mergedAdditionalProps
				}
			});
			return {
				keyword: schemaKeywords.and,
				args: newArgs
			};
		});
	}
	#getOptions(name) {
		const { override = [] } = this.context;
		return {
			...this.options,
			...override.find(({ pattern, type }) => {
				if (name && type === "schemaName") return !!name.match(pattern);
				return false;
			})?.options || {}
		};
	}
	#getUnknownType(name) {
		const options = this.#getOptions(name);
		if (options.unknownType === "any") return schemaKeywords.any;
		if (options.unknownType === "void") return schemaKeywords.void;
		return schemaKeywords.unknown;
	}
	#getEmptyType(name) {
		const options = this.#getOptions(name);
		if (options.emptySchemaType === "any") return schemaKeywords.any;
		if (options.emptySchemaType === "void") return schemaKeywords.void;
		return schemaKeywords.unknown;
	}
	/**
	* Recursively creates a type literal with the given props.
	*/
	#parseProperties(name, schemaObject, rootName) {
		const properties = schemaObject?.properties || {};
		const additionalProperties = schemaObject?.additionalProperties;
		const required = schemaObject?.required;
		const patternProperties = schemaObject && "patternProperties" in schemaObject ? schemaObject.patternProperties : void 0;
		const propertiesSchemas = Object.keys(properties).map((propertyName) => {
			const validationFunctions = [];
			const propertySchema = properties[propertyName];
			const isRequired = Array.isArray(required) ? required?.includes(propertyName) : !!required;
			const nullable = isNullable(propertySchema);
			validationFunctions.push(...this.parse({
				schema: propertySchema,
				name: propertyName,
				parentName: name,
				rootName: rootName || name
			}));
			validationFunctions.push({
				keyword: schemaKeywords.name,
				args: propertyName
			});
			if (!isRequired && nullable) validationFunctions.push({ keyword: schemaKeywords.nullish });
			else if (!isRequired) validationFunctions.push({ keyword: schemaKeywords.optional });
			return { [propertyName]: validationFunctions };
		}).reduce((acc, curr) => ({
			...acc,
			...curr
		}), {});
		let additionalPropertiesSchemas = [];
		if (additionalProperties) additionalPropertiesSchemas = additionalProperties === true || !Object.keys(additionalProperties).length ? [{ keyword: this.#getUnknownType(name) }] : this.parse({
			schema: additionalProperties,
			name: null,
			parentName: name,
			rootName: rootName || name
		});
		let patternPropertiesSchemas = {};
		if (patternProperties && typeof patternProperties === "object") patternPropertiesSchemas = Object.entries(patternProperties).reduce((acc, [pattern, patternSchema]) => {
			const schemas = patternSchema === true || !Object.keys(patternSchema).length ? [{ keyword: this.#getUnknownType(name) }] : this.parse({
				schema: patternSchema,
				name: null,
				parentName: name,
				rootName: rootName || name
			});
			return {
				...acc,
				[pattern]: schemas
			};
		}, {});
		const args = {
			properties: propertiesSchemas,
			additionalProperties: additionalPropertiesSchemas
		};
		if (Object.keys(patternPropertiesSchemas).length > 0) args["patternProperties"] = patternPropertiesSchemas;
		return [{
			keyword: schemaKeywords.object,
			args
		}];
	}
	/**
	* Create a type alias for the schema referenced by the given ReferenceObject
	*/
	#getRefAlias(schemaObject, name) {
		const { $ref } = schemaObject;
		const ref = this.refs[$ref];
		if (ref) {
			const dereferencedSchema = this.context.oas.dereferenceWithRef(schemaObject);
			if (dereferencedSchema && isDiscriminator(dereferencedSchema)) {
				const [key] = Object.entries(dereferencedSchema.discriminator.mapping || {}).find(([_key, value]) => value.replace(/.+\//, "") === name) || [];
				if (key) return [{
					keyword: schemaKeywords.and,
					args: [{
						keyword: schemaKeywords.ref,
						args: {
							name: ref.propertyName,
							$ref,
							path: ref.path,
							isImportable: !!this.context.oas.get($ref)
						}
					}, {
						keyword: schemaKeywords.object,
						args: { properties: { [dereferencedSchema.discriminator.propertyName]: [{
							keyword: schemaKeywords.const,
							args: {
								name: key,
								format: "string",
								value: key
							}
						}] } }
					}]
				}];
			}
			return [{
				keyword: schemaKeywords.ref,
				args: {
					name: ref.propertyName,
					$ref,
					path: ref.path,
					isImportable: !!this.context.oas.get($ref)
				}
			}];
		}
		this.#ensureNameMapping();
		const originalName = $ref.replace(/.+\//, "");
		const resolvedName = this.#schemaNameMapping.get($ref) || originalName;
		const propertyName = this.context.pluginManager.resolveName({
			name: resolvedName,
			pluginKey: this.context.plugin.key,
			type: "function"
		});
		const fileName = this.context.pluginManager.resolveName({
			name: resolvedName,
			pluginKey: this.context.plugin.key,
			type: "file"
		});
		const file = this.context.pluginManager.getFile({
			name: fileName,
			pluginKey: this.context.plugin.key,
			extname: ".ts"
		});
		this.refs[$ref] = {
			propertyName,
			originalName: resolvedName,
			path: file.path
		};
		return this.#getRefAlias(schemaObject, name);
	}
	#getParsedSchemaObject(schema) {
		return getSchemaFactory(this.context.oas)(schema);
	}
	#addDiscriminatorToSchema({ schema, schemaObject, discriminator }) {
		if (!isKeyword(schema, schemaKeywords.union)) return schema;
		if (discriminator.propertyName.startsWith("x-")) return schema;
		const objectPropertySchema = SchemaGenerator.find(this.parse({
			schema: schemaObject,
			name: null,
			parentName: null,
			rootName: null
		}), schemaKeywords.object);
		return {
			...schema,
			args: Object.entries(discriminator.mapping || {}).map(([key, value]) => {
				let arg;
				if (value.startsWith("#kubb-inline-")) {
					const index = Number.parseInt(value.replace("#kubb-inline-", ""), 10);
					if (!Number.isNaN(index) && index >= 0 && index < schema.args.length) arg = schema.args[index];
				} else arg = schema.args.find((item) => isKeyword(item, schemaKeywords.ref) && item.args.$ref === value);
				if (!arg) return;
				return {
					keyword: schemaKeywords.and,
					args: [arg, {
						keyword: schemaKeywords.object,
						args: { properties: {
							...objectPropertySchema?.args?.properties || {},
							[discriminator.propertyName]: [{
								keyword: schemaKeywords.const,
								args: {
									name: key,
									format: "string",
									value: key
								}
							}, ...objectPropertySchema?.args?.properties[discriminator.propertyName] || []].filter((item) => !isKeyword(item, schemaKeywords.enum))
						} }
					}]
				};
			}).filter(Boolean)
		};
	}
	/**
	* Checks if an allOf item reference would create a circular reference.
	* This happens when a child schema extends a discriminator parent via allOf,
	* and the parent has a oneOf/anyOf that references or maps to the child.
	*
	* Without oneOf/anyOf, the discriminator is just for documentation/validation
	* purposes and doesn't create a TypeScript union type that would be circular.
	*/
	#wouldCreateCircularReference(item, childSchemaName) {
		if (!isReference(item) || !childSchemaName) return false;
		const dereferencedSchema = this.context.oas.dereferenceWithRef(item);
		if (dereferencedSchema && isDiscriminator(dereferencedSchema)) {
			const parentOneOf = dereferencedSchema.oneOf || dereferencedSchema.anyOf;
			if (!parentOneOf) return false;
			const childRef = `#/components/schemas/${childSchemaName}`;
			if (parentOneOf.some((oneOfItem) => {
				return isReference(oneOfItem) && oneOfItem.$ref === childRef;
			})) return true;
			const mapping = dereferencedSchema.discriminator.mapping || {};
			if (Object.values(mapping).some((value) => value === childRef)) return true;
		}
		return false;
	}
	/**
	* This is the very core of the OpenAPI to TS conversion - it takes a
	* schema and returns the appropriate type.
	*/
	#parseSchemaObject({ schema: _schemaObject, name, parentName, rootName }) {
		const normalizedSchema = this.context.oas.flattenSchema(_schemaObject);
		const { schemaObject, version } = this.#getParsedSchemaObject(normalizedSchema);
		const options = this.#getOptions(name);
		const emptyType = this.#getEmptyType(name);
		if (!schemaObject) return [{ keyword: emptyType }];
		const baseItems = [{
			keyword: schemaKeywords.schema,
			args: {
				type: schemaObject.type,
				format: schemaObject.format
			}
		}];
		const min = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? void 0;
		const max = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? void 0;
		const exclusiveMinimum = schemaObject.exclusiveMinimum;
		const exclusiveMaximum = schemaObject.exclusiveMaximum;
		const nullable = isNullable(schemaObject);
		const defaultNullAndNullable = schemaObject.default === null && nullable;
		if (schemaObject.default !== void 0 && !defaultNullAndNullable && !Array.isArray(schemaObject.default)) if (typeof schemaObject.default === "string") baseItems.push({
			keyword: schemaKeywords.default,
			args: transformers.stringify(schemaObject.default)
		});
		else if (typeof schemaObject.default === "boolean") baseItems.push({
			keyword: schemaKeywords.default,
			args: schemaObject.default ?? false
		});
		else baseItems.push({
			keyword: schemaKeywords.default,
			args: schemaObject.default
		});
		if (schemaObject.deprecated) baseItems.push({ keyword: schemaKeywords.deprecated });
		if (schemaObject.description) baseItems.push({
			keyword: schemaKeywords.describe,
			args: schemaObject.description
		});
		if (max !== void 0) if (exclusiveMaximum) baseItems.unshift({
			keyword: schemaKeywords.exclusiveMaximum,
			args: max
		});
		else baseItems.unshift({
			keyword: schemaKeywords.max,
			args: max
		});
		if (min !== void 0) if (exclusiveMinimum) baseItems.unshift({
			keyword: schemaKeywords.exclusiveMinimum,
			args: min
		});
		else baseItems.unshift({
			keyword: schemaKeywords.min,
			args: min
		});
		if (typeof exclusiveMaximum === "number") baseItems.unshift({
			keyword: schemaKeywords.exclusiveMaximum,
			args: exclusiveMaximum
		});
		if (typeof exclusiveMinimum === "number") baseItems.unshift({
			keyword: schemaKeywords.exclusiveMinimum,
			args: exclusiveMinimum
		});
		if (nullable) baseItems.push({ keyword: schemaKeywords.nullable });
		if (schemaObject.type && Array.isArray(schemaObject.type)) {
			const items = schemaObject.type.filter((value) => value !== "null");
			if (items.length > 1) return [...[{
				keyword: schemaKeywords.union,
				args: items.map((item) => this.parse({
					schema: {
						...schemaObject,
						type: item
					},
					name,
					parentName,
					rootName
				})[0]).filter(Boolean).map((item) => isKeyword(item, schemaKeywords.object) ? {
					...item,
					args: {
						...item.args,
						strict: true
					}
				} : item)
			}], ...baseItems].filter(Boolean);
		}
		if (schemaObject.readOnly) baseItems.push({ keyword: schemaKeywords.readOnly });
		if (schemaObject.writeOnly) baseItems.push({ keyword: schemaKeywords.writeOnly });
		if (isReference(schemaObject)) return [
			...this.#getRefAlias(schemaObject, name),
			schemaObject.description && {
				keyword: schemaKeywords.describe,
				args: schemaObject.description
			},
			schemaObject.pattern && schemaObject.type === "string" && {
				keyword: schemaKeywords.matches,
				args: schemaObject.pattern
			},
			nullable && { keyword: schemaKeywords.nullable },
			schemaObject.readOnly && { keyword: schemaKeywords.readOnly },
			schemaObject.writeOnly && { keyword: schemaKeywords.writeOnly },
			{
				keyword: schemaKeywords.schema,
				args: {
					type: schemaObject.type,
					format: schemaObject.format
				}
			}
		].filter(Boolean);
		if (schemaObject.oneOf || schemaObject.anyOf) {
			const schemaWithoutOneOf = {
				...schemaObject,
				oneOf: void 0,
				anyOf: void 0
			};
			const discriminator = this.context.oas.getDiscriminator(schemaObject);
			const union = {
				keyword: schemaKeywords.union,
				args: (schemaObject.oneOf || schemaObject.anyOf).map((item) => {
					return item && this.parse({
						schema: item,
						name,
						parentName,
						rootName
					})[0];
				}).filter(Boolean)
			};
			if (discriminator) {
				if (this.context && this.context.oas.options.discriminator !== "inherit") return [this.#addDiscriminatorToSchema({
					schemaObject: schemaWithoutOneOf,
					schema: union,
					discriminator
				}), ...baseItems];
			}
			if (schemaWithoutOneOf.properties) {
				const propertySchemas = this.parse({
					schema: schemaWithoutOneOf,
					name,
					parentName,
					rootName
				});
				union.args = [...union.args.map((arg) => {
					return {
						keyword: schemaKeywords.and,
						args: [arg, ...propertySchemas]
					};
				})];
				return [union, ...baseItems];
			}
			return [union, ...baseItems];
		}
		if (schemaObject.allOf) {
			const schemaWithoutAllOf = {
				...schemaObject,
				allOf: void 0
			};
			const and = {
				keyword: schemaKeywords.and,
				args: schemaObject.allOf.flatMap((item) => {
					if (this.#wouldCreateCircularReference(item, name)) return [];
					return item ? this.parse({
						schema: item,
						name,
						parentName,
						rootName
					}) : [];
				}).filter(Boolean)
			};
			if (schemaWithoutAllOf.required?.length) {
				const allOfItems = schemaObject.allOf;
				const resolvedSchemas = [];
				for (const item of allOfItems) {
					const resolved = isReference(item) ? this.context.oas.get(item.$ref) : item;
					if (resolved) resolvedSchemas.push(resolved);
				}
				const existingKeys = schemaWithoutAllOf.properties ? new Set(Object.keys(schemaWithoutAllOf.properties)) : null;
				const parsedItems = [];
				for (const key of schemaWithoutAllOf.required) {
					if (existingKeys?.has(key)) continue;
					for (const schema of resolvedSchemas) if (schema.properties?.[key]) {
						parsedItems.push({
							properties: { [key]: schema.properties[key] },
							required: [key]
						});
						break;
					}
				}
				for (const item of parsedItems) {
					const parsed = this.parse({
						schema: item,
						name,
						parentName,
						rootName
					});
					if (Array.isArray(parsed)) and.args = and.args ? and.args.concat(parsed) : parsed;
				}
			}
			if (schemaWithoutAllOf.properties) and.args = [...and.args || [], ...this.parse({
				schema: schemaWithoutAllOf,
				name,
				parentName,
				rootName
			})];
			return SchemaGenerator.combineObjects([and, ...baseItems]);
		}
		if (schemaObject.enum) {
			if (schemaObject.type === "array") {
				const normalizedItems = {
					...typeof schemaObject.items === "object" && !Array.isArray(schemaObject.items) ? schemaObject.items : {},
					enum: schemaObject.enum
				};
				const { enum: _, ...schemaWithoutEnum } = schemaObject;
				const normalizedSchema$1 = {
					...schemaWithoutEnum,
					items: normalizedItems
				};
				return this.parse({
					schema: normalizedSchema$1,
					name,
					parentName,
					rootName
				});
			}
			const useCollisionDetection = this.context.oas.options.collisionDetection ?? false;
			const enumNameParts = useCollisionDetection && rootName && rootName !== parentName ? [
				rootName,
				parentName,
				name,
				options.enumSuffix
			] : [
				parentName,
				name,
				options.enumSuffix
			];
			const enumName = useCollisionDetection ? pascalCase(enumNameParts.join(" ")) : getUniqueName(pascalCase(enumNameParts.join(" ")), this.options.usedEnumNames || {});
			const typeName = this.context.pluginManager.resolveName({
				name: enumName,
				pluginKey: this.context.plugin.key,
				type: "type"
			});
			if (schemaObject.enum.includes(null)) baseItems.push({ keyword: schemaKeywords.nullable });
			const filteredValues = schemaObject.enum.filter((value) => value !== null);
			const extensionEnums = ["x-enumNames", "x-enum-varnames"].filter((extensionKey) => extensionKey in schemaObject).map((extensionKey) => {
				return [{
					keyword: schemaKeywords.enum,
					args: {
						name,
						typeName,
						asConst: false,
						items: [...new Set(schemaObject[extensionKey])].map((name$1, index) => ({
							name: transformers.stringify(name$1),
							value: schemaObject.enum?.[index],
							format: isNumber(schemaObject.enum?.[index]) ? "number" : "string"
						}))
					}
				}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches)];
			});
			if (schemaObject.type === "number" || schemaObject.type === "integer") {
				const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum));
				return [{
					keyword: schemaKeywords.enum,
					args: {
						name: enumName,
						typeName,
						asConst: true,
						items: enumNames?.args?.items ? [...new Set(enumNames.args.items)].map(({ name: name$1, value }) => ({
							name: name$1,
							value,
							format: "number"
						})) : [...new Set(filteredValues)].map((value) => {
							return {
								name: value,
								value,
								format: "number"
							};
						})
					}
				}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches)];
			}
			if (schemaObject.type === "boolean") {
				const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum));
				return [{
					keyword: schemaKeywords.enum,
					args: {
						name: enumName,
						typeName,
						asConst: true,
						items: enumNames?.args?.items ? [...new Set(enumNames.args.items)].map(({ name: name$1, value }) => ({
							name: name$1,
							value,
							format: "boolean"
						})) : [...new Set(filteredValues)].map((value) => {
							return {
								name: value,
								value,
								format: "boolean"
							};
						})
					}
				}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.matches)];
			}
			if (extensionEnums.length > 0 && extensionEnums[0]) return extensionEnums[0];
			return [{
				keyword: schemaKeywords.enum,
				args: {
					name: enumName,
					typeName,
					asConst: false,
					items: [...new Set(filteredValues)].map((value) => ({
						name: transformers.stringify(value),
						value,
						format: isNumber(value) ? "number" : "string"
					}))
				}
			}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches)];
		}
		if ("prefixItems" in schemaObject) {
			const prefixItems = schemaObject.prefixItems;
			const items = "items" in schemaObject ? schemaObject.items : [];
			const min$1 = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? void 0;
			const max$1 = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? void 0;
			return [{
				keyword: schemaKeywords.tuple,
				args: {
					min: min$1,
					max: max$1,
					items: prefixItems.map((item) => {
						return this.parse({
							schema: item,
							name,
							parentName,
							rootName
						})[0];
					}).filter(Boolean),
					rest: this.parse({
						schema: items,
						name,
						parentName,
						rootName
					})[0]
				}
			}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max)];
		}
		if (version === "3.1" && "const" in schemaObject) {
			if (schemaObject["const"] === null) return [{ keyword: schemaKeywords.null }];
			if (schemaObject["const"] === void 0) return [{ keyword: schemaKeywords.undefined }];
			let format = typeof schemaObject["const"];
			if (format !== "number" && format !== "boolean") format = "string";
			return [{
				keyword: schemaKeywords.const,
				args: {
					name: schemaObject["const"],
					format,
					value: schemaObject["const"]
				}
			}, ...baseItems];
		}
		/**
		* > Structural validation alone may be insufficient to allow an application to correctly utilize certain values. The "format"
		* > annotation keyword is defined to allow schema authors to convey semantic information for a fixed subset of values which are
		* > accurately described by authoritative resources, be they RFCs or other external specifications.
		*
		* In other words: format is more specific than type alone, hence it should override the type value, if possible.
		*
		* see also https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-00#rfc.section.7
		*/
		if (schemaObject.format) {
			if (schemaObject.type === "integer" && (schemaObject.format === "int32" || schemaObject.format === "int64")) {
				baseItems.unshift({ keyword: schemaKeywords.integer });
				return baseItems;
			}
			if (schemaObject.type === "number" && (schemaObject.format === "float" || schemaObject.format === "double")) {
				baseItems.unshift({ keyword: schemaKeywords.number });
				return baseItems;
			}
			switch (schemaObject.format) {
				case "binary":
					baseItems.push({ keyword: schemaKeywords.blob });
					return baseItems;
				case "date-time":
					if (options.dateType) {
						if (options.dateType === "date") {
							baseItems.unshift({
								keyword: schemaKeywords.date,
								args: { type: "date" }
							});
							return baseItems;
						}
						if (options.dateType === "stringOffset") {
							baseItems.unshift({
								keyword: schemaKeywords.datetime,
								args: { offset: true }
							});
							return baseItems;
						}
						if (options.dateType === "stringLocal") {
							baseItems.unshift({
								keyword: schemaKeywords.datetime,
								args: { local: true }
							});
							return baseItems;
						}
						baseItems.unshift({
							keyword: schemaKeywords.datetime,
							args: { offset: false }
						});
						return baseItems;
					}
					break;
				case "date":
					if (options.dateType) {
						if (options.dateType === "date") {
							baseItems.unshift({
								keyword: schemaKeywords.date,
								args: { type: "date" }
							});
							return baseItems;
						}
						baseItems.unshift({
							keyword: schemaKeywords.date,
							args: { type: "string" }
						});
						return baseItems;
					}
					break;
				case "time":
					if (options.dateType) {
						if (options.dateType === "date") {
							baseItems.unshift({
								keyword: schemaKeywords.time,
								args: { type: "date" }
							});
							return baseItems;
						}
						baseItems.unshift({
							keyword: schemaKeywords.time,
							args: { type: "string" }
						});
						return baseItems;
					}
					break;
				case "uuid":
					baseItems.unshift({ keyword: schemaKeywords.uuid });
					return baseItems;
				case "email":
				case "idn-email":
					baseItems.unshift({ keyword: schemaKeywords.email });
					return baseItems;
				case "uri":
				case "ipv4":
				case "ipv6":
				case "uri-reference":
				case "hostname":
				case "idn-hostname":
					baseItems.unshift({ keyword: schemaKeywords.url });
					return baseItems;
				default: break;
			}
		}
		if (schemaObject.pattern && schemaObject.type === "string") {
			baseItems.unshift({
				keyword: schemaKeywords.matches,
				args: schemaObject.pattern
			});
			return baseItems;
		}
		if ("items" in schemaObject || schemaObject.type === "array") {
			const min$1 = schemaObject.minimum ?? schemaObject.minLength ?? schemaObject.minItems ?? void 0;
			const max$1 = schemaObject.maximum ?? schemaObject.maxLength ?? schemaObject.maxItems ?? void 0;
			const items = this.parse({
				schema: "items" in schemaObject ? schemaObject.items : [],
				name,
				parentName,
				rootName
			});
			const unique = !!schemaObject.uniqueItems;
			return [{
				keyword: schemaKeywords.array,
				args: {
					items,
					min: min$1,
					max: max$1,
					unique
				}
			}, ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max)];
		}
		if (schemaObject.properties || schemaObject.additionalProperties || "patternProperties" in schemaObject) {
			if (isDiscriminator(schemaObject)) {
				const schemaObjectOverridden = Object.keys(schemaObject.properties || {}).reduce((acc, propertyName) => {
					if (acc.properties?.[propertyName] && propertyName === schemaObject.discriminator.propertyName) return {
						...acc,
						properties: {
							...acc.properties,
							[propertyName]: {
								...acc.properties[propertyName] || {},
								enum: schemaObject.discriminator.mapping ? Object.keys(schemaObject.discriminator.mapping) : void 0
							}
						}
					};
					return acc;
				}, schemaObject || {});
				return [...this.#parseProperties(name, schemaObjectOverridden, rootName), ...baseItems];
			}
			return [...this.#parseProperties(name, schemaObject, rootName), ...baseItems];
		}
		if (schemaObject.type) {
			const type = Array.isArray(schemaObject.type) ? schemaObject.type.filter((item) => item !== "null")[0] : schemaObject.type;
			if (![
				"boolean",
				"object",
				"number",
				"string",
				"integer",
				"null"
			].includes(type)) this.context.events?.emit("warn", `Schema type '${schemaObject.type}' is not valid for schema ${parentName}.${name}`);
			return [{ keyword: type }, ...baseItems];
		}
		let inferredType;
		if (schemaObject.minLength !== void 0 || schemaObject.maxLength !== void 0 || schemaObject.pattern !== void 0) inferredType = "string";
		else if (schemaObject.minimum !== void 0 || schemaObject.maximum !== void 0) inferredType = "number";
		if (inferredType) return [{ keyword: inferredType }, ...baseItems];
		return [{ keyword: emptyType }, ...baseItems];
	}
	async build(...generators) {
		const { oas, contentType, include } = this.context;
		if (!this.#nameMappingInitialized) {
			const { schemas: schemas$1, nameMapping } = oas.getSchemas({
				contentType,
				includes: include
			});
			this.#schemaNameMapping = nameMapping;
			this.#nameMappingInitialized = true;
			const schemaEntries = Object.entries(schemas$1);
			this.context.events?.emit("debug", {
				date: /* @__PURE__ */ new Date(),
				logs: [
					`Building ${schemaEntries.length} schemas`,
					`  • Content Type: ${contentType || "application/json"}`,
					`  • Generators: ${generators.length}`
				]
			});
			return this.#doBuild(schemas$1, generators);
		}
		const { schemas } = oas.getSchemas({
			contentType,
			includes: include
		});
		return this.#doBuild(schemas, generators);
	}
	async #doBuild(schemas, generators) {
		const schemaEntries = Object.entries(schemas);
		const generatorLimit = pLimit(3);
		const schemaLimit = pLimit(30);
		const writeTasks = generators.map((generator) => generatorLimit(async () => {
			const schemaTasks = schemaEntries.map(([name, schemaObject]) => schemaLimit(async () => {
				const options = this.#getOptions(name);
				const tree = this.parse({
					schema: schemaObject,
					name,
					parentName: null,
					rootName: name
				});
				if (generator.type === "react") {
					await buildSchema({
						name,
						value: schemaObject,
						tree
					}, {
						config: this.context.pluginManager.config,
						fabric: this.context.fabric,
						Component: generator.Schema,
						generator: this,
						plugin: {
							...this.context.plugin,
							options: {
								...this.options,
								...options
							}
						}
					});
					return [];
				}
				return await generator.schema?.({
					config: this.context.pluginManager.config,
					generator: this,
					schema: {
						name,
						value: schemaObject,
						tree
					},
					plugin: {
						...this.context.plugin,
						options: {
							...this.options,
							...options
						}
					}
				}) ?? [];
			}));
			return (await Promise.all(schemaTasks)).flat();
		}));
		return (await Promise.all(writeTasks)).flat();
	}
};

//#endregion
export { pLimit as a, buildSchema as i, buildOperation as n, buildOperations as r, SchemaGenerator as t };
//# sourceMappingURL=SchemaGenerator-CK_Mv0RW.js.map