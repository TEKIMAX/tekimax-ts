{"version":3,"file":"SchemaMapper-D-GETHNf.js","names":[],"sources":["../src/SchemaMapper.ts"],"sourcesContent":["import type { KubbFile } from '@kubb/fabric-core/types'\nimport type { SchemaObject } from '@kubb/oas'\n\nexport type SchemaKeywordMapper = {\n  object: {\n    keyword: 'object'\n    args: {\n      properties: { [x: string]: Schema[] }\n      additionalProperties: Schema[]\n      patternProperties?: Record<string, Schema[]>\n      strict?: boolean\n    }\n  }\n  url: { keyword: 'url' }\n  readOnly: { keyword: 'readOnly' }\n  writeOnly: { keyword: 'writeOnly' }\n  uuid: { keyword: 'uuid' }\n  email: { keyword: 'email' }\n  firstName: { keyword: 'firstName' }\n  lastName: { keyword: 'lastName' }\n  phone: { keyword: 'phone' }\n  password: { keyword: 'password' }\n  date: { keyword: 'date'; args: { type?: 'date' | 'string' } }\n  time: { keyword: 'time'; args: { type?: 'date' | 'string' } }\n  datetime: { keyword: 'datetime'; args: { offset?: boolean; local?: boolean } }\n  tuple: { keyword: 'tuple'; args: { items: Schema[]; min?: number; max?: number; rest?: Schema } }\n  array: {\n    keyword: 'array'\n    args: { items: Schema[]; min?: number; max?: number; unique?: boolean }\n  }\n  enum: {\n    keyword: 'enum'\n    args: {\n      name: string\n      typeName: string\n      asConst: boolean\n      items: Array<{\n        name: string | number\n        format: 'string' | 'number' | 'boolean'\n        value?: string | number | boolean\n      }>\n    }\n  }\n  and: { keyword: 'and'; args: Schema[] }\n  const: {\n    keyword: 'const'\n    args: {\n      name: string | number\n      format: 'string' | 'number' | 'boolean'\n      value?: string | number | boolean\n    }\n  }\n  union: { keyword: 'union'; args: Schema[] }\n  ref: {\n    keyword: 'ref'\n    args: {\n      name: string\n      $ref: string\n      /**\n       * Full qualified path.\n       */\n      path: KubbFile.Path\n      /**\n       * When true `File.Import` is used.\n       * When false a reference is used inside the current file.\n       */\n      isImportable: boolean\n    }\n  }\n  matches: { keyword: 'matches'; args?: string }\n  boolean: { keyword: 'boolean' }\n  default: { keyword: 'default'; args: string | number | boolean }\n  string: { keyword: 'string' }\n  integer: { keyword: 'integer' }\n  number: { keyword: 'number' }\n  max: { keyword: 'max'; args: number }\n  min: { keyword: 'min'; args: number }\n  exclusiveMaximum: { keyword: 'exclusiveMaximum'; args: number }\n  exclusiveMinimum: { keyword: 'exclusiveMinimum'; args: number }\n  describe: { keyword: 'describe'; args: string }\n  example: { keyword: 'example'; args: string }\n  deprecated: { keyword: 'deprecated' }\n  optional: { keyword: 'optional' }\n  undefined: { keyword: 'undefined' }\n  nullish: { keyword: 'nullish' }\n  nullable: { keyword: 'nullable' }\n  null: { keyword: 'null' }\n  any: { keyword: 'any' }\n  unknown: { keyword: 'unknown' }\n  void: { keyword: 'void' }\n  blob: { keyword: 'blob' }\n  schema: { keyword: 'schema'; args: { type: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object'; format?: string } }\n  name: { keyword: 'name'; args: string }\n  catchall: { keyword: 'catchall' }\n  interface: { keyword: 'interface' }\n}\n\nexport const schemaKeywords = {\n  any: 'any',\n  unknown: 'unknown',\n  number: 'number',\n  integer: 'integer',\n  string: 'string',\n  boolean: 'boolean',\n  undefined: 'undefined',\n  nullable: 'nullable',\n  null: 'null',\n  nullish: 'nullish',\n  array: 'array',\n  tuple: 'tuple',\n  enum: 'enum',\n  union: 'union',\n  datetime: 'datetime',\n  date: 'date',\n  email: 'email',\n  uuid: 'uuid',\n  url: 'url',\n  void: 'void',\n  /* intersection */\n  default: 'default',\n  const: 'const',\n  and: 'and',\n  describe: 'describe',\n  min: 'min',\n  max: 'max',\n  exclusiveMinimum: 'exclusiveMinimum',\n  exclusiveMaximum: 'exclusiveMaximum',\n  optional: 'optional',\n  readOnly: 'readOnly',\n  writeOnly: 'writeOnly',\n\n  // custom ones\n  object: 'object',\n  ref: 'ref',\n  matches: 'matches',\n  firstName: 'firstName',\n  lastName: 'lastName',\n  password: 'password',\n  phone: 'phone',\n  blob: 'blob',\n  deprecated: 'deprecated',\n  example: 'example',\n  schema: 'schema',\n  catchall: 'catchall',\n  time: 'time',\n  name: 'name',\n  interface: 'interface',\n} satisfies {\n  [K in keyof SchemaKeywordMapper]: SchemaKeywordMapper[K]['keyword']\n}\n\nexport type SchemaKeyword = keyof SchemaKeywordMapper\n\nexport type SchemaMapper<T = string | null | undefined> = {\n  [K in keyof SchemaKeywordMapper]: (() => T | undefined) | undefined\n}\n\nexport type SchemaKeywordBase<T> = {\n  keyword: SchemaKeyword\n  args: T\n}\n\nexport type Schema = { keyword: string } | SchemaKeywordMapper[keyof SchemaKeywordMapper]\n\nexport type SchemaTree = {\n  schema: SchemaObject\n  parent: Schema | undefined\n  current: Schema\n  siblings: Schema[]\n  /**\n   * this is equal to the key of a property(object)\n   */\n  name?: string\n}\n\nexport function isKeyword<T extends Schema, K extends keyof SchemaKeywordMapper>(meta: T, keyword: K): meta is Extract<T, SchemaKeywordMapper[K]> {\n  return meta.keyword === keyword\n}\n"],"mappings":";;;AAiGA,MAAa,iBAAiB;CAC5B,KAAK;CACL,SAAS;CACT,QAAQ;CACR,SAAS;CACT,QAAQ;CACR,SAAS;CACT,WAAW;CACX,UAAU;CACV,MAAM;CACN,SAAS;CACT,OAAO;CACP,OAAO;CACP,MAAM;CACN,OAAO;CACP,UAAU;CACV,MAAM;CACN,OAAO;CACP,MAAM;CACN,KAAK;CACL,MAAM;CAEN,SAAS;CACT,OAAO;CACP,KAAK;CACL,UAAU;CACV,KAAK;CACL,KAAK;CACL,kBAAkB;CAClB,kBAAkB;CAClB,UAAU;CACV,UAAU;CACV,WAAW;CAGX,QAAQ;CACR,KAAK;CACL,SAAS;CACT,WAAW;CACX,UAAU;CACV,UAAU;CACV,OAAO;CACP,MAAM;CACN,YAAY;CACZ,SAAS;CACT,QAAQ;CACR,UAAU;CACV,MAAM;CACN,MAAM;CACN,WAAW;CACZ;AA4BD,SAAgB,UAAiE,MAAS,SAAwD;AAChJ,QAAO,KAAK,YAAY"}