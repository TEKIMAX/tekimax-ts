{"version":3,"file":"index.js","names":[],"sources":["../src/composables/useContext.ts","../src/composables/useNodeTree.ts","../src/contexts/AppContext.ts","../src/components/App.ts","../src/components/Br.ts","../src/utils/createJSDoc.ts","../src/components/Const.ts","../src/components/Dedent.ts","../src/contexts/FileContext.ts","../src/composables/useFile.ts","../src/composables/useFileManager.ts","../src/components/File.ts","../src/components/Indent.ts","../src/components/Function.ts","../src/components/Type.ts","../src/composables/useApp.ts","../src/composables/useLifecycle.ts","../src/createFabric.ts"],"sourcesContent":["import type { Context } from '../context.ts'\nimport { inject } from '../context.ts'\n\n/**\n * React-style alias for inject\n *\n * @example\n * ```ts\n * const theme = useContext(ThemeContext) // type is inferred from ThemeContext\n * ```\n */\nexport function useContext<T>(key: Context<T>): T\nexport function useContext<T, TValue = T>(key: Context<T>, defaultValue: TValue): NonNullable<T> | TValue\nexport function useContext<T>(key: Context<T>, defaultValue?: T): T {\n  return inject(key, defaultValue)\n}\n","import { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport type { TreeNode } from '../utils/TreeNode.ts'\nimport { useContext } from './useContext.ts'\n\nexport type ComponentNode = {\n  type: string\n  props: Record<string, unknown>\n}\n\n/**\n * Accesses the current node tree for tracking component hierarchy.\n *\n * Use this composable to inspect or manipulate the component tree structure.\n * Returns null if not within a component that provides NodeTreeContext.\n *\n * @returns The current TreeNode or null\n *\n * @example\n * ```ts\n * const nodeTree = useNodeTree()\n * if (nodeTree) {\n *   const childTree = nodeTree.addChild({ type: 'MyComponent', props: {} })\n * }\n * ```\n */\nexport function useNodeTree(): TreeNode<ComponentNode> | null {\n  return useContext(NodeTreeContext)\n}\n","import { createContext } from '../context.ts'\n\nexport type AppContextProps<TMeta extends object = object> = {\n  /**\n   * Exit (unmount)\n   */\n  exit: (error?: Error) => void\n  meta: TMeta\n}\n\n/**\n * Provides app-level metadata and lifecycle hooks (like `exit`) to\n * components and composables within a Fabric runtime.\n */\nexport const AppContext = createContext<AppContextProps>({\n  exit: () => {},\n  meta: {},\n})\n","import { useContext } from '../composables/useContext.ts'\nimport { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { AppContext } from '../contexts/AppContext.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { RootContext } from '../contexts/RootContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\n\nexport type AppProps<TMeta extends Object = Object> = {\n  /**\n   * Metadata attached to the App context.\n   *\n   * Use this to pass custom data to child components via useApp.\n   */\n  meta?: TMeta\n  /**\n   * Child components.\n   */\n  children?: FabricNode\n}\n\n/**\n * Container component providing App context with metadata and lifecycle.\n *\n * Use this component to wrap your application and provide shared metadata\n * that can be accessed by child components using the useApp composable.\n *\n * @example\n * ```tsx\n * <App meta={{ version: '1.0.0', author: 'John Doe' }}>\n *   <File baseName=\"user.ts\" path=\"./user.ts\">\n *     <File.Source>export type User = {}</File.Source>\n *   </File>\n * </App>\n * ```\n */\nexport const App = createComponent('App', ({ children, ...props }: AppProps) => {\n  const { meta = {} } = props\n\n  const { exit } = useContext(RootContext)\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'App', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  provide(AppContext, { exit, meta })\n\n  return children\n})\n\nApp.displayName = 'App'\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\n/**\n * Generates a line break in the output.\n *\n * Use this component to add newlines in generated code.\n *\n * @example\n * ```tsx\n * <>\n *   const x = 1\n *   <Br />\n *   const y = 2\n * </>\n * ```\n */\nexport const Br = createComponent('br', () => {\n  return createIntrinsic('br')\n})\n\nBr.displayName = 'Br'\n","/**\n * Create JSDoc comment block from comments array\n */\nexport function createJSDoc({ comments }: { comments: string[] }): string {\n  if (!comments || comments.length === 0) return ''\n\n  const lines = comments\n    .flatMap((c) => String(c ?? '').split(/\\r?\\n/))\n    .map((l) => l.replace(/\\*\\//g, '*\\\\/').replace(/\\r/g, ''))\n    .filter((l) => l.trim().length > 0)\n\n  if (lines.length === 0) return ''\n\n  return ['/**', ...lines.map((l) => ` * ${l}`), ' */'].join('\\n')\n}\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport { renderIntrinsic } from '../intrinsic.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type ConstProps = {\n  /**\n   * Name of the constant.\n   */\n  name: string\n  /**\n   * Export this constant.\n   * - `true` generates `export const`\n   * - `false` generates internal const\n   * @default false\n   */\n  export?: boolean\n  /**\n   * TypeScript type annotation.\n   *\n   * @example 'string' or 'User[]'\n   */\n  type?: string\n  /**\n   * JSDoc comments for the constant.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Use const assertion.\n   * - `true` adds `as const` for deep readonly\n   * - `false` uses inferred or explicit type\n   * @default false\n   */\n  asConst?: boolean\n  /**\n   * Constant value.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript constant declaration.\n *\n * @example\n * ```tsx\n * <Const name=\"API_URL\" export type=\"string\">\n *   'https://api.example.com'\n * </Const>\n * ```\n */\nexport const Const = createComponent('Const', ({ children, ...props }: ConstProps) => {\n  const { name, export: canExport, type, JSDoc, asConst } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Const', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const value = renderIntrinsic(children)\n\n  let result = ''\n\n  if (JSDoc?.comments) {\n    result += createJSDoc({ comments: JSDoc.comments })\n    result += '\\n'\n  }\n\n  if (canExport) {\n    result += 'export '\n  }\n\n  result += `const ${name}`\n\n  if (type) {\n    result += `: ${type}`\n  }\n\n  result += ` = ${children ? value : ''}`\n\n  if (asConst) {\n    result += ' as const'\n  }\n\n  return result\n})\n\nConst.displayName = 'Const'\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\n/**\n * Decreases indentation level in the output.\n *\n * Use this component to reduce indentation after an indented code block.\n * Typically paired with Indent to control indentation levels.\n *\n * @example\n * ```tsx\n * <>\n *   function example() {'{'}<Br />\n *   <Indent />\n *     return true<Br />\n *   <Dedent />\n *   {'}'}\n * </>\n * ```\n */\nexport const Dedent = createComponent('dedent', () => {\n  return createIntrinsic('dedent')\n})\nDedent.displayName = 'Dedent'\n","import { createContext } from '../context.ts'\nimport type * as KubbFile from '../KubbFile.ts'\n\n/**\n * Provides app-level metadata and lifecycle hooks (like `exit`) to\n * components and composables within a Fabric runtime.\n */\nexport const FileContext = createContext<KubbFile.ResolvedFile | null>(null)\n","import { FileContext } from '../contexts/FileContext.ts'\nimport type * as KubbFile from '../KubbFile.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * Accesses the current File context.\n *\n * Use this composable to access or modify the current file's properties,\n * sources, imports, or exports.\n *\n * @returns The current file object or null if not within a File component\n *\n * @example\n * ```ts\n * const file = useFile()\n * if (file) {\n *   console.log(file.path)\n *   file.sources.push({ value: 'export const x = 1', isExportable: true })\n * }\n * ```\n */\nexport function useFile(): KubbFile.ResolvedFile | null {\n  return useContext(FileContext)\n}\n","import { RootContext } from '../contexts/RootContext.ts'\nimport type { FileManager } from '../FileManager.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * Accesses the FileManager from the Root context.\n *\n * Use this composable to interact with the FileManager directly,\n * such as adding, retrieving, or managing files.\n *\n * @returns The current FileManager instance\n *\n * @example\n * ```ts\n * const fileManager = useFileManager()\n * fileManager.add({\n *   baseName: 'user.ts',\n *   path: './generated/user.ts',\n *   sources: []\n * })\n * ```\n */\nexport function useFileManager(): FileManager {\n  const { fileManager } = useContext(RootContext)\n\n  return fileManager\n}\n","import { useFile } from '../composables/useFile.ts'\nimport { useFileManager } from '../composables/useFileManager.ts'\nimport { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { FileContext } from '../contexts/FileContext.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { type ComponentBuilder, createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport { renderIntrinsic } from '../intrinsic.ts'\nimport { createExport, createImport, print } from '../parsers/typescriptParser.ts'\nimport type { KubbFile } from '../types.ts'\n\nexport type FileProps<TMeta extends object = object> = {\n  /**\n   * File name with extension.\n   *\n   * @example 'user.ts'\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Full path to the file including directory and file name.\n   *\n   * The path must include the baseName at the end.\n   *\n   * @example './generated/types/user.ts'\n   */\n  path: KubbFile.Path\n  /**\n   * Optional metadata attached to the file.\n   *\n   * Use this to store custom information about the file.\n   */\n  meta?: TMeta\n  /**\n   * Optional banner text added at the top of the file.\n   */\n  banner?: string\n  /**\n   * Optional footer text added at the bottom of the file.\n   */\n  footer?: string\n  /**\n   * Child components (File.Source, File.Import, File.Export).\n   */\n  children?: FabricNode\n}\n\n/**\n * Component for generating files with sources, imports, and exports.\n *\n * Creates files in the FileManager that can be written to disk.\n *\n * @example\n * ```tsx\n * <File baseName=\"user.ts\" path=\"./generated/user.ts\">\n *   <File.Source isExportable>\n *     export type User = {{ '{' }} id: number {{ '}' }}\n *   </File.Source>\n * </File>\n * ```\n */\nexport const File = createComponent('File', ({ children, ...props }: FileProps) => {\n  const { baseName, path, meta = {}, footer, banner } = props\n\n  const fileManager = useFileManager()\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'File', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const file: KubbFile.File = {\n    baseName,\n    path,\n    meta,\n    banner,\n    footer,\n    sources: [],\n    imports: [],\n    exports: [],\n  }\n\n  const [resolvedFile] = fileManager.add(file)\n  provide(FileContext, resolvedFile)\n\n  return children\n}) as ComponentBuilder<FileProps<object>> & { Source: typeof FileSource; Import: typeof FileImport; Export: typeof FileExport }\n\ntype FileSourceProps = Omit<KubbFile.Source, 'value'> & {\n  /**\n   * Source code content.\n   */\n  children?: FabricNode\n}\n\n/**\n * Adds source code to a file.\n *\n * Use this component inside a File component to add code blocks.\n *\n * @example\n * ```tsx\n * <File.Source isExportable name=\"User\">\n *   export type User = {{ '{' }} id: number {{ '}' }}\n * </File.Source>\n * ```\n */\nexport const FileSource = createComponent('FileSource', ({ children, ...props }: FileSourceProps) => {\n  const { name, isExportable, isIndexable, isTypeOnly } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileSource', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const value = renderIntrinsic(children)\n\n  if (file) {\n    file.sources.push({\n      name,\n      isExportable,\n      isIndexable,\n      isTypeOnly,\n      value,\n    })\n  }\n\n  return value\n})\n\nexport type FileExportProps = KubbFile.Export\n\n/**\n * Adds export statements to a file.\n *\n * Use this component to create re-exports from other files.\n *\n * @example\n * ```tsx\n * <File.Export name=\"User\" path=\"./types/user\" isTypeOnly />\n * ```\n */\nexport const FileExport = createComponent('FileExport', (props: FileExportProps) => {\n  const { name, path, isTypeOnly, asAlias } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileExport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.exports.push({\n      name,\n      path,\n      asAlias,\n      isTypeOnly,\n    })\n  }\n\n  return print(createExport({ name, path, isTypeOnly, asAlias }))\n})\n\nexport type FileImportProps = KubbFile.Import\n\n/**\n * Adds import statements to a file.\n *\n * Use this component to import types or values from other files.\n *\n * @example\n * ```tsx\n * <File.Import name=\"User\" path=\"./types/user\" isTypeOnly />\n * ```\n */\nexport const FileImport = createComponent('FileImport', (props: FileImportProps) => {\n  const { name, path, root, isNameSpace, isTypeOnly } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileImport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.imports.push({\n      name,\n      path,\n      root,\n      isNameSpace,\n      isTypeOnly,\n    })\n  }\n\n  return print(createImport({ name, path, root, isNameSpace, isTypeOnly }))\n})\n\nFile.Source = FileSource\nFile.Import = FileImport\nFile.Export = FileExport\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\n/**\n * Increases indentation level in the output.\n *\n * Use this component to add indentation for nested code blocks.\n * Typically paired with Dedent to control indentation levels.\n *\n * @example\n * ```tsx\n * <>\n *   function example() {'{'}<Br />\n *   <Indent />\n *     return true<Br />\n *   <Dedent />\n *   {'}'}\n * </>\n * ```\n */\nexport const Indent = createComponent('indent', () => {\n  return createIntrinsic('indent')\n})\nIndent.displayName = 'Indent'\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { type ComponentBuilder, createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\nimport { Br } from './Br.ts'\nimport { Dedent } from './Dedent.ts'\nimport { Indent } from './Indent.ts'\n\ntype FunctionProps = {\n  /**\n   * Name of the function.\n   */\n  name: string\n  /**\n   * Export with default keyword.\n   * - `true` generates `export default function`\n   * - `false` generates named export or no export\n   * @default false\n   */\n  default?: boolean\n  /**\n   * Function parameters.\n   *\n   * @example 'id: number, name: string'\n   */\n  params?: string\n  /**\n   * Export this function.\n   * - `true` generates `export function`\n   * - `false` generates internal function\n   * @default false\n   */\n  export?: boolean\n  /**\n   * Make the function async.\n   * - `true` adds async keyword and wraps return type in Promise\n   * - `false` generates synchronous function\n   * @default false\n   */\n  async?: boolean\n  /**\n   * TypeScript generics.\n   *\n   * @example 'T' or ['T', 'U']\n   */\n  generics?: string | string[]\n  /**\n   * Return type of the function.\n   *\n   * When async is true, this is automatically wrapped in Promise.\n   */\n  returnType?: string\n  /**\n   * JSDoc comments for the function.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Function body.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript function declaration.\n *\n * @example\n * ```tsx\n * <Function\n *   name=\"getUser\"\n *   export\n *   async\n *   params=\"id: number\"\n *   returnType=\"User\"\n * >\n *   return fetch(`/users/${id}`).then(r => r.json())\n * </Function>\n * ```\n */\nexport const Function = createComponent('Function', ({ children, ...props }: FunctionProps) => {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Function', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const parts: string[] = []\n\n  if (JSDoc?.comments) {\n    parts.push(createJSDoc({ comments: JSDoc.comments }))\n    parts.push('\\n')\n  }\n\n  if (canExport) {\n    parts.push('export ')\n  }\n\n  if (isDefault) {\n    parts.push('default ')\n  }\n\n  if (async) {\n    parts.push('async ')\n  }\n\n  parts.push(`function ${name}`)\n\n  if (generics) {\n    parts.push('<')\n    parts.push(Array.isArray(generics) ? generics.join(', ').trim() : generics)\n    parts.push('>')\n  }\n\n  parts.push(`(${params || ''})`)\n\n  if (returnType && !async) {\n    parts.push(`: ${returnType}`)\n  }\n\n  if (returnType && async) {\n    parts.push(`: Promise<${returnType}>`)\n  }\n\n  parts.push(' {')\n\n  if (children) {\n    return [parts.join(''), Br(), Indent(), children, Br(), Dedent(), '}']\n  }\n\n  return [parts.join(''), '}']\n}) as ComponentBuilder<FunctionProps> & { Arrow: typeof ArrowFunction }\n\nFunction.displayName = 'Function'\n\ntype ArrowFunctionProps = FunctionProps & {\n  /**\n   * Create Arrow function in one line\n   */\n  singleLine?: boolean\n}\n\n/**\n * ArrowFunction\n *\n * Builds an arrow function declaration string for the fsx renderer. Supports\n * the same options as `Function`. Use `singleLine` to produce a one-line\n * arrow expression.\n */\nconst ArrowFunction = createComponent('ArrowFunction', ({ children, ...props }: ArrowFunctionProps) => {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc, singleLine } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'ArrowFunction', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const parts: string[] = []\n\n  if (JSDoc?.comments) {\n    parts.push(createJSDoc({ comments: JSDoc.comments }))\n    parts.push('\\n')\n  }\n\n  if (canExport) {\n    parts.push('export ')\n  }\n\n  if (isDefault) {\n    parts.push('default ')\n  }\n\n  parts.push(`const ${name} = `)\n\n  if (async) {\n    parts.push('async ')\n  }\n\n  if (generics) {\n    parts.push('<')\n    parts.push(Array.isArray(generics) ? generics.join(', ').trim() : generics)\n    parts.push('>')\n  }\n\n  parts.push(`(${params || ''})`)\n\n  if (returnType && !async) {\n    parts.push(`: ${returnType}`)\n  }\n\n  if (returnType && async) {\n    parts.push(`: Promise<${returnType}>`)\n  }\n\n  if (singleLine) {\n    parts.push(` => ${children || ''}\\n`)\n    return parts.join('')\n  }\n\n  if (children) {\n    return [parts.join(''), ' => {', Br(), Indent(), children, Br(), Dedent(), '}']\n  }\n\n  return [parts.join(''), ' => {}']\n})\n\nArrowFunction.displayName = 'ArrowFunction'\nFunction.Arrow = ArrowFunction\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport { renderIntrinsic } from '../intrinsic.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type TypeProps = {\n  /**\n   * Name of the type (must start with a capital letter).\n   */\n  name: string\n  /**\n   * Export this type.\n   * - `true` generates `export type`\n   * - `false` generates internal type\n   * @default false\n   */\n  export?: boolean\n  /**\n   * JSDoc comments for the type.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Type definition.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript type declaration.\n *\n * @example\n * ```tsx\n * <Type name=\"User\" export>\n *   {'{'} id: number; name: string {'}'}\n * </Type>\n * ```\n */\nexport const Type = createComponent('Type', ({ children, ...props }: TypeProps) => {\n  const { name, export: canExport, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Type', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (name.charAt(0).toUpperCase() !== name.charAt(0)) {\n    throw new Error('Name should start with a capital letter (see TypeScript types)')\n  }\n\n  const value = renderIntrinsic(children)\n\n  let result = ''\n\n  if (JSDoc?.comments) {\n    result += createJSDoc({ comments: JSDoc.comments })\n    result += '\\n'\n  }\n\n  if (canExport) {\n    result += 'export '\n  }\n\n  result += `type ${name} = ${value || ''}`\n\n  return result\n})\n\nType.displayName = 'Type'\n","import { AppContext, type AppContextProps } from '../contexts/AppContext.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * Accesses the App context with metadata and exit function.\n *\n * Use this composable to access metadata defined in the App component\n * or to exit the rendering process early.\n *\n * @throws Error when no AppContext is available\n *\n * @example\n * ```ts\n * const { meta, exit } = useApp<{ version: string }>()\n * console.log(meta.version)\n * ```\n */\nexport function useApp<TMeta extends object = object>(): AppContextProps<TMeta> {\n  return useContext(AppContext) as AppContextProps<TMeta>\n}\n","import { RootContext } from '../contexts/RootContext.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * Accesses lifecycle helpers for controlling generation flow.\n *\n * Use this composable to exit the rendering process early or perform\n * cleanup operations.\n *\n * @returns Object with lifecycle methods (exit)\n *\n * @example\n * ```ts\n * const { exit } = useLifecycle()\n *\n * // Stop generation on error\n * if (invalidData) {\n *   exit(new Error('Invalid data'))\n * }\n * ```\n */\nexport function useLifecycle() {\n  const { exit } = useContext(RootContext)\n\n  return {\n    exit,\n  }\n}\n","import { isFunction } from 'remeda'\nimport type { Fabric, FabricConfig, FabricContext, FabricEvents, FabricOptions } from './Fabric.ts'\nimport { FileManager } from './FileManager.ts'\nimport type * as KubbFile from './KubbFile.ts'\nimport type { Parser } from './parsers/types.ts'\nimport type { Plugin } from './plugins/types.ts'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter.ts'\n\n/**\n * Creates a new Fabric instance for file generation.\n *\n * The Fabric instance provides methods for registering plugins,\n * adding files, and triggering file generation.\n *\n * @param config - Optional configuration object\n * @returns A new Fabric instance\n *\n * @example\n * ```ts\n * import { createFabric } from '@kubb/fabric-core'\n * import { fsPlugin } from '@kubb/fabric-core/plugins'\n * import { typescriptParser } from '@kubb/fabric-core/parsers'\n *\n * const fabric = createFabric()\n * fabric.use(fsPlugin)\n * fabric.use(typescriptParser)\n *\n * await fabric.addFile({\n *   baseName: 'user.ts',\n *   path: './generated/user.ts',\n *   sources: [{ value: 'export type User = {}', isExportable: true }],\n *    imports: [],\n *   exports: [],\n * })\n *\n * await fabric.write({ extension: { '.ts': '.ts' } })\n * ```\n */\nexport function createFabric<T extends FabricOptions>(config: FabricConfig<T> = { mode: 'sequential' } as FabricConfig<T>): Fabric<T> {\n  const events = new AsyncEventEmitter<FabricEvents>()\n  const installedPlugins = new Set<Plugin<any>>()\n  const installedParsers = new Map<KubbFile.Extname, Parser<any>>()\n  const installedParserNames = new Set<string>()\n  const fileManager = new FileManager({ events })\n\n  const context: FabricContext<T> = {\n    get files() {\n      return fileManager.files\n    },\n    async addFile(...files) {\n      await fileManager.add(...files)\n    },\n    config,\n    fileManager,\n    installedPlugins,\n    installedParsers,\n    on: events.on.bind(events),\n    off: events.off.bind(events),\n    onOnce: events.onOnce.bind(events),\n    removeAll: events.removeAll.bind(events),\n    emit: events.emit.bind(events),\n  } as FabricContext<T>\n\n  const fabric: Fabric<T> = {\n    context,\n    get files() {\n      return fileManager.files\n    },\n    async addFile(...files) {\n      await fileManager.add(...files)\n    },\n    async upsertFile(...files) {\n      await fileManager.upsert(...files)\n    },\n    async use(pluginOrParser, ...options) {\n      if (pluginOrParser.type === 'plugin') {\n        if (installedPlugins.has(pluginOrParser)) {\n          console.warn(`Plugin \"${pluginOrParser.name}\" already applied.`)\n        } else {\n          installedPlugins.add(pluginOrParser)\n        }\n\n        if (isFunction(pluginOrParser.inject)) {\n          const injecter = pluginOrParser.inject\n\n          const injected = (injecter as any)(context, ...options)\n          Object.assign(fabric, injected)\n        }\n      }\n\n      if (pluginOrParser.type === 'parser') {\n        if (installedParserNames.has(pluginOrParser.name)) {\n          console.warn(`Parser \"${pluginOrParser.name}\" already applied.`)\n        } else {\n          installedParserNames.add(pluginOrParser.name)\n        }\n\n        if (pluginOrParser.extNames) {\n          for (const extName of pluginOrParser.extNames) {\n            const existing = installedParsers.get(extName)\n            if (existing && existing.name !== pluginOrParser.name) {\n              console.warn(`Parser \"${pluginOrParser.name}\" is overriding parser \"${existing.name}\" for extension \"${extName}\".`)\n            }\n            installedParsers.set(extName, pluginOrParser)\n          }\n        }\n      }\n\n      if (isFunction(pluginOrParser.install)) {\n        const installer = pluginOrParser.install\n\n        await (installer as any)(context, ...options)\n      }\n\n      return fabric\n    },\n  } as Fabric<T>\n\n  return fabric\n}\n"],"mappings":"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"}