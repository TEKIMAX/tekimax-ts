import { n as __name } from "./chunk-Cq_TCZj9.js";
import { normalize, relative } from "node:path";

//#region src/utils/trimExtName.ts
function trimExtName(text) {
	return text.replace(/\.[^/.]+$/, "");
}

//#endregion
//#region src/parsers/defineParser.ts
/**
* Defines a Fabric parser with type safety.
*
* Use this function to create parsers that transform files based on
* their extension.
*
* @param parser - The parser configuration object
* @returns A typed parser ready to use with Fabric
*
* @example
* ```ts
* import { defineParser } from '@kubb/fabric-core'
*
* export const jsonParser = defineParser({
*   name: 'json-parser',
*   extensions: ['.json'],
*   async parse(source, meta) {
*     const data = JSON.parse(source)
*     return data
*   }
* })
* ```
*/
function defineParser(parser) {
	return {
		type: "parser",
		...parser
	};
}

//#endregion
//#region src/utils/getRelativePath.ts
function slash(path, platform = "linux") {
	const isWindowsPath = /^\\\\\?\\/.test(path);
	const normalizedPath = normalize(path);
	if (["linux", "mac"].includes(platform) && !isWindowsPath) return normalizedPath.replaceAll(/\\/g, "/").replace("../", "");
	return normalizedPath.replaceAll(/\\/g, "/").replace("../", "");
}
function getRelativePath(rootDir, filePath, platform = "linux") {
	if (!rootDir || !filePath) throw new Error(`Root and file should be filled in when retrieving the relativePath, ${rootDir || ""} ${filePath || ""}`);
	const slashedPath = slash(relative(rootDir, filePath), platform);
	if (slashedPath.startsWith("../")) return slashedPath;
	return `./${slashedPath}`;
}

//#endregion
export { defineParser as n, trimExtName as r, getRelativePath as t };
//# sourceMappingURL=getRelativePath-B46cm-1j.js.map