import { n as __name } from "./chunk-Cq_TCZj9.js";
import { A as Path, D as File$1, M as Source, O as Import, T as Export, _ as inject, b as FileManager, c as FabricOptions, d as renderIndent, f as renderIntrinsic, g as createContext, h as Context, j as ResolvedFile, n as FabricComponent, p as RenderContext, r as FabricConfig, s as FabricNode, t as Fabric, v as provide, w as BaseName, x as FileProcessor, y as unprovide } from "./Fabric-BvXmQNIJ.js";
import { n as useNodeTree, r as TreeNode, t as ComponentNode } from "./useNodeTree-b4DoGP4O.js";
import { n as RootContext, t as JSDoc } from "./types-02AmEaOf.js";

//#region src/createComponent.d.ts
type MakeChildrenOptional<T extends object> = T extends {
  children?: any;
} ? Omit<T, 'children'> & Partial<Pick<T, 'children'>> : T;
type ComponentBuilder<T extends object> = {
  (...args: unknown extends T ? [] : {} extends Omit<T, 'children'> ? [props?: MakeChildrenOptional<T>] : [props: MakeChildrenOptional<T>]): FabricComponent<T>;
  displayName?: string | undefined;
};
declare function createComponent<TProps extends object>(type: string, Component: (props: TProps) => FabricNode): ComponentBuilder<TProps>;
//#endregion
//#region src/components/App.d.ts
type AppProps<TMeta extends Object = Object> = {
  /**
   * Metadata attached to the App context.
   *
   * Use this to pass custom data to child components via useApp.
   */
  meta?: TMeta;
  /**
   * Child components.
   */
  children?: FabricNode;
};
/**
 * Container component providing App context with metadata and lifecycle.
 *
 * Use this component to wrap your application and provide shared metadata
 * that can be accessed by child components using the useApp composable.
 *
 * @example
 * ```tsx
 * <App meta={{ version: '1.0.0', author: 'John Doe' }}>
 *   <File baseName="user.ts" path="./user.ts">
 *     <File.Source>export type User = {}</File.Source>
 *   </File>
 * </App>
 * ```
 */
declare const App: ComponentBuilder<AppProps<Object>>;
//#endregion
//#region src/components/Br.d.ts
/**
 * Generates a line break in the output.
 *
 * Use this component to add newlines in generated code.
 *
 * @example
 * ```tsx
 * <>
 *   const x = 1
 *   <Br />
 *   const y = 2
 * </>
 * ```
 */
declare const Br: ComponentBuilder<object>;
//#endregion
//#region src/components/Const.d.ts
type ConstProps = {
  /**
   * Name of the constant.
   */
  name: string;
  /**
   * Export this constant.
   * - `true` generates `export const`
   * - `false` generates internal const
   * @default false
   */
  export?: boolean;
  /**
   * TypeScript type annotation.
   *
   * @example 'string' or 'User[]'
   */
  type?: string;
  /**
   * JSDoc comments for the constant.
   */
  JSDoc?: JSDoc;
  /**
   * Use const assertion.
   * - `true` adds `as const` for deep readonly
   * - `false` uses inferred or explicit type
   * @default false
   */
  asConst?: boolean;
  /**
   * Constant value.
   */
  children?: FabricNode;
};
/**
 * Generates a TypeScript constant declaration.
 *
 * @example
 * ```tsx
 * <Const name="API_URL" export type="string">
 *   'https://api.example.com'
 * </Const>
 * ```
 */
declare const Const: ComponentBuilder<ConstProps>;
//#endregion
//#region src/components/Dedent.d.ts
/**
 * Decreases indentation level in the output.
 *
 * Use this component to reduce indentation after an indented code block.
 * Typically paired with Indent to control indentation levels.
 *
 * @example
 * ```tsx
 * <>
 *   function example() {'{'}<Br />
 *   <Indent />
 *     return true<Br />
 *   <Dedent />
 *   {'}'}
 * </>
 * ```
 */
declare const Dedent: ComponentBuilder<object>;
//#endregion
//#region src/components/File.d.ts
type FileProps<TMeta extends object = object> = {
  /**
   * File name with extension.
   *
   * @example 'user.ts'
   */
  baseName: BaseName;
  /**
   * Full path to the file including directory and file name.
   *
   * The path must include the baseName at the end.
   *
   * @example './generated/types/user.ts'
   */
  path: Path;
  /**
   * Optional metadata attached to the file.
   *
   * Use this to store custom information about the file.
   */
  meta?: TMeta;
  /**
   * Optional banner text added at the top of the file.
   */
  banner?: string;
  /**
   * Optional footer text added at the bottom of the file.
   */
  footer?: string;
  /**
   * Child components (File.Source, File.Import, File.Export).
   */
  children?: FabricNode;
};
/**
 * Component for generating files with sources, imports, and exports.
 *
 * Creates files in the FileManager that can be written to disk.
 *
 * @example
 * ```tsx
 * <File baseName="user.ts" path="./generated/user.ts">
 *   <File.Source isExportable>
 *     export type User = {{ '{' }} id: number {{ '}' }}
 *   </File.Source>
 * </File>
 * ```
 */
declare const File: ComponentBuilder<FileProps<object>> & {
  Source: typeof FileSource;
  Import: typeof FileImport;
  Export: typeof FileExport;
};
type FileSourceProps = Omit<Source, 'value'> & {
  /**
   * Source code content.
   */
  children?: FabricNode;
};
/**
 * Adds source code to a file.
 *
 * Use this component inside a File component to add code blocks.
 *
 * @example
 * ```tsx
 * <File.Source isExportable name="User">
 *   export type User = {{ '{' }} id: number {{ '}' }}
 * </File.Source>
 * ```
 */
declare const FileSource: ComponentBuilder<FileSourceProps>;
/**
 * Adds export statements to a file.
 *
 * Use this component to create re-exports from other files.
 *
 * @example
 * ```tsx
 * <File.Export name="User" path="./types/user" isTypeOnly />
 * ```
 */
declare const FileExport: ComponentBuilder<Export>;
/**
 * Adds import statements to a file.
 *
 * Use this component to import types or values from other files.
 *
 * @example
 * ```tsx
 * <File.Import name="User" path="./types/user" isTypeOnly />
 * ```
 */
declare const FileImport: ComponentBuilder<Import>;
//#endregion
//#region src/components/Function.d.ts
type FunctionProps = {
  /**
   * Name of the function.
   */
  name: string;
  /**
   * Export with default keyword.
   * - `true` generates `export default function`
   * - `false` generates named export or no export
   * @default false
   */
  default?: boolean;
  /**
   * Function parameters.
   *
   * @example 'id: number, name: string'
   */
  params?: string;
  /**
   * Export this function.
   * - `true` generates `export function`
   * - `false` generates internal function
   * @default false
   */
  export?: boolean;
  /**
   * Make the function async.
   * - `true` adds async keyword and wraps return type in Promise
   * - `false` generates synchronous function
   * @default false
   */
  async?: boolean;
  /**
   * TypeScript generics.
   *
   * @example 'T' or ['T', 'U']
   */
  generics?: string | string[];
  /**
   * Return type of the function.
   *
   * When async is true, this is automatically wrapped in Promise.
   */
  returnType?: string;
  /**
   * JSDoc comments for the function.
   */
  JSDoc?: JSDoc;
  /**
   * Function body.
   */
  children?: FabricNode;
};
/**
 * Generates a TypeScript function declaration.
 *
 * @example
 * ```tsx
 * <Function
 *   name="getUser"
 *   export
 *   async
 *   params="id: number"
 *   returnType="User"
 * >
 *   return fetch(`/users/${id}`).then(r => r.json())
 * </Function>
 * ```
 */
declare const Function: ComponentBuilder<FunctionProps> & {
  Arrow: typeof ArrowFunction;
};
type ArrowFunctionProps = FunctionProps & {
  /**
   * Create Arrow function in one line
   */
  singleLine?: boolean;
};
/**
 * ArrowFunction
 *
 * Builds an arrow function declaration string for the fsx renderer. Supports
 * the same options as `Function`. Use `singleLine` to produce a one-line
 * arrow expression.
 */
declare const ArrowFunction: ComponentBuilder<ArrowFunctionProps>;
//#endregion
//#region src/components/Indent.d.ts
/**
 * Increases indentation level in the output.
 *
 * Use this component to add indentation for nested code blocks.
 * Typically paired with Dedent to control indentation levels.
 *
 * @example
 * ```tsx
 * <>
 *   function example() {'{'}<Br />
 *   <Indent />
 *     return true<Br />
 *   <Dedent />
 *   {'}'}
 * </>
 * ```
 */
declare const Indent: ComponentBuilder<object>;
//#endregion
//#region src/components/Root.d.ts
type RootProps = {
  /**
   * Callback to exit the Fabric application.
   *
   * Call this to stop rendering and clean up resources.
   */
  onExit: (error?: Error) => void;
  /**
   * Error handler for runtime exceptions.
   *
   * Receives errors thrown during component rendering.
   */
  onError: (error: Error) => void;
  /**
   * Tree structure representing the component hierarchy.
   *
   * Used internally for tracking component relationships.
   */
  treeNode: TreeNode<ComponentNode>;
  /**
   * FileManager instance for file operations.
   *
   * Manages all files created during rendering.
   */
  fileManager: FileManager;
  /**
   * Child components.
   */
  children?: FabricNode;
};
/**
 * Root component providing core Fabric runtime context.
 *
 * This component is typically used internally by the Fabric renderer.
 * It provides the root context including FileManager, error handling,
 * and lifecycle management.
 *
 * @example
 * ```tsx
 * <Root
 *   onExit={(error) => process.exit(error ? 1 : 0)}
 *   onError={(error) => console.error(error)}
 *   treeNode={treeNode}
 *   fileManager={fileManager}
 * >
 *   <App>
 *     Your components here
 *   </App>
 * </Root>
 * ```
 */
declare const Root: ComponentBuilder<RootProps>;
//#endregion
//#region src/components/Type.d.ts
type TypeProps = {
  /**
   * Name of the type (must start with a capital letter).
   */
  name: string;
  /**
   * Export this type.
   * - `true` generates `export type`
   * - `false` generates internal type
   * @default false
   */
  export?: boolean;
  /**
   * JSDoc comments for the type.
   */
  JSDoc?: JSDoc;
  /**
   * Type definition.
   */
  children?: FabricNode;
};
/**
 * Generates a TypeScript type declaration.
 *
 * @example
 * ```tsx
 * <Type name="User" export>
 *   {'{'} id: number; name: string {'}'}
 * </Type>
 * ```
 */
declare const Type: ComponentBuilder<TypeProps>;
//#endregion
//#region src/contexts/AppContext.d.ts
type AppContextProps<TMeta extends object = object> = {
  /**
   * Exit (unmount)
   */
  exit: (error?: Error) => void;
  meta: TMeta;
};
/**
 * Provides app-level metadata and lifecycle hooks (like `exit`) to
 * components and composables within a Fabric runtime.
 */
declare const AppContext: Context<AppContextProps<object>>;
//#endregion
//#region src/composables/useApp.d.ts
/**
 * Accesses the App context with metadata and exit function.
 *
 * Use this composable to access metadata defined in the App component
 * or to exit the rendering process early.
 *
 * @throws Error when no AppContext is available
 *
 * @example
 * ```ts
 * const { meta, exit } = useApp<{ version: string }>()
 * console.log(meta.version)
 * ```
 */
declare function useApp<TMeta extends object = object>(): AppContextProps<TMeta>;
//#endregion
//#region src/composables/useContext.d.ts
/**
 * React-style alias for inject
 *
 * @example
 * ```ts
 * const theme = useContext(ThemeContext) // type is inferred from ThemeContext
 * ```
 */
declare function useContext<T>(key: Context<T>): T;
declare function useContext<T, TValue = T>(key: Context<T>, defaultValue: TValue): NonNullable<T> | TValue;
//#endregion
//#region src/composables/useFile.d.ts
/**
 * Accesses the current File context.
 *
 * Use this composable to access or modify the current file's properties,
 * sources, imports, or exports.
 *
 * @returns The current file object or null if not within a File component
 *
 * @example
 * ```ts
 * const file = useFile()
 * if (file) {
 *   console.log(file.path)
 *   file.sources.push({ value: 'export const x = 1', isExportable: true })
 * }
 * ```
 */
declare function useFile(): ResolvedFile | null;
//#endregion
//#region src/composables/useFileManager.d.ts
/**
 * Accesses the FileManager from the Root context.
 *
 * Use this composable to interact with the FileManager directly,
 * such as adding, retrieving, or managing files.
 *
 * @returns The current FileManager instance
 *
 * @example
 * ```ts
 * const fileManager = useFileManager()
 * fileManager.add({
 *   baseName: 'user.ts',
 *   path: './generated/user.ts',
 *   sources: []
 * })
 * ```
 */
declare function useFileManager(): FileManager;
//#endregion
//#region src/composables/useLifecycle.d.ts
/**
 * Accesses lifecycle helpers for controlling generation flow.
 *
 * Use this composable to exit the rendering process early or perform
 * cleanup operations.
 *
 * @returns Object with lifecycle methods (exit)
 *
 * @example
 * ```ts
 * const { exit } = useLifecycle()
 *
 * // Stop generation on error
 * if (invalidData) {
 *   exit(new Error('Invalid data'))
 * }
 * ```
 */
declare function useLifecycle(): {
  exit: (error?: Error) => void;
};
//#endregion
//#region src/contexts/FileContext.d.ts
/**
 * Provides app-level metadata and lifecycle hooks (like `exit`) to
 * components and composables within a Fabric runtime.
 */
declare const FileContext: Context<ResolvedFile<object> | null>;
//#endregion
//#region src/contexts/NodeTreeContext.d.ts
/**
 * Context for having the current NodeTree
 */
declare const NodeTreeContext: Context<TreeNode<ComponentNode> | null>;
//#endregion
//#region src/createFabric.d.ts
/**
 * Creates a new Fabric instance for file generation.
 *
 * The Fabric instance provides methods for registering plugins,
 * adding files, and triggering file generation.
 *
 * @param config - Optional configuration object
 * @returns A new Fabric instance
 *
 * @example
 * ```ts
 * import { createFabric } from '@kubb/fabric-core'
 * import { fsPlugin } from '@kubb/fabric-core/plugins'
 * import { typescriptParser } from '@kubb/fabric-core/parsers'
 *
 * const fabric = createFabric()
 * fabric.use(fsPlugin)
 * fabric.use(typescriptParser)
 *
 * await fabric.addFile({
 *   baseName: 'user.ts',
 *   path: './generated/user.ts',
 *   sources: [{ value: 'export type User = {}', isExportable: true }],
 *    imports: [],
 *   exports: [],
 * })
 *
 * await fabric.write({ extension: { '.ts': '.ts' } })
 * ```
 */
declare function createFabric<T extends FabricOptions>(config?: FabricConfig<T>): Fabric<T>;
//#endregion
//#region src/createFile.d.ts
/**
 * Helper to create a file with name and id set
 */
declare function createFile<TMeta extends object = object>(file: File$1<TMeta>): ResolvedFile<TMeta>;
//#endregion
//#region src/utils/createJSDoc.d.ts
/**
 * Create JSDoc comment block from comments array
 */
declare function createJSDoc({
  comments
}: {
  comments: string[];
}): string;
//#endregion
//#region src/utils/getRelativePath.d.ts
declare function getRelativePath(rootDir?: string | null, filePath?: string | null, platform?: 'windows' | 'mac' | 'linux'): string;
//#endregion
export { App, AppContext, Br, Const, Dedent, type Fabric, File, FileContext, FileManager, FileProcessor, Function, Indent, NodeTreeContext, RenderContext, Root, RootContext, TreeNode, Type, createComponent, createContext, createFabric, createFile, createJSDoc, getRelativePath, inject, provide, renderIndent, renderIntrinsic, unprovide, useApp, useContext, useFile, useFileManager, useLifecycle, useNodeTree };
//# sourceMappingURL=index.d.ts.map