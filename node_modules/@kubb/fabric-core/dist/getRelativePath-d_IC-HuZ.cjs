//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", {
	value,
	configurable: true
});
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let node_path = require("node:path");

//#region src/utils/trimExtName.ts
function trimExtName(text) {
	return text.replace(/\.[^/.]+$/, "");
}

//#endregion
//#region src/parsers/defineParser.ts
/**
* Defines a Fabric parser with type safety.
*
* Use this function to create parsers that transform files based on
* their extension.
*
* @param parser - The parser configuration object
* @returns A typed parser ready to use with Fabric
*
* @example
* ```ts
* import { defineParser } from '@kubb/fabric-core'
*
* export const jsonParser = defineParser({
*   name: 'json-parser',
*   extensions: ['.json'],
*   async parse(source, meta) {
*     const data = JSON.parse(source)
*     return data
*   }
* })
* ```
*/
function defineParser(parser) {
	return {
		type: "parser",
		...parser
	};
}

//#endregion
//#region src/utils/getRelativePath.ts
function slash(path, platform = "linux") {
	const isWindowsPath = /^\\\\\?\\/.test(path);
	const normalizedPath = (0, node_path.normalize)(path);
	if (["linux", "mac"].includes(platform) && !isWindowsPath) return normalizedPath.replaceAll(/\\/g, "/").replace("../", "");
	return normalizedPath.replaceAll(/\\/g, "/").replace("../", "");
}
function getRelativePath(rootDir, filePath, platform = "linux") {
	if (!rootDir || !filePath) throw new Error(`Root and file should be filled in when retrieving the relativePath, ${rootDir || ""} ${filePath || ""}`);
	const slashedPath = slash((0, node_path.relative)(rootDir, filePath), platform);
	if (slashedPath.startsWith("../")) return slashedPath;
	return `./${slashedPath}`;
}

//#endregion
Object.defineProperty(exports, '__name', {
  enumerable: true,
  get: function () {
    return __name;
  }
});
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'defineParser', {
  enumerable: true,
  get: function () {
    return defineParser;
  }
});
Object.defineProperty(exports, 'getRelativePath', {
  enumerable: true,
  get: function () {
    return getRelativePath;
  }
});
Object.defineProperty(exports, 'trimExtName', {
  enumerable: true,
  get: function () {
    return trimExtName;
  }
});
//# sourceMappingURL=getRelativePath-d_IC-HuZ.cjs.map