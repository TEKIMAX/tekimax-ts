"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/index.ts
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function isEmptyObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !Object.keys(obj).length;
}
function isEmptyArray(arr) {
  return Array.isArray(arr) && arr.length === 0;
}
function removeUndefined(obj) {
  if (obj === void 0) {
    return void 0;
  }
  if (obj === null) {
    return null;
  }
  if (Array.isArray(obj)) {
    return obj.map(removeUndefined).filter((item) => item !== void 0);
  }
  if (typeof obj === "object") {
    const cleaned = {};
    Object.entries(obj).forEach(([key, value]) => {
      const cleanedValue = removeUndefined(value);
      if (cleanedValue !== void 0) {
        cleaned[key] = cleanedValue;
      }
    });
    return cleaned;
  }
  return obj;
}
function stripEmptyObjects(obj, options = {}) {
  const cleanObj = obj;
  if (obj === null && options.removeAllFalsy) {
    return void 0;
  }
  if (!isObject(obj) && !Array.isArray(cleanObj)) {
    return cleanObj;
  }
  if (!Array.isArray(cleanObj)) {
    Object.keys(cleanObj).forEach((key) => {
      let value = cleanObj[key];
      if (typeof value !== "object") {
        return;
      }
      if (value === null) {
        if (options.removeAllFalsy) {
          delete cleanObj[key];
        }
        return;
      }
      value = stripEmptyObjects(value, options);
      if (isEmptyObject(value)) {
        delete cleanObj[key];
      } else if (isEmptyArray(value) && !options.preserveEmptyArray) {
        delete cleanObj[key];
      } else {
        cleanObj[key] = value;
      }
    });
    return cleanObj;
  }
  cleanObj.forEach((o, idx) => {
    let value = o;
    if (typeof value === "object" && value !== null) {
      value = stripEmptyObjects(value, options);
      if (isEmptyObject(value)) {
        delete cleanObj[idx];
      } else if (isEmptyArray(value) && !options.preserveEmptyArray) {
        delete cleanObj[idx];
      } else {
        cleanObj[idx] = value;
      }
    } else if (value === null && (options.removeAllFalsy || !options.preserveNullishArrays)) {
      delete cleanObj[idx];
    }
  });
  return cleanObj.filter((el) => el !== void 0);
}
function removeUndefinedObjects(obj, options) {
  if (obj === void 0) {
    return void 0;
  }
  let withoutUndefined = _optionalChain([options, 'optionalAccess', _ => _.preserveNullishArrays]) ? removeUndefined(obj) : JSON.parse(JSON.stringify(obj));
  withoutUndefined = stripEmptyObjects(withoutUndefined, options);
  if (isEmptyObject(withoutUndefined) || isEmptyArray(withoutUndefined) && !_optionalChain([options, 'optionalAccess', _2 => _2.preserveEmptyArray]))
    return void 0;
  return withoutUndefined;
}


exports.default = removeUndefinedObjects;

module.exports = exports.default;
//# sourceMappingURL=index.js.map